/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package opamp.proto;

public final class Opamp {
  private Opamp() {}

  public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry) {}

  public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions((com.google.protobuf.ExtensionRegistryLite) registry);
  }

  /** Protobuf enum {@code opamp.proto.AgentToServerFlags} */
  public enum AgentToServerFlags implements com.google.protobuf.ProtocolMessageEnum {
    /** <code>AgentToServerFlags_Unspecified = 0;</code> */
    AgentToServerFlags_Unspecified(0),
    /**
     *
     *
     * <pre>
     * The Agent requests Server go generate a new instance_uid, which will
     * be sent back in ServerToAgent message
     * </pre>
     *
     * <code>AgentToServerFlags_RequestInstanceUid = 1;</code>
     */
    AgentToServerFlags_RequestInstanceUid(1),
    UNRECOGNIZED(-1),
    ;

    /** <code>AgentToServerFlags_Unspecified = 0;</code> */
    public static final int AgentToServerFlags_Unspecified_VALUE = 0;

    /**
     *
     *
     * <pre>
     * The Agent requests Server go generate a new instance_uid, which will
     * be sent back in ServerToAgent message
     * </pre>
     *
     * <code>AgentToServerFlags_RequestInstanceUid = 1;</code>
     */
    public static final int AgentToServerFlags_RequestInstanceUid_VALUE = 1;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static AgentToServerFlags valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AgentToServerFlags forNumber(int value) {
      switch (value) {
        case 0:
          return AgentToServerFlags_Unspecified;
        case 1:
          return AgentToServerFlags_RequestInstanceUid;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AgentToServerFlags>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AgentToServerFlags>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AgentToServerFlags>() {
              public AgentToServerFlags findValueByNumber(int number) {
                return AgentToServerFlags.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(0);
    }

    private static final AgentToServerFlags[] VALUES = values();

    public static AgentToServerFlags valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AgentToServerFlags(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.AgentToServerFlags)
  }

  /** Protobuf enum {@code opamp.proto.ServerToAgentFlags} */
  public enum ServerToAgentFlags implements com.google.protobuf.ProtocolMessageEnum {
    /** <code>ServerToAgentFlags_Unspecified = 0;</code> */
    ServerToAgentFlags_Unspecified(0),
    /**
     *
     *
     * <pre>
     * ReportFullState flag can be used by the Server if the Agent did not include the
     * particular bit of information in the last status report (which is an allowed
     * optimization) but the Server detects that it does not have it (e.g. was
     * restarted and lost state). The detection happens using
     * AgentToServer.sequence_num values.
     * The Server asks the Agent to report full status.
     * </pre>
     *
     * <code>ServerToAgentFlags_ReportFullState = 1;</code>
     */
    ServerToAgentFlags_ReportFullState(1),
    /**
     *
     *
     * <pre>
     * ReportAvailableComponents flag can be used by the server if the Agent did
     * not include the full AvailableComponents message, but only the hash.
     * If this flag is specified, the agent will populate available_components.components
     * with a full description of the agent's components.
     * Status: [Development]
     * </pre>
     *
     * <code>ServerToAgentFlags_ReportAvailableComponents = 2;</code>
     */
    ServerToAgentFlags_ReportAvailableComponents(2),
    UNRECOGNIZED(-1),
    ;

    /** <code>ServerToAgentFlags_Unspecified = 0;</code> */
    public static final int ServerToAgentFlags_Unspecified_VALUE = 0;

    /**
     *
     *
     * <pre>
     * ReportFullState flag can be used by the Server if the Agent did not include the
     * particular bit of information in the last status report (which is an allowed
     * optimization) but the Server detects that it does not have it (e.g. was
     * restarted and lost state). The detection happens using
     * AgentToServer.sequence_num values.
     * The Server asks the Agent to report full status.
     * </pre>
     *
     * <code>ServerToAgentFlags_ReportFullState = 1;</code>
     */
    public static final int ServerToAgentFlags_ReportFullState_VALUE = 1;

    /**
     *
     *
     * <pre>
     * ReportAvailableComponents flag can be used by the server if the Agent did
     * not include the full AvailableComponents message, but only the hash.
     * If this flag is specified, the agent will populate available_components.components
     * with a full description of the agent's components.
     * Status: [Development]
     * </pre>
     *
     * <code>ServerToAgentFlags_ReportAvailableComponents = 2;</code>
     */
    public static final int ServerToAgentFlags_ReportAvailableComponents_VALUE = 2;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static ServerToAgentFlags valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerToAgentFlags forNumber(int value) {
      switch (value) {
        case 0:
          return ServerToAgentFlags_Unspecified;
        case 1:
          return ServerToAgentFlags_ReportFullState;
        case 2:
          return ServerToAgentFlags_ReportAvailableComponents;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerToAgentFlags>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<ServerToAgentFlags>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ServerToAgentFlags>() {
              public ServerToAgentFlags findValueByNumber(int number) {
                return ServerToAgentFlags.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(1);
    }

    private static final ServerToAgentFlags[] VALUES = values();

    public static ServerToAgentFlags valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerToAgentFlags(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.ServerToAgentFlags)
  }

  /** Protobuf enum {@code opamp.proto.ServerCapabilities} */
  public enum ServerCapabilities implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>ServerCapabilities_Unspecified = 0;</code>
     */
    ServerCapabilities_Unspecified(0),
    /**
     *
     *
     * <pre>
     * The Server can accept status reports. This bit MUST be set, since all Server
     * MUST be able to accept status reports.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsStatus = 1;</code>
     */
    ServerCapabilities_AcceptsStatus(1),
    /**
     *
     *
     * <pre>
     * The Server can offer remote configuration to the Agent.
     * </pre>
     *
     * <code>ServerCapabilities_OffersRemoteConfig = 2;</code>
     */
    ServerCapabilities_OffersRemoteConfig(2),
    /**
     *
     *
     * <pre>
     * The Server can accept EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsEffectiveConfig = 4;</code>
     */
    ServerCapabilities_AcceptsEffectiveConfig(4),
    /**
     *
     *
     * <pre>
     * The Server can offer Packages.
     * Status: [Beta]
     * </pre>
     *
     * <code>ServerCapabilities_OffersPackages = 8;</code>
     */
    ServerCapabilities_OffersPackages(8),
    /**
     *
     *
     * <pre>
     * The Server can accept Packages status.
     * Status: [Beta]
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsPackagesStatus = 16;</code>
     */
    ServerCapabilities_AcceptsPackagesStatus(16),
    /**
     *
     *
     * <pre>
     * The Server can offer connection settings.
     * Status: [Beta]
     * </pre>
     *
     * <code>ServerCapabilities_OffersConnectionSettings = 32;</code>
     */
    ServerCapabilities_OffersConnectionSettings(32),
    /**
     *
     *
     * <pre>
     * The Server can accept ConnectionSettingsRequest and respond with an offer.
     * Status: [Development]
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsConnectionSettingsRequest = 64;</code>
     */
    ServerCapabilities_AcceptsConnectionSettingsRequest(64),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>ServerCapabilities_Unspecified = 0;</code>
     */
    public static final int ServerCapabilities_Unspecified_VALUE = 0;

    /**
     *
     *
     * <pre>
     * The Server can accept status reports. This bit MUST be set, since all Server
     * MUST be able to accept status reports.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsStatus = 1;</code>
     */
    public static final int ServerCapabilities_AcceptsStatus_VALUE = 1;

    /**
     *
     *
     * <pre>
     * The Server can offer remote configuration to the Agent.
     * </pre>
     *
     * <code>ServerCapabilities_OffersRemoteConfig = 2;</code>
     */
    public static final int ServerCapabilities_OffersRemoteConfig_VALUE = 2;

    /**
     *
     *
     * <pre>
     * The Server can accept EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsEffectiveConfig = 4;</code>
     */
    public static final int ServerCapabilities_AcceptsEffectiveConfig_VALUE = 4;

    /**
     *
     *
     * <pre>
     * The Server can offer Packages.
     * Status: [Beta]
     * </pre>
     *
     * <code>ServerCapabilities_OffersPackages = 8;</code>
     */
    public static final int ServerCapabilities_OffersPackages_VALUE = 8;

    /**
     *
     *
     * <pre>
     * The Server can accept Packages status.
     * Status: [Beta]
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsPackagesStatus = 16;</code>
     */
    public static final int ServerCapabilities_AcceptsPackagesStatus_VALUE = 16;

    /**
     *
     *
     * <pre>
     * The Server can offer connection settings.
     * Status: [Beta]
     * </pre>
     *
     * <code>ServerCapabilities_OffersConnectionSettings = 32;</code>
     */
    public static final int ServerCapabilities_OffersConnectionSettings_VALUE = 32;

    /**
     *
     *
     * <pre>
     * The Server can accept ConnectionSettingsRequest and respond with an offer.
     * Status: [Development]
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsConnectionSettingsRequest = 64;</code>
     */
    public static final int ServerCapabilities_AcceptsConnectionSettingsRequest_VALUE = 64;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static ServerCapabilities valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerCapabilities forNumber(int value) {
      switch (value) {
        case 0:
          return ServerCapabilities_Unspecified;
        case 1:
          return ServerCapabilities_AcceptsStatus;
        case 2:
          return ServerCapabilities_OffersRemoteConfig;
        case 4:
          return ServerCapabilities_AcceptsEffectiveConfig;
        case 8:
          return ServerCapabilities_OffersPackages;
        case 16:
          return ServerCapabilities_AcceptsPackagesStatus;
        case 32:
          return ServerCapabilities_OffersConnectionSettings;
        case 64:
          return ServerCapabilities_AcceptsConnectionSettingsRequest;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerCapabilities>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<ServerCapabilities>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ServerCapabilities>() {
              public ServerCapabilities findValueByNumber(int number) {
                return ServerCapabilities.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(2);
    }

    private static final ServerCapabilities[] VALUES = values();

    public static ServerCapabilities valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerCapabilities(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.ServerCapabilities)
  }

  /**
   *
   *
   * <pre>
   * The type of the package, either an addon or a top-level package.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf enum {@code opamp.proto.PackageType}
   */
  public enum PackageType implements com.google.protobuf.ProtocolMessageEnum {
    /** <code>PackageType_TopLevel = 0;</code> */
    PackageType_TopLevel(0),
    /** <code>PackageType_Addon = 1;</code> */
    PackageType_Addon(1),
    UNRECOGNIZED(-1),
    ;

    /** <code>PackageType_TopLevel = 0;</code> */
    public static final int PackageType_TopLevel_VALUE = 0;

    /** <code>PackageType_Addon = 1;</code> */
    public static final int PackageType_Addon_VALUE = 1;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static PackageType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static PackageType forNumber(int value) {
      switch (value) {
        case 0:
          return PackageType_TopLevel;
        case 1:
          return PackageType_Addon;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PackageType> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<PackageType> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<PackageType>() {
          public PackageType findValueByNumber(int number) {
            return PackageType.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(3);
    }

    private static final PackageType[] VALUES = values();

    public static PackageType valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private PackageType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.PackageType)
  }

  /** Protobuf enum {@code opamp.proto.ServerErrorResponseType} */
  public enum ServerErrorResponseType implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * Unknown error. Something went wrong, but it is not known what exactly.
     * The Agent SHOULD NOT retry the message.
     * The error_message field may contain a description of the problem.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unknown = 0;</code>
     */
    ServerErrorResponseType_Unknown(0),
    /**
     *
     *
     * <pre>
     * The AgentToServer message was malformed. The Agent SHOULD NOT retry
     * the message.
     * </pre>
     *
     * <code>ServerErrorResponseType_BadRequest = 1;</code>
     */
    ServerErrorResponseType_BadRequest(1),
    /**
     *
     *
     * <pre>
     * The Server is overloaded and unable to process the request. The Agent
     * should retry the message later. retry_info field may be optionally
     * set with additional information about retrying.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unavailable = 2;</code>
     */
    ServerErrorResponseType_Unavailable(2),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * Unknown error. Something went wrong, but it is not known what exactly.
     * The Agent SHOULD NOT retry the message.
     * The error_message field may contain a description of the problem.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unknown = 0;</code>
     */
    public static final int ServerErrorResponseType_Unknown_VALUE = 0;

    /**
     *
     *
     * <pre>
     * The AgentToServer message was malformed. The Agent SHOULD NOT retry
     * the message.
     * </pre>
     *
     * <code>ServerErrorResponseType_BadRequest = 1;</code>
     */
    public static final int ServerErrorResponseType_BadRequest_VALUE = 1;

    /**
     *
     *
     * <pre>
     * The Server is overloaded and unable to process the request. The Agent
     * should retry the message later. retry_info field may be optionally
     * set with additional information about retrying.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unavailable = 2;</code>
     */
    public static final int ServerErrorResponseType_Unavailable_VALUE = 2;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static ServerErrorResponseType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerErrorResponseType forNumber(int value) {
      switch (value) {
        case 0:
          return ServerErrorResponseType_Unknown;
        case 1:
          return ServerErrorResponseType_BadRequest;
        case 2:
          return ServerErrorResponseType_Unavailable;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerErrorResponseType>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<ServerErrorResponseType>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ServerErrorResponseType>() {
              public ServerErrorResponseType findValueByNumber(int number) {
                return ServerErrorResponseType.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(4);
    }

    private static final ServerErrorResponseType[] VALUES = values();

    public static ServerErrorResponseType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerErrorResponseType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.ServerErrorResponseType)
  }

  /**
   *
   *
   * <pre>
   * Status: [Beta]
   * </pre>
   *
   * Protobuf enum {@code opamp.proto.CommandType}
   */
  public enum CommandType implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * The Agent should restart. This request will be ignored if the Agent does not
     * support restart.
     * </pre>
     *
     * <code>CommandType_Restart = 0;</code>
     */
    CommandType_Restart(0),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * The Agent should restart. This request will be ignored if the Agent does not
     * support restart.
     * </pre>
     *
     * <code>CommandType_Restart = 0;</code>
     */
    public static final int CommandType_Restart_VALUE = 0;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static CommandType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CommandType forNumber(int value) {
      switch (value) {
        case 0:
          return CommandType_Restart;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CommandType> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<CommandType> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<CommandType>() {
          public CommandType findValueByNumber(int number) {
            return CommandType.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(5);
    }

    private static final CommandType[] VALUES = values();

    public static CommandType valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CommandType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.CommandType)
  }

  /** Protobuf enum {@code opamp.proto.AgentCapabilities} */
  public enum AgentCapabilities implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>AgentCapabilities_Unspecified = 0;</code>
     */
    AgentCapabilities_Unspecified(0),
    /**
     *
     *
     * <pre>
     * The Agent can report status. This bit MUST be set, since all Agents MUST
     * report status.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsStatus = 1;</code>
     */
    AgentCapabilities_ReportsStatus(1),
    /**
     *
     *
     * <pre>
     * The Agent can accept remote configuration from the Server.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRemoteConfig = 2;</code>
     */
    AgentCapabilities_AcceptsRemoteConfig(2),
    /**
     *
     *
     * <pre>
     * The Agent will report EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsEffectiveConfig = 4;</code>
     */
    AgentCapabilities_ReportsEffectiveConfig(4),
    /**
     *
     *
     * <pre>
     * The Agent can accept package offers.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsPackages = 8;</code>
     */
    AgentCapabilities_AcceptsPackages(8),
    /**
     *
     *
     * <pre>
     * The Agent can report package status.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsPackageStatuses = 16;</code>
     */
    AgentCapabilities_ReportsPackageStatuses(16),
    /**
     *
     *
     * <pre>
     * The Agent can report own trace to the destination specified by
     * the Server via ConnectionSettingsOffers.own_traces field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnTraces = 32;</code>
     */
    AgentCapabilities_ReportsOwnTraces(32),
    /**
     *
     *
     * <pre>
     * The Agent can report own metrics to the destination specified by
     * the Server via ConnectionSettingsOffers.own_metrics field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnMetrics = 64;</code>
     */
    AgentCapabilities_ReportsOwnMetrics(64),
    /**
     *
     *
     * <pre>
     * The Agent can report own logs to the destination specified by
     * the Server via ConnectionSettingsOffers.own_logs field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnLogs = 128;</code>
     */
    AgentCapabilities_ReportsOwnLogs(128),
    /**
     *
     *
     * <pre>
     * The can accept connections settings for OpAMP via
     * ConnectionSettingsOffers.opamp field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOpAMPConnectionSettings = 256;</code>
     */
    AgentCapabilities_AcceptsOpAMPConnectionSettings(256),
    /**
     *
     *
     * <pre>
     * The can accept connections settings for other destinations via
     * ConnectionSettingsOffers.other_connections field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOtherConnectionSettings = 512;</code>
     */
    AgentCapabilities_AcceptsOtherConnectionSettings(512),
    /**
     *
     *
     * <pre>
     * The Agent can accept restart requests.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRestartCommand = 1024;</code>
     */
    AgentCapabilities_AcceptsRestartCommand(1024),
    /**
     *
     *
     * <pre>
     * The Agent will report Health via AgentToServer.health field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsHealth = 2048;</code>
     */
    AgentCapabilities_ReportsHealth(2048),
    /**
     *
     *
     * <pre>
     * The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsRemoteConfig = 4096;</code>
     */
    AgentCapabilities_ReportsRemoteConfig(4096),
    /**
     *
     *
     * <pre>
     * The Agent can report heartbeats.
     * This is specified by the ServerToAgent.OpAMPConnectionSettings.heartbeat_interval_seconds field.
     * If this capability is true, but the Server does not set a heartbeat_interval_seconds field, the
     * Agent should use its own configured interval, which by default will be 30s. The Server may not
     * know the configured interval and should not make assumptions about it.
     * Status: [Development]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsHeartbeat = 8192;</code>
     */
    AgentCapabilities_ReportsHeartbeat(8192),
    /**
     *
     *
     * <pre>
     * The agent will report AvailableComponents via the AgentToServer.available_components field.
     * Status: [Development]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsAvailableComponents = 16384;</code>
     */
    AgentCapabilities_ReportsAvailableComponents(16384),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>AgentCapabilities_Unspecified = 0;</code>
     */
    public static final int AgentCapabilities_Unspecified_VALUE = 0;

    /**
     *
     *
     * <pre>
     * The Agent can report status. This bit MUST be set, since all Agents MUST
     * report status.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsStatus = 1;</code>
     */
    public static final int AgentCapabilities_ReportsStatus_VALUE = 1;

    /**
     *
     *
     * <pre>
     * The Agent can accept remote configuration from the Server.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRemoteConfig = 2;</code>
     */
    public static final int AgentCapabilities_AcceptsRemoteConfig_VALUE = 2;

    /**
     *
     *
     * <pre>
     * The Agent will report EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsEffectiveConfig = 4;</code>
     */
    public static final int AgentCapabilities_ReportsEffectiveConfig_VALUE = 4;

    /**
     *
     *
     * <pre>
     * The Agent can accept package offers.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsPackages = 8;</code>
     */
    public static final int AgentCapabilities_AcceptsPackages_VALUE = 8;

    /**
     *
     *
     * <pre>
     * The Agent can report package status.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsPackageStatuses = 16;</code>
     */
    public static final int AgentCapabilities_ReportsPackageStatuses_VALUE = 16;

    /**
     *
     *
     * <pre>
     * The Agent can report own trace to the destination specified by
     * the Server via ConnectionSettingsOffers.own_traces field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnTraces = 32;</code>
     */
    public static final int AgentCapabilities_ReportsOwnTraces_VALUE = 32;

    /**
     *
     *
     * <pre>
     * The Agent can report own metrics to the destination specified by
     * the Server via ConnectionSettingsOffers.own_metrics field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnMetrics = 64;</code>
     */
    public static final int AgentCapabilities_ReportsOwnMetrics_VALUE = 64;

    /**
     *
     *
     * <pre>
     * The Agent can report own logs to the destination specified by
     * the Server via ConnectionSettingsOffers.own_logs field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnLogs = 128;</code>
     */
    public static final int AgentCapabilities_ReportsOwnLogs_VALUE = 128;

    /**
     *
     *
     * <pre>
     * The can accept connections settings for OpAMP via
     * ConnectionSettingsOffers.opamp field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOpAMPConnectionSettings = 256;</code>
     */
    public static final int AgentCapabilities_AcceptsOpAMPConnectionSettings_VALUE = 256;

    /**
     *
     *
     * <pre>
     * The can accept connections settings for other destinations via
     * ConnectionSettingsOffers.other_connections field.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOtherConnectionSettings = 512;</code>
     */
    public static final int AgentCapabilities_AcceptsOtherConnectionSettings_VALUE = 512;

    /**
     *
     *
     * <pre>
     * The Agent can accept restart requests.
     * Status: [Beta]
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRestartCommand = 1024;</code>
     */
    public static final int AgentCapabilities_AcceptsRestartCommand_VALUE = 1024;

    /**
     *
     *
     * <pre>
     * The Agent will report Health via AgentToServer.health field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsHealth = 2048;</code>
     */
    public static final int AgentCapabilities_ReportsHealth_VALUE = 2048;

    /**
     *
     *
     * <pre>
     * The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsRemoteConfig = 4096;</code>
     */
    public static final int AgentCapabilities_ReportsRemoteConfig_VALUE = 4096;

    /**
     *
     *
     * <pre>
     * The Agent can report heartbeats.
     * This is specified by the ServerToAgent.OpAMPConnectionSettings.heartbeat_interval_seconds field.
     * If this capability is true, but the Server does not set a heartbeat_interval_seconds field, the
     * Agent should use its own configured interval, which by default will be 30s. The Server may not
     * know the configured interval and should not make assumptions about it.
     * Status: [Development]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsHeartbeat = 8192;</code>
     */
    public static final int AgentCapabilities_ReportsHeartbeat_VALUE = 8192;

    /**
     *
     *
     * <pre>
     * The agent will report AvailableComponents via the AgentToServer.available_components field.
     * Status: [Development]
     * </pre>
     *
     * <code>AgentCapabilities_ReportsAvailableComponents = 16384;</code>
     */
    public static final int AgentCapabilities_ReportsAvailableComponents_VALUE = 16384;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static AgentCapabilities valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AgentCapabilities forNumber(int value) {
      switch (value) {
        case 0:
          return AgentCapabilities_Unspecified;
        case 1:
          return AgentCapabilities_ReportsStatus;
        case 2:
          return AgentCapabilities_AcceptsRemoteConfig;
        case 4:
          return AgentCapabilities_ReportsEffectiveConfig;
        case 8:
          return AgentCapabilities_AcceptsPackages;
        case 16:
          return AgentCapabilities_ReportsPackageStatuses;
        case 32:
          return AgentCapabilities_ReportsOwnTraces;
        case 64:
          return AgentCapabilities_ReportsOwnMetrics;
        case 128:
          return AgentCapabilities_ReportsOwnLogs;
        case 256:
          return AgentCapabilities_AcceptsOpAMPConnectionSettings;
        case 512:
          return AgentCapabilities_AcceptsOtherConnectionSettings;
        case 1024:
          return AgentCapabilities_AcceptsRestartCommand;
        case 2048:
          return AgentCapabilities_ReportsHealth;
        case 4096:
          return AgentCapabilities_ReportsRemoteConfig;
        case 8192:
          return AgentCapabilities_ReportsHeartbeat;
        case 16384:
          return AgentCapabilities_ReportsAvailableComponents;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AgentCapabilities>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<AgentCapabilities>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AgentCapabilities>() {
              public AgentCapabilities findValueByNumber(int number) {
                return AgentCapabilities.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(6);
    }

    private static final AgentCapabilities[] VALUES = values();

    public static AgentCapabilities valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AgentCapabilities(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.AgentCapabilities)
  }

  /** Protobuf enum {@code opamp.proto.RemoteConfigStatuses} */
  public enum RemoteConfigStatuses implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * The value of status field is not set.
     * </pre>
     *
     * <code>RemoteConfigStatuses_UNSET = 0;</code>
     */
    RemoteConfigStatuses_UNSET(0),
    /**
     *
     *
     * <pre>
     * Remote config was successfully applied by the Agent.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLIED = 1;</code>
     */
    RemoteConfigStatuses_APPLIED(1),
    /**
     *
     *
     * <pre>
     * Agent is currently applying the remote config that it received earlier.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLYING = 2;</code>
     */
    RemoteConfigStatuses_APPLYING(2),
    /**
     *
     *
     * <pre>
     * Agent tried to apply the config received earlier, but it failed.
     * See error_message for more details.
     * </pre>
     *
     * <code>RemoteConfigStatuses_FAILED = 3;</code>
     */
    RemoteConfigStatuses_FAILED(3),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * The value of status field is not set.
     * </pre>
     *
     * <code>RemoteConfigStatuses_UNSET = 0;</code>
     */
    public static final int RemoteConfigStatuses_UNSET_VALUE = 0;

    /**
     *
     *
     * <pre>
     * Remote config was successfully applied by the Agent.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLIED = 1;</code>
     */
    public static final int RemoteConfigStatuses_APPLIED_VALUE = 1;

    /**
     *
     *
     * <pre>
     * Agent is currently applying the remote config that it received earlier.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLYING = 2;</code>
     */
    public static final int RemoteConfigStatuses_APPLYING_VALUE = 2;

    /**
     *
     *
     * <pre>
     * Agent tried to apply the config received earlier, but it failed.
     * See error_message for more details.
     * </pre>
     *
     * <code>RemoteConfigStatuses_FAILED = 3;</code>
     */
    public static final int RemoteConfigStatuses_FAILED_VALUE = 3;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static RemoteConfigStatuses valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static RemoteConfigStatuses forNumber(int value) {
      switch (value) {
        case 0:
          return RemoteConfigStatuses_UNSET;
        case 1:
          return RemoteConfigStatuses_APPLIED;
        case 2:
          return RemoteConfigStatuses_APPLYING;
        case 3:
          return RemoteConfigStatuses_FAILED;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<RemoteConfigStatuses>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<RemoteConfigStatuses>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<RemoteConfigStatuses>() {
              public RemoteConfigStatuses findValueByNumber(int number) {
                return RemoteConfigStatuses.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(7);
    }

    private static final RemoteConfigStatuses[] VALUES = values();

    public static RemoteConfigStatuses valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private RemoteConfigStatuses(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.RemoteConfigStatuses)
  }

  /**
   *
   *
   * <pre>
   * The status of this package.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf enum {@code opamp.proto.PackageStatusEnum}
   */
  public enum PackageStatusEnum implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * Package is successfully installed by the Agent.
     * The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installed = 0;</code>
     */
    PackageStatusEnum_Installed(0),
    /**
     *
     *
     * <pre>
     * Installation of this package has not yet started.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallPending = 1;</code>
     */
    PackageStatusEnum_InstallPending(1),
    /**
     *
     *
     * <pre>
     * Agent is currently installing the package.
     * server_offered_hash field MUST be set to indicate the version that the
     * Agent is installing. The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installing = 2;</code>
     */
    PackageStatusEnum_Installing(2),
    /**
     *
     *
     * <pre>
     * Agent tried to install the package but installation failed.
     * server_offered_hash field MUST be set to indicate the version that the Agent
     * tried to install. The error_message may also contain more details about
     * the failure.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallFailed = 3;</code>
     */
    PackageStatusEnum_InstallFailed(3),
    /**
     *
     *
     * <pre>
     * Agent is currently downloading the package.
     * server_offered_hash field MUST be set to indicate the version that the
     * Agent is installing. The error_message field MUST NOT be set.
     * Status: [Development]
     * </pre>
     *
     * <code>PackageStatusEnum_Downloading = 4;</code>
     */
    PackageStatusEnum_Downloading(4),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * Package is successfully installed by the Agent.
     * The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installed = 0;</code>
     */
    public static final int PackageStatusEnum_Installed_VALUE = 0;

    /**
     *
     *
     * <pre>
     * Installation of this package has not yet started.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallPending = 1;</code>
     */
    public static final int PackageStatusEnum_InstallPending_VALUE = 1;

    /**
     *
     *
     * <pre>
     * Agent is currently installing the package.
     * server_offered_hash field MUST be set to indicate the version that the
     * Agent is installing. The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installing = 2;</code>
     */
    public static final int PackageStatusEnum_Installing_VALUE = 2;

    /**
     *
     *
     * <pre>
     * Agent tried to install the package but installation failed.
     * server_offered_hash field MUST be set to indicate the version that the Agent
     * tried to install. The error_message may also contain more details about
     * the failure.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallFailed = 3;</code>
     */
    public static final int PackageStatusEnum_InstallFailed_VALUE = 3;

    /**
     *
     *
     * <pre>
     * Agent is currently downloading the package.
     * server_offered_hash field MUST be set to indicate the version that the
     * Agent is installing. The error_message field MUST NOT be set.
     * Status: [Development]
     * </pre>
     *
     * <code>PackageStatusEnum_Downloading = 4;</code>
     */
    public static final int PackageStatusEnum_Downloading_VALUE = 4;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new IllegalArgumentException("Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static PackageStatusEnum valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static PackageStatusEnum forNumber(int value) {
      switch (value) {
        case 0:
          return PackageStatusEnum_Installed;
        case 1:
          return PackageStatusEnum_InstallPending;
        case 2:
          return PackageStatusEnum_Installing;
        case 3:
          return PackageStatusEnum_InstallFailed;
        case 4:
          return PackageStatusEnum_Downloading;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PackageStatusEnum>
        internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<PackageStatusEnum>
        internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PackageStatusEnum>() {
              public PackageStatusEnum findValueByNumber(int number) {
                return PackageStatusEnum.forNumber(number);
              }
            };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new IllegalStateException("Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return Opamp.getDescriptor().getEnumTypes().get(8);
    }

    private static final PackageStatusEnum[] VALUES = values();

    public static PackageStatusEnum valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private PackageStatusEnum(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.PackageStatusEnum)
  }

  public interface AgentToServerOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentToServer)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Globally unique identifier of the running instance of the Agent. SHOULD remain
     * unchanged for the lifetime of the Agent process.
     * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
     * </pre>
     *
     * <code>bytes instance_uid = 1;</code>
     *
     * @return The instanceUid.
     */
    com.google.protobuf.ByteString getInstanceUid();

    /**
     *
     *
     * <pre>
     * The sequence number is incremented by 1 for every AgentToServer sent
     * by the Agent. This allows the Server to detect that it missed a message when
     * it notices that the sequence_num is not exactly by 1 greater than the previously
     * received one.
     * </pre>
     *
     * <code>uint64 sequence_num = 2;</code>
     *
     * @return The sequenceNum.
     */
    long getSequenceNum();

    /**
     *
     *
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     *
     * @return Whether the agentDescription field is set.
     */
    boolean hasAgentDescription();

    /**
     *
     *
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     *
     * @return The agentDescription.
     */
    AgentDescription getAgentDescription();

    /**
     *
     *
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     */
    AgentDescriptionOrBuilder getAgentDescriptionOrBuilder();

    /**
     *
     *
     * <pre>
     * Bitmask of flags defined by AgentCapabilities enum.
     * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
     * the Agent. This allows extending the protocol and the AgentCapabilities enum
     * in the future such that old Agents automatically report that they don't
     * support the new capability.
     * This field MUST be always set.
     * </pre>
     *
     * <code>uint64 capabilities = 4;</code>
     *
     * @return The capabilities.
     */
    long getCapabilities();

    /**
     *
     *
     * <pre>
     * The current health of the Agent and sub-components. The top-level ComponentHealth represents
     * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
     * message.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ComponentHealth health = 5;</code>
     *
     * @return Whether the health field is set.
     */
    boolean hasHealth();

    /**
     *
     *
     * <pre>
     * The current health of the Agent and sub-components. The top-level ComponentHealth represents
     * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
     * message.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ComponentHealth health = 5;</code>
     *
     * @return The health.
     */
    ComponentHealth getHealth();

    /**
     *
     *
     * <pre>
     * The current health of the Agent and sub-components. The top-level ComponentHealth represents
     * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
     * message.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ComponentHealth health = 5;</code>
     */
    ComponentHealthOrBuilder getHealthOrBuilder();

    /**
     *
     *
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     *
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     *
     * @return Whether the effectiveConfig field is set.
     */
    boolean hasEffectiveConfig();

    /**
     *
     *
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     *
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     *
     * @return The effectiveConfig.
     */
    EffectiveConfig getEffectiveConfig();

    /**
     *
     *
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     *
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     */
    EffectiveConfigOrBuilder getEffectiveConfigOrBuilder();

    /**
     *
     *
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     *
     * @return Whether the remoteConfigStatus field is set.
     */
    boolean hasRemoteConfigStatus();

    /**
     *
     *
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     *
     * @return The remoteConfigStatus.
     */
    RemoteConfigStatus getRemoteConfigStatus();

    /**
     *
     *
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     */
    RemoteConfigStatusOrBuilder getRemoteConfigStatusOrBuilder();

    /**
     *
     *
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     *
     * @return Whether the packageStatuses field is set.
     */
    boolean hasPackageStatuses();

    /**
     *
     *
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     *
     * @return The packageStatuses.
     */
    PackageStatuses getPackageStatuses();

    /**
     *
     *
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     */
    PackageStatusesOrBuilder getPackageStatusesOrBuilder();

    /**
     *
     *
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     *
     * @return Whether the agentDisconnect field is set.
     */
    boolean hasAgentDisconnect();

    /**
     *
     *
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     *
     * @return The agentDisconnect.
     */
    AgentDisconnect getAgentDisconnect();

    /**
     *
     *
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     */
    AgentDisconnectOrBuilder getAgentDisconnectOrBuilder();

    /**
     *
     *
     * <pre>
     * Bit flags as defined by AgentToServerFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 10;</code>
     *
     * @return The flags.
     */
    long getFlags();

    /**
     *
     *
     * <pre>
     * A request to create connection settings. This field is set for flows where
     * the Agent initiates the creation of connection settings.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
     *
     * @return Whether the connectionSettingsRequest field is set.
     */
    boolean hasConnectionSettingsRequest();

    /**
     *
     *
     * <pre>
     * A request to create connection settings. This field is set for flows where
     * the Agent initiates the creation of connection settings.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
     *
     * @return The connectionSettingsRequest.
     */
    ConnectionSettingsRequest getConnectionSettingsRequest();

    /**
     *
     *
     * <pre>
     * A request to create connection settings. This field is set for flows where
     * the Agent initiates the creation of connection settings.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
     */
    ConnectionSettingsRequestOrBuilder getConnectionSettingsRequestOrBuilder();

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
     *
     * @return Whether the customCapabilities field is set.
     */
    boolean hasCustomCapabilities();

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
     *
     * @return The customCapabilities.
     */
    CustomCapabilities getCustomCapabilities();

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
     */
    CustomCapabilitiesOrBuilder getCustomCapabilitiesOrBuilder();

    /**
     *
     *
     * <pre>
     * A custom message sent from an Agent to the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
     *
     * @return Whether the customMessage field is set.
     */
    boolean hasCustomMessage();

    /**
     *
     *
     * <pre>
     * A custom message sent from an Agent to the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
     *
     * @return The customMessage.
     */
    CustomMessage getCustomMessage();

    /**
     *
     *
     * <pre>
     * A custom message sent from an Agent to the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
     */
    CustomMessageOrBuilder getCustomMessageOrBuilder();

    /**
     *
     *
     * <pre>
     * A message indicating the components that are available for configuration on the agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
     *
     * @return Whether the availableComponents field is set.
     */
    boolean hasAvailableComponents();

    /**
     *
     *
     * <pre>
     * A message indicating the components that are available for configuration on the agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
     *
     * @return The availableComponents.
     */
    AvailableComponents getAvailableComponents();

    /**
     *
     *
     * <pre>
     * A message indicating the components that are available for configuration on the agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
     */
    AvailableComponentsOrBuilder getAvailableComponentsOrBuilder();
  }

  /** Protobuf type {@code opamp.proto.AgentToServer} */
  public static final class AgentToServer extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentToServer)
      AgentToServerOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentToServer.newBuilder() to construct.
    private AgentToServer(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentToServer() {
      instanceUid_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentToServer();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentToServer_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentToServer_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentToServer.class, Builder.class);
    }

    private int bitField0_;
    public static final int INSTANCE_UID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString instanceUid_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Globally unique identifier of the running instance of the Agent. SHOULD remain
     * unchanged for the lifetime of the Agent process.
     * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
     * </pre>
     *
     * <code>bytes instance_uid = 1;</code>
     *
     * @return The instanceUid.
     */
    @Override
    public com.google.protobuf.ByteString getInstanceUid() {
      return instanceUid_;
    }

    public static final int SEQUENCE_NUM_FIELD_NUMBER = 2;
    private long sequenceNum_ = 0L;

    /**
     *
     *
     * <pre>
     * The sequence number is incremented by 1 for every AgentToServer sent
     * by the Agent. This allows the Server to detect that it missed a message when
     * it notices that the sequence_num is not exactly by 1 greater than the previously
     * received one.
     * </pre>
     *
     * <code>uint64 sequence_num = 2;</code>
     *
     * @return The sequenceNum.
     */
    @Override
    public long getSequenceNum() {
      return sequenceNum_;
    }

    public static final int AGENT_DESCRIPTION_FIELD_NUMBER = 3;
    private AgentDescription agentDescription_;

    /**
     *
     *
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     *
     * @return Whether the agentDescription field is set.
     */
    @Override
    public boolean hasAgentDescription() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     *
     * @return The agentDescription.
     */
    @Override
    public AgentDescription getAgentDescription() {
      return agentDescription_ == null ? AgentDescription.getDefaultInstance() : agentDescription_;
    }

    /**
     *
     *
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     */
    @Override
    public AgentDescriptionOrBuilder getAgentDescriptionOrBuilder() {
      return agentDescription_ == null ? AgentDescription.getDefaultInstance() : agentDescription_;
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 4;
    private long capabilities_ = 0L;

    /**
     *
     *
     * <pre>
     * Bitmask of flags defined by AgentCapabilities enum.
     * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
     * the Agent. This allows extending the protocol and the AgentCapabilities enum
     * in the future such that old Agents automatically report that they don't
     * support the new capability.
     * This field MUST be always set.
     * </pre>
     *
     * <code>uint64 capabilities = 4;</code>
     *
     * @return The capabilities.
     */
    @Override
    public long getCapabilities() {
      return capabilities_;
    }

    public static final int HEALTH_FIELD_NUMBER = 5;
    private ComponentHealth health_;

    /**
     *
     *
     * <pre>
     * The current health of the Agent and sub-components. The top-level ComponentHealth represents
     * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
     * message.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ComponentHealth health = 5;</code>
     *
     * @return Whether the health field is set.
     */
    @Override
    public boolean hasHealth() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * The current health of the Agent and sub-components. The top-level ComponentHealth represents
     * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
     * message.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ComponentHealth health = 5;</code>
     *
     * @return The health.
     */
    @Override
    public ComponentHealth getHealth() {
      return health_ == null ? ComponentHealth.getDefaultInstance() : health_;
    }

    /**
     *
     *
     * <pre>
     * The current health of the Agent and sub-components. The top-level ComponentHealth represents
     * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
     * message.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ComponentHealth health = 5;</code>
     */
    @Override
    public ComponentHealthOrBuilder getHealthOrBuilder() {
      return health_ == null ? ComponentHealth.getDefaultInstance() : health_;
    }

    public static final int EFFECTIVE_CONFIG_FIELD_NUMBER = 6;
    private EffectiveConfig effectiveConfig_;

    /**
     *
     *
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     *
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     *
     * @return Whether the effectiveConfig field is set.
     */
    @Override
    public boolean hasEffectiveConfig() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     *
     *
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     *
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     *
     * @return The effectiveConfig.
     */
    @Override
    public EffectiveConfig getEffectiveConfig() {
      return effectiveConfig_ == null ? EffectiveConfig.getDefaultInstance() : effectiveConfig_;
    }

    /**
     *
     *
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     *
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     */
    @Override
    public EffectiveConfigOrBuilder getEffectiveConfigOrBuilder() {
      return effectiveConfig_ == null ? EffectiveConfig.getDefaultInstance() : effectiveConfig_;
    }

    public static final int REMOTE_CONFIG_STATUS_FIELD_NUMBER = 7;
    private RemoteConfigStatus remoteConfigStatus_;

    /**
     *
     *
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     *
     * @return Whether the remoteConfigStatus field is set.
     */
    @Override
    public boolean hasRemoteConfigStatus() {
      return ((bitField0_ & 0x00000008) != 0);
    }

    /**
     *
     *
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     *
     * @return The remoteConfigStatus.
     */
    @Override
    public RemoteConfigStatus getRemoteConfigStatus() {
      return remoteConfigStatus_ == null
          ? RemoteConfigStatus.getDefaultInstance()
          : remoteConfigStatus_;
    }

    /**
     *
     *
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     */
    @Override
    public RemoteConfigStatusOrBuilder getRemoteConfigStatusOrBuilder() {
      return remoteConfigStatus_ == null
          ? RemoteConfigStatus.getDefaultInstance()
          : remoteConfigStatus_;
    }

    public static final int PACKAGE_STATUSES_FIELD_NUMBER = 8;
    private PackageStatuses packageStatuses_;

    /**
     *
     *
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     *
     * @return Whether the packageStatuses field is set.
     */
    @Override
    public boolean hasPackageStatuses() {
      return ((bitField0_ & 0x00000010) != 0);
    }

    /**
     *
     *
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     *
     * @return The packageStatuses.
     */
    @Override
    public PackageStatuses getPackageStatuses() {
      return packageStatuses_ == null ? PackageStatuses.getDefaultInstance() : packageStatuses_;
    }

    /**
     *
     *
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     */
    @Override
    public PackageStatusesOrBuilder getPackageStatusesOrBuilder() {
      return packageStatuses_ == null ? PackageStatuses.getDefaultInstance() : packageStatuses_;
    }

    public static final int AGENT_DISCONNECT_FIELD_NUMBER = 9;
    private AgentDisconnect agentDisconnect_;

    /**
     *
     *
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     *
     * @return Whether the agentDisconnect field is set.
     */
    @Override
    public boolean hasAgentDisconnect() {
      return ((bitField0_ & 0x00000020) != 0);
    }

    /**
     *
     *
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     *
     * @return The agentDisconnect.
     */
    @Override
    public AgentDisconnect getAgentDisconnect() {
      return agentDisconnect_ == null ? AgentDisconnect.getDefaultInstance() : agentDisconnect_;
    }

    /**
     *
     *
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     */
    @Override
    public AgentDisconnectOrBuilder getAgentDisconnectOrBuilder() {
      return agentDisconnect_ == null ? AgentDisconnect.getDefaultInstance() : agentDisconnect_;
    }

    public static final int FLAGS_FIELD_NUMBER = 10;
    private long flags_ = 0L;

    /**
     *
     *
     * <pre>
     * Bit flags as defined by AgentToServerFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 10;</code>
     *
     * @return The flags.
     */
    @Override
    public long getFlags() {
      return flags_;
    }

    public static final int CONNECTION_SETTINGS_REQUEST_FIELD_NUMBER = 11;
    private ConnectionSettingsRequest connectionSettingsRequest_;

    /**
     *
     *
     * <pre>
     * A request to create connection settings. This field is set for flows where
     * the Agent initiates the creation of connection settings.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
     *
     * @return Whether the connectionSettingsRequest field is set.
     */
    @Override
    public boolean hasConnectionSettingsRequest() {
      return ((bitField0_ & 0x00000040) != 0);
    }

    /**
     *
     *
     * <pre>
     * A request to create connection settings. This field is set for flows where
     * the Agent initiates the creation of connection settings.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
     *
     * @return The connectionSettingsRequest.
     */
    @Override
    public ConnectionSettingsRequest getConnectionSettingsRequest() {
      return connectionSettingsRequest_ == null
          ? ConnectionSettingsRequest.getDefaultInstance()
          : connectionSettingsRequest_;
    }

    /**
     *
     *
     * <pre>
     * A request to create connection settings. This field is set for flows where
     * the Agent initiates the creation of connection settings.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
     */
    @Override
    public ConnectionSettingsRequestOrBuilder getConnectionSettingsRequestOrBuilder() {
      return connectionSettingsRequest_ == null
          ? ConnectionSettingsRequest.getDefaultInstance()
          : connectionSettingsRequest_;
    }

    public static final int CUSTOM_CAPABILITIES_FIELD_NUMBER = 12;
    private CustomCapabilities customCapabilities_;

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
     *
     * @return Whether the customCapabilities field is set.
     */
    @Override
    public boolean hasCustomCapabilities() {
      return ((bitField0_ & 0x00000080) != 0);
    }

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
     *
     * @return The customCapabilities.
     */
    @Override
    public CustomCapabilities getCustomCapabilities() {
      return customCapabilities_ == null
          ? CustomCapabilities.getDefaultInstance()
          : customCapabilities_;
    }

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
     */
    @Override
    public CustomCapabilitiesOrBuilder getCustomCapabilitiesOrBuilder() {
      return customCapabilities_ == null
          ? CustomCapabilities.getDefaultInstance()
          : customCapabilities_;
    }

    public static final int CUSTOM_MESSAGE_FIELD_NUMBER = 13;
    private CustomMessage customMessage_;

    /**
     *
     *
     * <pre>
     * A custom message sent from an Agent to the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
     *
     * @return Whether the customMessage field is set.
     */
    @Override
    public boolean hasCustomMessage() {
      return ((bitField0_ & 0x00000100) != 0);
    }

    /**
     *
     *
     * <pre>
     * A custom message sent from an Agent to the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
     *
     * @return The customMessage.
     */
    @Override
    public CustomMessage getCustomMessage() {
      return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
    }

    /**
     *
     *
     * <pre>
     * A custom message sent from an Agent to the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
     */
    @Override
    public CustomMessageOrBuilder getCustomMessageOrBuilder() {
      return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
    }

    public static final int AVAILABLE_COMPONENTS_FIELD_NUMBER = 14;
    private AvailableComponents availableComponents_;

    /**
     *
     *
     * <pre>
     * A message indicating the components that are available for configuration on the agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
     *
     * @return Whether the availableComponents field is set.
     */
    @Override
    public boolean hasAvailableComponents() {
      return ((bitField0_ & 0x00000200) != 0);
    }

    /**
     *
     *
     * <pre>
     * A message indicating the components that are available for configuration on the agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
     *
     * @return The availableComponents.
     */
    @Override
    public AvailableComponents getAvailableComponents() {
      return availableComponents_ == null
          ? AvailableComponents.getDefaultInstance()
          : availableComponents_;
    }

    /**
     *
     *
     * <pre>
     * A message indicating the components that are available for configuration on the agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
     */
    @Override
    public AvailableComponentsOrBuilder getAvailableComponentsOrBuilder() {
      return availableComponents_ == null
          ? AvailableComponents.getDefaultInstance()
          : availableComponents_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!instanceUid_.isEmpty()) {
        output.writeBytes(1, instanceUid_);
      }
      if (sequenceNum_ != 0L) {
        output.writeUInt64(2, sequenceNum_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(3, getAgentDescription());
      }
      if (capabilities_ != 0L) {
        output.writeUInt64(4, capabilities_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(5, getHealth());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(6, getEffectiveConfig());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(7, getRemoteConfigStatus());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(8, getPackageStatuses());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(9, getAgentDisconnect());
      }
      if (flags_ != 0L) {
        output.writeUInt64(10, flags_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(11, getConnectionSettingsRequest());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(12, getCustomCapabilities());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(13, getCustomMessage());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(14, getAvailableComponents());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!instanceUid_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, instanceUid_);
      }
      if (sequenceNum_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(2, sequenceNum_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getAgentDescription());
      }
      if (capabilities_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(4, capabilities_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(5, getHealth());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, getEffectiveConfig());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(7, getRemoteConfigStatus());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(8, getPackageStatuses());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(9, getAgentDisconnect());
      }
      if (flags_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(10, flags_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                11, getConnectionSettingsRequest());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(12, getCustomCapabilities());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(13, getCustomMessage());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(14, getAvailableComponents());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentToServer)) {
        return super.equals(obj);
      }
      AgentToServer other = (AgentToServer) obj;

      if (!getInstanceUid().equals(other.getInstanceUid())) return false;
      if (getSequenceNum() != other.getSequenceNum()) return false;
      if (hasAgentDescription() != other.hasAgentDescription()) return false;
      if (hasAgentDescription()) {
        if (!getAgentDescription().equals(other.getAgentDescription())) return false;
      }
      if (getCapabilities() != other.getCapabilities()) return false;
      if (hasHealth() != other.hasHealth()) return false;
      if (hasHealth()) {
        if (!getHealth().equals(other.getHealth())) return false;
      }
      if (hasEffectiveConfig() != other.hasEffectiveConfig()) return false;
      if (hasEffectiveConfig()) {
        if (!getEffectiveConfig().equals(other.getEffectiveConfig())) return false;
      }
      if (hasRemoteConfigStatus() != other.hasRemoteConfigStatus()) return false;
      if (hasRemoteConfigStatus()) {
        if (!getRemoteConfigStatus().equals(other.getRemoteConfigStatus())) return false;
      }
      if (hasPackageStatuses() != other.hasPackageStatuses()) return false;
      if (hasPackageStatuses()) {
        if (!getPackageStatuses().equals(other.getPackageStatuses())) return false;
      }
      if (hasAgentDisconnect() != other.hasAgentDisconnect()) return false;
      if (hasAgentDisconnect()) {
        if (!getAgentDisconnect().equals(other.getAgentDisconnect())) return false;
      }
      if (getFlags() != other.getFlags()) return false;
      if (hasConnectionSettingsRequest() != other.hasConnectionSettingsRequest()) return false;
      if (hasConnectionSettingsRequest()) {
        if (!getConnectionSettingsRequest().equals(other.getConnectionSettingsRequest()))
          return false;
      }
      if (hasCustomCapabilities() != other.hasCustomCapabilities()) return false;
      if (hasCustomCapabilities()) {
        if (!getCustomCapabilities().equals(other.getCustomCapabilities())) return false;
      }
      if (hasCustomMessage() != other.hasCustomMessage()) return false;
      if (hasCustomMessage()) {
        if (!getCustomMessage().equals(other.getCustomMessage())) return false;
      }
      if (hasAvailableComponents() != other.hasAvailableComponents()) return false;
      if (hasAvailableComponents()) {
        if (!getAvailableComponents().equals(other.getAvailableComponents())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + INSTANCE_UID_FIELD_NUMBER;
      hash = (53 * hash) + getInstanceUid().hashCode();
      hash = (37 * hash) + SEQUENCE_NUM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSequenceNum());
      if (hasAgentDescription()) {
        hash = (37 * hash) + AGENT_DESCRIPTION_FIELD_NUMBER;
        hash = (53 * hash) + getAgentDescription().hashCode();
      }
      hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getCapabilities());
      if (hasHealth()) {
        hash = (37 * hash) + HEALTH_FIELD_NUMBER;
        hash = (53 * hash) + getHealth().hashCode();
      }
      if (hasEffectiveConfig()) {
        hash = (37 * hash) + EFFECTIVE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getEffectiveConfig().hashCode();
      }
      if (hasRemoteConfigStatus()) {
        hash = (37 * hash) + REMOTE_CONFIG_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getRemoteConfigStatus().hashCode();
      }
      if (hasPackageStatuses()) {
        hash = (37 * hash) + PACKAGE_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getPackageStatuses().hashCode();
      }
      if (hasAgentDisconnect()) {
        hash = (37 * hash) + AGENT_DISCONNECT_FIELD_NUMBER;
        hash = (53 * hash) + getAgentDisconnect().hashCode();
      }
      hash = (37 * hash) + FLAGS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getFlags());
      if (hasConnectionSettingsRequest()) {
        hash = (37 * hash) + CONNECTION_SETTINGS_REQUEST_FIELD_NUMBER;
        hash = (53 * hash) + getConnectionSettingsRequest().hashCode();
      }
      if (hasCustomCapabilities()) {
        hash = (37 * hash) + CUSTOM_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCustomCapabilities().hashCode();
      }
      if (hasCustomMessage()) {
        hash = (37 * hash) + CUSTOM_MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getCustomMessage().hashCode();
      }
      if (hasAvailableComponents()) {
        hash = (37 * hash) + AVAILABLE_COMPONENTS_FIELD_NUMBER;
        hash = (53 * hash) + getAvailableComponents().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentToServer parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentToServer parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentToServer parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentToServer parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentToServer parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentToServer parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentToServer parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentToServer parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentToServer parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentToServer parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentToServer parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentToServer parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentToServer prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.AgentToServer} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentToServer)
        AgentToServerOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentToServer_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentToServer_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentToServer.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentToServer.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getAgentDescriptionFieldBuilder();
          getHealthFieldBuilder();
          getEffectiveConfigFieldBuilder();
          getRemoteConfigStatusFieldBuilder();
          getPackageStatusesFieldBuilder();
          getAgentDisconnectFieldBuilder();
          getConnectionSettingsRequestFieldBuilder();
          getCustomCapabilitiesFieldBuilder();
          getCustomMessageFieldBuilder();
          getAvailableComponentsFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        instanceUid_ = com.google.protobuf.ByteString.EMPTY;
        sequenceNum_ = 0L;
        agentDescription_ = null;
        if (agentDescriptionBuilder_ != null) {
          agentDescriptionBuilder_.dispose();
          agentDescriptionBuilder_ = null;
        }
        capabilities_ = 0L;
        health_ = null;
        if (healthBuilder_ != null) {
          healthBuilder_.dispose();
          healthBuilder_ = null;
        }
        effectiveConfig_ = null;
        if (effectiveConfigBuilder_ != null) {
          effectiveConfigBuilder_.dispose();
          effectiveConfigBuilder_ = null;
        }
        remoteConfigStatus_ = null;
        if (remoteConfigStatusBuilder_ != null) {
          remoteConfigStatusBuilder_.dispose();
          remoteConfigStatusBuilder_ = null;
        }
        packageStatuses_ = null;
        if (packageStatusesBuilder_ != null) {
          packageStatusesBuilder_.dispose();
          packageStatusesBuilder_ = null;
        }
        agentDisconnect_ = null;
        if (agentDisconnectBuilder_ != null) {
          agentDisconnectBuilder_.dispose();
          agentDisconnectBuilder_ = null;
        }
        flags_ = 0L;
        connectionSettingsRequest_ = null;
        if (connectionSettingsRequestBuilder_ != null) {
          connectionSettingsRequestBuilder_.dispose();
          connectionSettingsRequestBuilder_ = null;
        }
        customCapabilities_ = null;
        if (customCapabilitiesBuilder_ != null) {
          customCapabilitiesBuilder_.dispose();
          customCapabilitiesBuilder_ = null;
        }
        customMessage_ = null;
        if (customMessageBuilder_ != null) {
          customMessageBuilder_.dispose();
          customMessageBuilder_ = null;
        }
        availableComponents_ = null;
        if (availableComponentsBuilder_ != null) {
          availableComponentsBuilder_.dispose();
          availableComponentsBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentToServer_descriptor;
      }

      @Override
      public AgentToServer getDefaultInstanceForType() {
        return AgentToServer.getDefaultInstance();
      }

      @Override
      public AgentToServer build() {
        AgentToServer result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentToServer buildPartial() {
        AgentToServer result = new AgentToServer(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(AgentToServer result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.instanceUid_ = instanceUid_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.sequenceNum_ = sequenceNum_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.agentDescription_ =
              agentDescriptionBuilder_ == null
                  ? agentDescription_
                  : agentDescriptionBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.capabilities_ = capabilities_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.health_ = healthBuilder_ == null ? health_ : healthBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.effectiveConfig_ =
              effectiveConfigBuilder_ == null ? effectiveConfig_ : effectiveConfigBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.remoteConfigStatus_ =
              remoteConfigStatusBuilder_ == null
                  ? remoteConfigStatus_
                  : remoteConfigStatusBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.packageStatuses_ =
              packageStatusesBuilder_ == null ? packageStatuses_ : packageStatusesBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.agentDisconnect_ =
              agentDisconnectBuilder_ == null ? agentDisconnect_ : agentDisconnectBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.flags_ = flags_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.connectionSettingsRequest_ =
              connectionSettingsRequestBuilder_ == null
                  ? connectionSettingsRequest_
                  : connectionSettingsRequestBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.customCapabilities_ =
              customCapabilitiesBuilder_ == null
                  ? customCapabilities_
                  : customCapabilitiesBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.customMessage_ =
              customMessageBuilder_ == null ? customMessage_ : customMessageBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.availableComponents_ =
              availableComponentsBuilder_ == null
                  ? availableComponents_
                  : availableComponentsBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentToServer) {
          return mergeFrom((AgentToServer) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentToServer other) {
        if (other == AgentToServer.getDefaultInstance()) return this;
        if (other.getInstanceUid() != com.google.protobuf.ByteString.EMPTY) {
          setInstanceUid(other.getInstanceUid());
        }
        if (other.getSequenceNum() != 0L) {
          setSequenceNum(other.getSequenceNum());
        }
        if (other.hasAgentDescription()) {
          mergeAgentDescription(other.getAgentDescription());
        }
        if (other.getCapabilities() != 0L) {
          setCapabilities(other.getCapabilities());
        }
        if (other.hasHealth()) {
          mergeHealth(other.getHealth());
        }
        if (other.hasEffectiveConfig()) {
          mergeEffectiveConfig(other.getEffectiveConfig());
        }
        if (other.hasRemoteConfigStatus()) {
          mergeRemoteConfigStatus(other.getRemoteConfigStatus());
        }
        if (other.hasPackageStatuses()) {
          mergePackageStatuses(other.getPackageStatuses());
        }
        if (other.hasAgentDisconnect()) {
          mergeAgentDisconnect(other.getAgentDisconnect());
        }
        if (other.getFlags() != 0L) {
          setFlags(other.getFlags());
        }
        if (other.hasConnectionSettingsRequest()) {
          mergeConnectionSettingsRequest(other.getConnectionSettingsRequest());
        }
        if (other.hasCustomCapabilities()) {
          mergeCustomCapabilities(other.getCustomCapabilities());
        }
        if (other.hasCustomMessage()) {
          mergeCustomMessage(other.getCustomMessage());
        }
        if (other.hasAvailableComponents()) {
          mergeAvailableComponents(other.getAvailableComponents());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  instanceUid_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 16:
                {
                  sequenceNum_ = input.readUInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
              case 26:
                {
                  input.readMessage(
                      getAgentDescriptionFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 32:
                {
                  capabilities_ = input.readUInt64();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
              case 42:
                {
                  input.readMessage(getHealthFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000010;
                  break;
                } // case 42
              case 50:
                {
                  input.readMessage(
                      getEffectiveConfigFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000020;
                  break;
                } // case 50
              case 58:
                {
                  input.readMessage(
                      getRemoteConfigStatusFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000040;
                  break;
                } // case 58
              case 66:
                {
                  input.readMessage(
                      getPackageStatusesFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000080;
                  break;
                } // case 66
              case 74:
                {
                  input.readMessage(
                      getAgentDisconnectFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000100;
                  break;
                } // case 74
              case 80:
                {
                  flags_ = input.readUInt64();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 80
              case 90:
                {
                  input.readMessage(
                      getConnectionSettingsRequestFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000400;
                  break;
                } // case 90
              case 98:
                {
                  input.readMessage(
                      getCustomCapabilitiesFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000800;
                  break;
                } // case 98
              case 106:
                {
                  input.readMessage(getCustomMessageFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00001000;
                  break;
                } // case 106
              case 114:
                {
                  input.readMessage(
                      getAvailableComponentsFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00002000;
                  break;
                } // case 114
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString instanceUid_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
       * </pre>
       *
       * <code>bytes instance_uid = 1;</code>
       *
       * @return The instanceUid.
       */
      @Override
      public com.google.protobuf.ByteString getInstanceUid() {
        return instanceUid_;
      }

      /**
       *
       *
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
       * </pre>
       *
       * <code>bytes instance_uid = 1;</code>
       *
       * @param value The instanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceUid(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        instanceUid_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
       * </pre>
       *
       * <code>bytes instance_uid = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearInstanceUid() {
        bitField0_ = (bitField0_ & ~0x00000001);
        instanceUid_ = getDefaultInstance().getInstanceUid();
        onChanged();
        return this;
      }

      private long sequenceNum_;

      /**
       *
       *
       * <pre>
       * The sequence number is incremented by 1 for every AgentToServer sent
       * by the Agent. This allows the Server to detect that it missed a message when
       * it notices that the sequence_num is not exactly by 1 greater than the previously
       * received one.
       * </pre>
       *
       * <code>uint64 sequence_num = 2;</code>
       *
       * @return The sequenceNum.
       */
      @Override
      public long getSequenceNum() {
        return sequenceNum_;
      }

      /**
       *
       *
       * <pre>
       * The sequence number is incremented by 1 for every AgentToServer sent
       * by the Agent. This allows the Server to detect that it missed a message when
       * it notices that the sequence_num is not exactly by 1 greater than the previously
       * received one.
       * </pre>
       *
       * <code>uint64 sequence_num = 2;</code>
       *
       * @param value The sequenceNum to set.
       * @return This builder for chaining.
       */
      public Builder setSequenceNum(long value) {

        sequenceNum_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The sequence number is incremented by 1 for every AgentToServer sent
       * by the Agent. This allows the Server to detect that it missed a message when
       * it notices that the sequence_num is not exactly by 1 greater than the previously
       * received one.
       * </pre>
       *
       * <code>uint64 sequence_num = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearSequenceNum() {
        bitField0_ = (bitField0_ & ~0x00000002);
        sequenceNum_ = 0L;
        onChanged();
        return this;
      }

      private AgentDescription agentDescription_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentDescription, AgentDescription.Builder, AgentDescriptionOrBuilder>
          agentDescriptionBuilder_;

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       *
       * @return Whether the agentDescription field is set.
       */
      public boolean hasAgentDescription() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       *
       * @return The agentDescription.
       */
      public AgentDescription getAgentDescription() {
        if (agentDescriptionBuilder_ == null) {
          return agentDescription_ == null
              ? AgentDescription.getDefaultInstance()
              : agentDescription_;
        } else {
          return agentDescriptionBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder setAgentDescription(AgentDescription value) {
        if (agentDescriptionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          agentDescription_ = value;
        } else {
          agentDescriptionBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder setAgentDescription(AgentDescription.Builder builderForValue) {
        if (agentDescriptionBuilder_ == null) {
          agentDescription_ = builderForValue.build();
        } else {
          agentDescriptionBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder mergeAgentDescription(AgentDescription value) {
        if (agentDescriptionBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && agentDescription_ != null
              && agentDescription_ != AgentDescription.getDefaultInstance()) {
            getAgentDescriptionBuilder().mergeFrom(value);
          } else {
            agentDescription_ = value;
          }
        } else {
          agentDescriptionBuilder_.mergeFrom(value);
        }
        if (agentDescription_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder clearAgentDescription() {
        bitField0_ = (bitField0_ & ~0x00000004);
        agentDescription_ = null;
        if (agentDescriptionBuilder_ != null) {
          agentDescriptionBuilder_.dispose();
          agentDescriptionBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public AgentDescription.Builder getAgentDescriptionBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getAgentDescriptionFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public AgentDescriptionOrBuilder getAgentDescriptionOrBuilder() {
        if (agentDescriptionBuilder_ != null) {
          return agentDescriptionBuilder_.getMessageOrBuilder();
        } else {
          return agentDescription_ == null
              ? AgentDescription.getDefaultInstance()
              : agentDescription_;
        }
      }

      /**
       *
       *
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentDescription, AgentDescription.Builder, AgentDescriptionOrBuilder>
          getAgentDescriptionFieldBuilder() {
        if (agentDescriptionBuilder_ == null) {
          agentDescriptionBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AgentDescription, AgentDescription.Builder, AgentDescriptionOrBuilder>(
                  getAgentDescription(), getParentForChildren(), isClean());
          agentDescription_ = null;
        }
        return agentDescriptionBuilder_;
      }

      private long capabilities_;

      /**
       *
       *
       * <pre>
       * Bitmask of flags defined by AgentCapabilities enum.
       * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
       * the Agent. This allows extending the protocol and the AgentCapabilities enum
       * in the future such that old Agents automatically report that they don't
       * support the new capability.
       * This field MUST be always set.
       * </pre>
       *
       * <code>uint64 capabilities = 4;</code>
       *
       * @return The capabilities.
       */
      @Override
      public long getCapabilities() {
        return capabilities_;
      }

      /**
       *
       *
       * <pre>
       * Bitmask of flags defined by AgentCapabilities enum.
       * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
       * the Agent. This allows extending the protocol and the AgentCapabilities enum
       * in the future such that old Agents automatically report that they don't
       * support the new capability.
       * This field MUST be always set.
       * </pre>
       *
       * <code>uint64 capabilities = 4;</code>
       *
       * @param value The capabilities to set.
       * @return This builder for chaining.
       */
      public Builder setCapabilities(long value) {

        capabilities_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Bitmask of flags defined by AgentCapabilities enum.
       * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
       * the Agent. This allows extending the protocol and the AgentCapabilities enum
       * in the future such that old Agents automatically report that they don't
       * support the new capability.
       * This field MUST be always set.
       * </pre>
       *
       * <code>uint64 capabilities = 4;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCapabilities() {
        bitField0_ = (bitField0_ & ~0x00000008);
        capabilities_ = 0L;
        onChanged();
        return this;
      }

      private ComponentHealth health_;
      private com.google.protobuf.SingleFieldBuilderV3<
              ComponentHealth, ComponentHealth.Builder, ComponentHealthOrBuilder>
          healthBuilder_;

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       *
       * @return Whether the health field is set.
       */
      public boolean hasHealth() {
        return ((bitField0_ & 0x00000010) != 0);
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       *
       * @return The health.
       */
      public ComponentHealth getHealth() {
        if (healthBuilder_ == null) {
          return health_ == null ? ComponentHealth.getDefaultInstance() : health_;
        } else {
          return healthBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      public Builder setHealth(ComponentHealth value) {
        if (healthBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          health_ = value;
        } else {
          healthBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      public Builder setHealth(ComponentHealth.Builder builderForValue) {
        if (healthBuilder_ == null) {
          health_ = builderForValue.build();
        } else {
          healthBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      public Builder mergeHealth(ComponentHealth value) {
        if (healthBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)
              && health_ != null
              && health_ != ComponentHealth.getDefaultInstance()) {
            getHealthBuilder().mergeFrom(value);
          } else {
            health_ = value;
          }
        } else {
          healthBuilder_.mergeFrom(value);
        }
        if (health_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      public Builder clearHealth() {
        bitField0_ = (bitField0_ & ~0x00000010);
        health_ = null;
        if (healthBuilder_ != null) {
          healthBuilder_.dispose();
          healthBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      public ComponentHealth.Builder getHealthBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getHealthFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      public ComponentHealthOrBuilder getHealthOrBuilder() {
        if (healthBuilder_ != null) {
          return healthBuilder_.getMessageOrBuilder();
        } else {
          return health_ == null ? ComponentHealth.getDefaultInstance() : health_;
        }
      }

      /**
       *
       *
       * <pre>
       * The current health of the Agent and sub-components. The top-level ComponentHealth represents
       * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
       * message.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ComponentHealth health = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              ComponentHealth, ComponentHealth.Builder, ComponentHealthOrBuilder>
          getHealthFieldBuilder() {
        if (healthBuilder_ == null) {
          healthBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  ComponentHealth, ComponentHealth.Builder, ComponentHealthOrBuilder>(
                  getHealth(), getParentForChildren(), isClean());
          health_ = null;
        }
        return healthBuilder_;
      }

      private EffectiveConfig effectiveConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
              EffectiveConfig, EffectiveConfig.Builder, EffectiveConfigOrBuilder>
          effectiveConfigBuilder_;

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       *
       * @return Whether the effectiveConfig field is set.
       */
      public boolean hasEffectiveConfig() {
        return ((bitField0_ & 0x00000020) != 0);
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       *
       * @return The effectiveConfig.
       */
      public EffectiveConfig getEffectiveConfig() {
        if (effectiveConfigBuilder_ == null) {
          return effectiveConfig_ == null ? EffectiveConfig.getDefaultInstance() : effectiveConfig_;
        } else {
          return effectiveConfigBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder setEffectiveConfig(EffectiveConfig value) {
        if (effectiveConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          effectiveConfig_ = value;
        } else {
          effectiveConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder setEffectiveConfig(EffectiveConfig.Builder builderForValue) {
        if (effectiveConfigBuilder_ == null) {
          effectiveConfig_ = builderForValue.build();
        } else {
          effectiveConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder mergeEffectiveConfig(EffectiveConfig value) {
        if (effectiveConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)
              && effectiveConfig_ != null
              && effectiveConfig_ != EffectiveConfig.getDefaultInstance()) {
            getEffectiveConfigBuilder().mergeFrom(value);
          } else {
            effectiveConfig_ = value;
          }
        } else {
          effectiveConfigBuilder_.mergeFrom(value);
        }
        if (effectiveConfig_ != null) {
          bitField0_ |= 0x00000020;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder clearEffectiveConfig() {
        bitField0_ = (bitField0_ & ~0x00000020);
        effectiveConfig_ = null;
        if (effectiveConfigBuilder_ != null) {
          effectiveConfigBuilder_.dispose();
          effectiveConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public EffectiveConfig.Builder getEffectiveConfigBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getEffectiveConfigFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public EffectiveConfigOrBuilder getEffectiveConfigOrBuilder() {
        if (effectiveConfigBuilder_ != null) {
          return effectiveConfigBuilder_.getMessageOrBuilder();
        } else {
          return effectiveConfig_ == null ? EffectiveConfig.getDefaultInstance() : effectiveConfig_;
        }
      }

      /**
       *
       *
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       *
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              EffectiveConfig, EffectiveConfig.Builder, EffectiveConfigOrBuilder>
          getEffectiveConfigFieldBuilder() {
        if (effectiveConfigBuilder_ == null) {
          effectiveConfigBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  EffectiveConfig, EffectiveConfig.Builder, EffectiveConfigOrBuilder>(
                  getEffectiveConfig(), getParentForChildren(), isClean());
          effectiveConfig_ = null;
        }
        return effectiveConfigBuilder_;
      }

      private RemoteConfigStatus remoteConfigStatus_;
      private com.google.protobuf.SingleFieldBuilderV3<
              RemoteConfigStatus, RemoteConfigStatus.Builder, RemoteConfigStatusOrBuilder>
          remoteConfigStatusBuilder_;

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       *
       * @return Whether the remoteConfigStatus field is set.
       */
      public boolean hasRemoteConfigStatus() {
        return ((bitField0_ & 0x00000040) != 0);
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       *
       * @return The remoteConfigStatus.
       */
      public RemoteConfigStatus getRemoteConfigStatus() {
        if (remoteConfigStatusBuilder_ == null) {
          return remoteConfigStatus_ == null
              ? RemoteConfigStatus.getDefaultInstance()
              : remoteConfigStatus_;
        } else {
          return remoteConfigStatusBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder setRemoteConfigStatus(RemoteConfigStatus value) {
        if (remoteConfigStatusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          remoteConfigStatus_ = value;
        } else {
          remoteConfigStatusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder setRemoteConfigStatus(RemoteConfigStatus.Builder builderForValue) {
        if (remoteConfigStatusBuilder_ == null) {
          remoteConfigStatus_ = builderForValue.build();
        } else {
          remoteConfigStatusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder mergeRemoteConfigStatus(RemoteConfigStatus value) {
        if (remoteConfigStatusBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)
              && remoteConfigStatus_ != null
              && remoteConfigStatus_ != RemoteConfigStatus.getDefaultInstance()) {
            getRemoteConfigStatusBuilder().mergeFrom(value);
          } else {
            remoteConfigStatus_ = value;
          }
        } else {
          remoteConfigStatusBuilder_.mergeFrom(value);
        }
        if (remoteConfigStatus_ != null) {
          bitField0_ |= 0x00000040;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder clearRemoteConfigStatus() {
        bitField0_ = (bitField0_ & ~0x00000040);
        remoteConfigStatus_ = null;
        if (remoteConfigStatusBuilder_ != null) {
          remoteConfigStatusBuilder_.dispose();
          remoteConfigStatusBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public RemoteConfigStatus.Builder getRemoteConfigStatusBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getRemoteConfigStatusFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public RemoteConfigStatusOrBuilder getRemoteConfigStatusOrBuilder() {
        if (remoteConfigStatusBuilder_ != null) {
          return remoteConfigStatusBuilder_.getMessageOrBuilder();
        } else {
          return remoteConfigStatus_ == null
              ? RemoteConfigStatus.getDefaultInstance()
              : remoteConfigStatus_;
        }
      }

      /**
       *
       *
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              RemoteConfigStatus, RemoteConfigStatus.Builder, RemoteConfigStatusOrBuilder>
          getRemoteConfigStatusFieldBuilder() {
        if (remoteConfigStatusBuilder_ == null) {
          remoteConfigStatusBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  RemoteConfigStatus, RemoteConfigStatus.Builder, RemoteConfigStatusOrBuilder>(
                  getRemoteConfigStatus(), getParentForChildren(), isClean());
          remoteConfigStatus_ = null;
        }
        return remoteConfigStatusBuilder_;
      }

      private PackageStatuses packageStatuses_;
      private com.google.protobuf.SingleFieldBuilderV3<
              PackageStatuses, PackageStatuses.Builder, PackageStatusesOrBuilder>
          packageStatusesBuilder_;

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       *
       * @return Whether the packageStatuses field is set.
       */
      public boolean hasPackageStatuses() {
        return ((bitField0_ & 0x00000080) != 0);
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       *
       * @return The packageStatuses.
       */
      public PackageStatuses getPackageStatuses() {
        if (packageStatusesBuilder_ == null) {
          return packageStatuses_ == null ? PackageStatuses.getDefaultInstance() : packageStatuses_;
        } else {
          return packageStatusesBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder setPackageStatuses(PackageStatuses value) {
        if (packageStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          packageStatuses_ = value;
        } else {
          packageStatusesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder setPackageStatuses(PackageStatuses.Builder builderForValue) {
        if (packageStatusesBuilder_ == null) {
          packageStatuses_ = builderForValue.build();
        } else {
          packageStatusesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder mergePackageStatuses(PackageStatuses value) {
        if (packageStatusesBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)
              && packageStatuses_ != null
              && packageStatuses_ != PackageStatuses.getDefaultInstance()) {
            getPackageStatusesBuilder().mergeFrom(value);
          } else {
            packageStatuses_ = value;
          }
        } else {
          packageStatusesBuilder_.mergeFrom(value);
        }
        if (packageStatuses_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder clearPackageStatuses() {
        bitField0_ = (bitField0_ & ~0x00000080);
        packageStatuses_ = null;
        if (packageStatusesBuilder_ != null) {
          packageStatusesBuilder_.dispose();
          packageStatusesBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public PackageStatuses.Builder getPackageStatusesBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getPackageStatusesFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public PackageStatusesOrBuilder getPackageStatusesOrBuilder() {
        if (packageStatusesBuilder_ != null) {
          return packageStatusesBuilder_.getMessageOrBuilder();
        } else {
          return packageStatuses_ == null ? PackageStatuses.getDefaultInstance() : packageStatuses_;
        }
      }

      /**
       *
       *
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              PackageStatuses, PackageStatuses.Builder, PackageStatusesOrBuilder>
          getPackageStatusesFieldBuilder() {
        if (packageStatusesBuilder_ == null) {
          packageStatusesBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  PackageStatuses, PackageStatuses.Builder, PackageStatusesOrBuilder>(
                  getPackageStatuses(), getParentForChildren(), isClean());
          packageStatuses_ = null;
        }
        return packageStatusesBuilder_;
      }

      private AgentDisconnect agentDisconnect_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentDisconnect, AgentDisconnect.Builder, AgentDisconnectOrBuilder>
          agentDisconnectBuilder_;

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       *
       * @return Whether the agentDisconnect field is set.
       */
      public boolean hasAgentDisconnect() {
        return ((bitField0_ & 0x00000100) != 0);
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       *
       * @return The agentDisconnect.
       */
      public AgentDisconnect getAgentDisconnect() {
        if (agentDisconnectBuilder_ == null) {
          return agentDisconnect_ == null ? AgentDisconnect.getDefaultInstance() : agentDisconnect_;
        } else {
          return agentDisconnectBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder setAgentDisconnect(AgentDisconnect value) {
        if (agentDisconnectBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          agentDisconnect_ = value;
        } else {
          agentDisconnectBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder setAgentDisconnect(AgentDisconnect.Builder builderForValue) {
        if (agentDisconnectBuilder_ == null) {
          agentDisconnect_ = builderForValue.build();
        } else {
          agentDisconnectBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder mergeAgentDisconnect(AgentDisconnect value) {
        if (agentDisconnectBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)
              && agentDisconnect_ != null
              && agentDisconnect_ != AgentDisconnect.getDefaultInstance()) {
            getAgentDisconnectBuilder().mergeFrom(value);
          } else {
            agentDisconnect_ = value;
          }
        } else {
          agentDisconnectBuilder_.mergeFrom(value);
        }
        if (agentDisconnect_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder clearAgentDisconnect() {
        bitField0_ = (bitField0_ & ~0x00000100);
        agentDisconnect_ = null;
        if (agentDisconnectBuilder_ != null) {
          agentDisconnectBuilder_.dispose();
          agentDisconnectBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public AgentDisconnect.Builder getAgentDisconnectBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getAgentDisconnectFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public AgentDisconnectOrBuilder getAgentDisconnectOrBuilder() {
        if (agentDisconnectBuilder_ != null) {
          return agentDisconnectBuilder_.getMessageOrBuilder();
        } else {
          return agentDisconnect_ == null ? AgentDisconnect.getDefaultInstance() : agentDisconnect_;
        }
      }

      /**
       *
       *
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentDisconnect, AgentDisconnect.Builder, AgentDisconnectOrBuilder>
          getAgentDisconnectFieldBuilder() {
        if (agentDisconnectBuilder_ == null) {
          agentDisconnectBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AgentDisconnect, AgentDisconnect.Builder, AgentDisconnectOrBuilder>(
                  getAgentDisconnect(), getParentForChildren(), isClean());
          agentDisconnect_ = null;
        }
        return agentDisconnectBuilder_;
      }

      private long flags_;

      /**
       *
       *
       * <pre>
       * Bit flags as defined by AgentToServerFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 10;</code>
       *
       * @return The flags.
       */
      @Override
      public long getFlags() {
        return flags_;
      }

      /**
       *
       *
       * <pre>
       * Bit flags as defined by AgentToServerFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 10;</code>
       *
       * @param value The flags to set.
       * @return This builder for chaining.
       */
      public Builder setFlags(long value) {

        flags_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Bit flags as defined by AgentToServerFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 10;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearFlags() {
        bitField0_ = (bitField0_ & ~0x00000200);
        flags_ = 0L;
        onChanged();
        return this;
      }

      private ConnectionSettingsRequest connectionSettingsRequest_;
      private com.google.protobuf.SingleFieldBuilderV3<
              ConnectionSettingsRequest,
              ConnectionSettingsRequest.Builder,
              ConnectionSettingsRequestOrBuilder>
          connectionSettingsRequestBuilder_;

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       *
       * @return Whether the connectionSettingsRequest field is set.
       */
      public boolean hasConnectionSettingsRequest() {
        return ((bitField0_ & 0x00000400) != 0);
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       *
       * @return The connectionSettingsRequest.
       */
      public ConnectionSettingsRequest getConnectionSettingsRequest() {
        if (connectionSettingsRequestBuilder_ == null) {
          return connectionSettingsRequest_ == null
              ? ConnectionSettingsRequest.getDefaultInstance()
              : connectionSettingsRequest_;
        } else {
          return connectionSettingsRequestBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      public Builder setConnectionSettingsRequest(ConnectionSettingsRequest value) {
        if (connectionSettingsRequestBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          connectionSettingsRequest_ = value;
        } else {
          connectionSettingsRequestBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      public Builder setConnectionSettingsRequest(
          ConnectionSettingsRequest.Builder builderForValue) {
        if (connectionSettingsRequestBuilder_ == null) {
          connectionSettingsRequest_ = builderForValue.build();
        } else {
          connectionSettingsRequestBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      public Builder mergeConnectionSettingsRequest(ConnectionSettingsRequest value) {
        if (connectionSettingsRequestBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)
              && connectionSettingsRequest_ != null
              && connectionSettingsRequest_ != ConnectionSettingsRequest.getDefaultInstance()) {
            getConnectionSettingsRequestBuilder().mergeFrom(value);
          } else {
            connectionSettingsRequest_ = value;
          }
        } else {
          connectionSettingsRequestBuilder_.mergeFrom(value);
        }
        if (connectionSettingsRequest_ != null) {
          bitField0_ |= 0x00000400;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      public Builder clearConnectionSettingsRequest() {
        bitField0_ = (bitField0_ & ~0x00000400);
        connectionSettingsRequest_ = null;
        if (connectionSettingsRequestBuilder_ != null) {
          connectionSettingsRequestBuilder_.dispose();
          connectionSettingsRequestBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      public ConnectionSettingsRequest.Builder getConnectionSettingsRequestBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getConnectionSettingsRequestFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      public ConnectionSettingsRequestOrBuilder getConnectionSettingsRequestOrBuilder() {
        if (connectionSettingsRequestBuilder_ != null) {
          return connectionSettingsRequestBuilder_.getMessageOrBuilder();
        } else {
          return connectionSettingsRequest_ == null
              ? ConnectionSettingsRequest.getDefaultInstance()
              : connectionSettingsRequest_;
        }
      }

      /**
       *
       *
       * <pre>
       * A request to create connection settings. This field is set for flows where
       * the Agent initiates the creation of connection settings.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              ConnectionSettingsRequest,
              ConnectionSettingsRequest.Builder,
              ConnectionSettingsRequestOrBuilder>
          getConnectionSettingsRequestFieldBuilder() {
        if (connectionSettingsRequestBuilder_ == null) {
          connectionSettingsRequestBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  ConnectionSettingsRequest,
                  ConnectionSettingsRequest.Builder,
                  ConnectionSettingsRequestOrBuilder>(
                  getConnectionSettingsRequest(), getParentForChildren(), isClean());
          connectionSettingsRequest_ = null;
        }
        return connectionSettingsRequestBuilder_;
      }

      private CustomCapabilities customCapabilities_;
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomCapabilities, CustomCapabilities.Builder, CustomCapabilitiesOrBuilder>
          customCapabilitiesBuilder_;

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       *
       * @return Whether the customCapabilities field is set.
       */
      public boolean hasCustomCapabilities() {
        return ((bitField0_ & 0x00000800) != 0);
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       *
       * @return The customCapabilities.
       */
      public CustomCapabilities getCustomCapabilities() {
        if (customCapabilitiesBuilder_ == null) {
          return customCapabilities_ == null
              ? CustomCapabilities.getDefaultInstance()
              : customCapabilities_;
        } else {
          return customCapabilitiesBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      public Builder setCustomCapabilities(CustomCapabilities value) {
        if (customCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          customCapabilities_ = value;
        } else {
          customCapabilitiesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      public Builder setCustomCapabilities(CustomCapabilities.Builder builderForValue) {
        if (customCapabilitiesBuilder_ == null) {
          customCapabilities_ = builderForValue.build();
        } else {
          customCapabilitiesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      public Builder mergeCustomCapabilities(CustomCapabilities value) {
        if (customCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0)
              && customCapabilities_ != null
              && customCapabilities_ != CustomCapabilities.getDefaultInstance()) {
            getCustomCapabilitiesBuilder().mergeFrom(value);
          } else {
            customCapabilities_ = value;
          }
        } else {
          customCapabilitiesBuilder_.mergeFrom(value);
        }
        if (customCapabilities_ != null) {
          bitField0_ |= 0x00000800;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      public Builder clearCustomCapabilities() {
        bitField0_ = (bitField0_ & ~0x00000800);
        customCapabilities_ = null;
        if (customCapabilitiesBuilder_ != null) {
          customCapabilitiesBuilder_.dispose();
          customCapabilitiesBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      public CustomCapabilities.Builder getCustomCapabilitiesBuilder() {
        bitField0_ |= 0x00000800;
        onChanged();
        return getCustomCapabilitiesFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      public CustomCapabilitiesOrBuilder getCustomCapabilitiesOrBuilder() {
        if (customCapabilitiesBuilder_ != null) {
          return customCapabilitiesBuilder_.getMessageOrBuilder();
        } else {
          return customCapabilities_ == null
              ? CustomCapabilities.getDefaultInstance()
              : customCapabilities_;
        }
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomCapabilities, CustomCapabilities.Builder, CustomCapabilitiesOrBuilder>
          getCustomCapabilitiesFieldBuilder() {
        if (customCapabilitiesBuilder_ == null) {
          customCapabilitiesBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  CustomCapabilities, CustomCapabilities.Builder, CustomCapabilitiesOrBuilder>(
                  getCustomCapabilities(), getParentForChildren(), isClean());
          customCapabilities_ = null;
        }
        return customCapabilitiesBuilder_;
      }

      private CustomMessage customMessage_;
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomMessage, CustomMessage.Builder, CustomMessageOrBuilder>
          customMessageBuilder_;

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       *
       * @return Whether the customMessage field is set.
       */
      public boolean hasCustomMessage() {
        return ((bitField0_ & 0x00001000) != 0);
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       *
       * @return The customMessage.
       */
      public CustomMessage getCustomMessage() {
        if (customMessageBuilder_ == null) {
          return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
        } else {
          return customMessageBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      public Builder setCustomMessage(CustomMessage value) {
        if (customMessageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          customMessage_ = value;
        } else {
          customMessageBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      public Builder setCustomMessage(CustomMessage.Builder builderForValue) {
        if (customMessageBuilder_ == null) {
          customMessage_ = builderForValue.build();
        } else {
          customMessageBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      public Builder mergeCustomMessage(CustomMessage value) {
        if (customMessageBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)
              && customMessage_ != null
              && customMessage_ != CustomMessage.getDefaultInstance()) {
            getCustomMessageBuilder().mergeFrom(value);
          } else {
            customMessage_ = value;
          }
        } else {
          customMessageBuilder_.mergeFrom(value);
        }
        if (customMessage_ != null) {
          bitField0_ |= 0x00001000;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      public Builder clearCustomMessage() {
        bitField0_ = (bitField0_ & ~0x00001000);
        customMessage_ = null;
        if (customMessageBuilder_ != null) {
          customMessageBuilder_.dispose();
          customMessageBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      public CustomMessage.Builder getCustomMessageBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getCustomMessageFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      public CustomMessageOrBuilder getCustomMessageOrBuilder() {
        if (customMessageBuilder_ != null) {
          return customMessageBuilder_.getMessageOrBuilder();
        } else {
          return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
        }
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from an Agent to the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 13;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomMessage, CustomMessage.Builder, CustomMessageOrBuilder>
          getCustomMessageFieldBuilder() {
        if (customMessageBuilder_ == null) {
          customMessageBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  CustomMessage, CustomMessage.Builder, CustomMessageOrBuilder>(
                  getCustomMessage(), getParentForChildren(), isClean());
          customMessage_ = null;
        }
        return customMessageBuilder_;
      }

      private AvailableComponents availableComponents_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AvailableComponents, AvailableComponents.Builder, AvailableComponentsOrBuilder>
          availableComponentsBuilder_;

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       *
       * @return Whether the availableComponents field is set.
       */
      public boolean hasAvailableComponents() {
        return ((bitField0_ & 0x00002000) != 0);
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       *
       * @return The availableComponents.
       */
      public AvailableComponents getAvailableComponents() {
        if (availableComponentsBuilder_ == null) {
          return availableComponents_ == null
              ? AvailableComponents.getDefaultInstance()
              : availableComponents_;
        } else {
          return availableComponentsBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      public Builder setAvailableComponents(AvailableComponents value) {
        if (availableComponentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          availableComponents_ = value;
        } else {
          availableComponentsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      public Builder setAvailableComponents(AvailableComponents.Builder builderForValue) {
        if (availableComponentsBuilder_ == null) {
          availableComponents_ = builderForValue.build();
        } else {
          availableComponentsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      public Builder mergeAvailableComponents(AvailableComponents value) {
        if (availableComponentsBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0)
              && availableComponents_ != null
              && availableComponents_ != AvailableComponents.getDefaultInstance()) {
            getAvailableComponentsBuilder().mergeFrom(value);
          } else {
            availableComponents_ = value;
          }
        } else {
          availableComponentsBuilder_.mergeFrom(value);
        }
        if (availableComponents_ != null) {
          bitField0_ |= 0x00002000;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      public Builder clearAvailableComponents() {
        bitField0_ = (bitField0_ & ~0x00002000);
        availableComponents_ = null;
        if (availableComponentsBuilder_ != null) {
          availableComponentsBuilder_.dispose();
          availableComponentsBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      public AvailableComponents.Builder getAvailableComponentsBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getAvailableComponentsFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      public AvailableComponentsOrBuilder getAvailableComponentsOrBuilder() {
        if (availableComponentsBuilder_ != null) {
          return availableComponentsBuilder_.getMessageOrBuilder();
        } else {
          return availableComponents_ == null
              ? AvailableComponents.getDefaultInstance()
              : availableComponents_;
        }
      }

      /**
       *
       *
       * <pre>
       * A message indicating the components that are available for configuration on the agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.AvailableComponents available_components = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AvailableComponents, AvailableComponents.Builder, AvailableComponentsOrBuilder>
          getAvailableComponentsFieldBuilder() {
        if (availableComponentsBuilder_ == null) {
          availableComponentsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AvailableComponents, AvailableComponents.Builder, AvailableComponentsOrBuilder>(
                  getAvailableComponents(), getParentForChildren(), isClean());
          availableComponents_ = null;
        }
        return availableComponentsBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentToServer)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentToServer)
    private static final AgentToServer DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentToServer();
    }

    public static AgentToServer getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentToServer> PARSER =
        new com.google.protobuf.AbstractParser<AgentToServer>() {
          @Override
          public AgentToServer parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentToServer> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentToServer> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentToServer getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AgentDisconnectOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentDisconnect)
      com.google.protobuf.MessageOrBuilder {}

  /**
   *
   *
   * <pre>
   * AgentDisconnect is the last message sent from the Agent to the Server. The Server
   * SHOULD forget the association of the Agent instance with the message stream.
   *
   * If the message stream is closed in the transport layer then the Server SHOULD
   * forget association of all Agent instances that were previously established for
   * this message stream using AgentConnect message, even if the corresponding
   * AgentDisconnect message were not explicitly received from the Agent.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.AgentDisconnect}
   */
  public static final class AgentDisconnect extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentDisconnect)
      AgentDisconnectOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentDisconnect.newBuilder() to construct.
    private AgentDisconnect(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentDisconnect() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentDisconnect();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentDisconnect_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentDisconnect.class, Builder.class);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentDisconnect)) {
        return super.equals(obj);
      }
      AgentDisconnect other = (AgentDisconnect) obj;

      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentDisconnect parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentDisconnect parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentDisconnect parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentDisconnect parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentDisconnect parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentDisconnect parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentDisconnect parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentDisconnect parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentDisconnect parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentDisconnect parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentDisconnect parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentDisconnect parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentDisconnect prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * AgentDisconnect is the last message sent from the Agent to the Server. The Server
     * SHOULD forget the association of the Agent instance with the message stream.
     *
     * If the message stream is closed in the transport layer then the Server SHOULD
     * forget association of all Agent instances that were previously established for
     * this message stream using AgentConnect message, even if the corresponding
     * AgentDisconnect message were not explicitly received from the Agent.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.AgentDisconnect}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentDisconnect)
        AgentDisconnectOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentDisconnect_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentDisconnect.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentDisconnect.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentDisconnect_descriptor;
      }

      @Override
      public AgentDisconnect getDefaultInstanceForType() {
        return AgentDisconnect.getDefaultInstance();
      }

      @Override
      public AgentDisconnect build() {
        AgentDisconnect result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentDisconnect buildPartial() {
        AgentDisconnect result = new AgentDisconnect(this);
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentDisconnect) {
          return mergeFrom((AgentDisconnect) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentDisconnect other) {
        if (other == AgentDisconnect.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentDisconnect)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentDisconnect)
    private static final AgentDisconnect DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentDisconnect();
    }

    public static AgentDisconnect getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentDisconnect> PARSER =
        new com.google.protobuf.AbstractParser<AgentDisconnect>() {
          @Override
          public AgentDisconnect parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentDisconnect> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentDisconnect> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentDisconnect getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ConnectionSettingsRequestOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ConnectionSettingsRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Request for OpAMP connection settings. If this field is unset
     * then the ConnectionSettingsRequest message is empty and is not actionable
     * for the Server.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
     *
     * @return Whether the opamp field is set.
     */
    boolean hasOpamp();

    /**
     *
     *
     * <pre>
     * Request for OpAMP connection settings. If this field is unset
     * then the ConnectionSettingsRequest message is empty and is not actionable
     * for the Server.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
     *
     * @return The opamp.
     */
    OpAMPConnectionSettingsRequest getOpamp();

    /**
     *
     *
     * <pre>
     * Request for OpAMP connection settings. If this field is unset
     * then the ConnectionSettingsRequest message is empty and is not actionable
     * for the Server.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
     */
    OpAMPConnectionSettingsRequestOrBuilder getOpampOrBuilder();
  }

  /**
   *
   *
   * <pre>
   * ConnectionSettingsRequest is a request from the Agent to the Server to create
   * and respond with an offer of connection settings for the Agent.
   * Status: [Development]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.ConnectionSettingsRequest}
   */
  public static final class ConnectionSettingsRequest extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ConnectionSettingsRequest)
      ConnectionSettingsRequestOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ConnectionSettingsRequest.newBuilder() to construct.
    private ConnectionSettingsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ConnectionSettingsRequest() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ConnectionSettingsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ConnectionSettingsRequest_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ConnectionSettingsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ConnectionSettingsRequest.class, Builder.class);
    }

    private int bitField0_;
    public static final int OPAMP_FIELD_NUMBER = 1;
    private OpAMPConnectionSettingsRequest opamp_;

    /**
     *
     *
     * <pre>
     * Request for OpAMP connection settings. If this field is unset
     * then the ConnectionSettingsRequest message is empty and is not actionable
     * for the Server.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
     *
     * @return Whether the opamp field is set.
     */
    @Override
    public boolean hasOpamp() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Request for OpAMP connection settings. If this field is unset
     * then the ConnectionSettingsRequest message is empty and is not actionable
     * for the Server.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
     *
     * @return The opamp.
     */
    @Override
    public OpAMPConnectionSettingsRequest getOpamp() {
      return opamp_ == null ? OpAMPConnectionSettingsRequest.getDefaultInstance() : opamp_;
    }

    /**
     *
     *
     * <pre>
     * Request for OpAMP connection settings. If this field is unset
     * then the ConnectionSettingsRequest message is empty and is not actionable
     * for the Server.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
     */
    @Override
    public OpAMPConnectionSettingsRequestOrBuilder getOpampOrBuilder() {
      return opamp_ == null ? OpAMPConnectionSettingsRequest.getDefaultInstance() : opamp_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getOpamp());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getOpamp());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ConnectionSettingsRequest)) {
        return super.equals(obj);
      }
      ConnectionSettingsRequest other = (ConnectionSettingsRequest) obj;

      if (hasOpamp() != other.hasOpamp()) return false;
      if (hasOpamp()) {
        if (!getOpamp().equals(other.getOpamp())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasOpamp()) {
        hash = (37 * hash) + OPAMP_FIELD_NUMBER;
        hash = (53 * hash) + getOpamp().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ConnectionSettingsRequest parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ConnectionSettingsRequest parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ConnectionSettingsRequest parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ConnectionSettingsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ConnectionSettingsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ConnectionSettingsRequest parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ConnectionSettingsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ConnectionSettingsRequest parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ConnectionSettingsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ConnectionSettingsRequest parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ConnectionSettingsRequest parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ConnectionSettingsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ConnectionSettingsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * ConnectionSettingsRequest is a request from the Agent to the Server to create
     * and respond with an offer of connection settings for the Agent.
     * Status: [Development]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.ConnectionSettingsRequest}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ConnectionSettingsRequest)
        ConnectionSettingsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ConnectionSettingsRequest_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ConnectionSettingsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ConnectionSettingsRequest.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ConnectionSettingsRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getOpampFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        opamp_ = null;
        if (opampBuilder_ != null) {
          opampBuilder_.dispose();
          opampBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ConnectionSettingsRequest_descriptor;
      }

      @Override
      public ConnectionSettingsRequest getDefaultInstanceForType() {
        return ConnectionSettingsRequest.getDefaultInstance();
      }

      @Override
      public ConnectionSettingsRequest build() {
        ConnectionSettingsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ConnectionSettingsRequest buildPartial() {
        ConnectionSettingsRequest result = new ConnectionSettingsRequest(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(ConnectionSettingsRequest result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.opamp_ = opampBuilder_ == null ? opamp_ : opampBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ConnectionSettingsRequest) {
          return mergeFrom((ConnectionSettingsRequest) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ConnectionSettingsRequest other) {
        if (other == ConnectionSettingsRequest.getDefaultInstance()) return this;
        if (other.hasOpamp()) {
          mergeOpamp(other.getOpamp());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  input.readMessage(getOpampFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private OpAMPConnectionSettingsRequest opamp_;
      private com.google.protobuf.SingleFieldBuilderV3<
              OpAMPConnectionSettingsRequest,
              OpAMPConnectionSettingsRequest.Builder,
              OpAMPConnectionSettingsRequestOrBuilder>
          opampBuilder_;

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       *
       * @return Whether the opamp field is set.
       */
      public boolean hasOpamp() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       *
       * @return The opamp.
       */
      public OpAMPConnectionSettingsRequest getOpamp() {
        if (opampBuilder_ == null) {
          return opamp_ == null ? OpAMPConnectionSettingsRequest.getDefaultInstance() : opamp_;
        } else {
          return opampBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      public Builder setOpamp(OpAMPConnectionSettingsRequest value) {
        if (opampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          opamp_ = value;
        } else {
          opampBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      public Builder setOpamp(OpAMPConnectionSettingsRequest.Builder builderForValue) {
        if (opampBuilder_ == null) {
          opamp_ = builderForValue.build();
        } else {
          opampBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      public Builder mergeOpamp(OpAMPConnectionSettingsRequest value) {
        if (opampBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)
              && opamp_ != null
              && opamp_ != OpAMPConnectionSettingsRequest.getDefaultInstance()) {
            getOpampBuilder().mergeFrom(value);
          } else {
            opamp_ = value;
          }
        } else {
          opampBuilder_.mergeFrom(value);
        }
        if (opamp_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      public Builder clearOpamp() {
        bitField0_ = (bitField0_ & ~0x00000001);
        opamp_ = null;
        if (opampBuilder_ != null) {
          opampBuilder_.dispose();
          opampBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      public OpAMPConnectionSettingsRequest.Builder getOpampBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getOpampFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      public OpAMPConnectionSettingsRequestOrBuilder getOpampOrBuilder() {
        if (opampBuilder_ != null) {
          return opampBuilder_.getMessageOrBuilder();
        } else {
          return opamp_ == null ? OpAMPConnectionSettingsRequest.getDefaultInstance() : opamp_;
        }
      }

      /**
       *
       *
       * <pre>
       * Request for OpAMP connection settings. If this field is unset
       * then the ConnectionSettingsRequest message is empty and is not actionable
       * for the Server.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              OpAMPConnectionSettingsRequest,
              OpAMPConnectionSettingsRequest.Builder,
              OpAMPConnectionSettingsRequestOrBuilder>
          getOpampFieldBuilder() {
        if (opampBuilder_ == null) {
          opampBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  OpAMPConnectionSettingsRequest,
                  OpAMPConnectionSettingsRequest.Builder,
                  OpAMPConnectionSettingsRequestOrBuilder>(
                  getOpamp(), getParentForChildren(), isClean());
          opamp_ = null;
        }
        return opampBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ConnectionSettingsRequest)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ConnectionSettingsRequest)
    private static final ConnectionSettingsRequest DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ConnectionSettingsRequest();
    }

    public static ConnectionSettingsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ConnectionSettingsRequest> PARSER =
        new com.google.protobuf.AbstractParser<ConnectionSettingsRequest>() {
          @Override
          public ConnectionSettingsRequest parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ConnectionSettingsRequest> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ConnectionSettingsRequest> getParserForType() {
      return PARSER;
    }

    @Override
    public ConnectionSettingsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface OpAMPConnectionSettingsRequestOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.OpAMPConnectionSettingsRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A request to create a client certificate. This is used to initiate a
     * Client Signing Request (CSR) flow.
     * Required.
     * </pre>
     *
     * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
     *
     * @return Whether the certificateRequest field is set.
     */
    boolean hasCertificateRequest();

    /**
     *
     *
     * <pre>
     * A request to create a client certificate. This is used to initiate a
     * Client Signing Request (CSR) flow.
     * Required.
     * </pre>
     *
     * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
     *
     * @return The certificateRequest.
     */
    CertificateRequest getCertificateRequest();

    /**
     *
     *
     * <pre>
     * A request to create a client certificate. This is used to initiate a
     * Client Signing Request (CSR) flow.
     * Required.
     * </pre>
     *
     * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
     */
    CertificateRequestOrBuilder getCertificateRequestOrBuilder();
  }

  /**
   *
   *
   * <pre>
   * OpAMPConnectionSettingsRequest is a request for the Server to produce
   * a OpAMPConnectionSettings in its response.
   * Status: [Development]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.OpAMPConnectionSettingsRequest}
   */
  public static final class OpAMPConnectionSettingsRequest
      extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.OpAMPConnectionSettingsRequest)
      OpAMPConnectionSettingsRequestOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use OpAMPConnectionSettingsRequest.newBuilder() to construct.
    private OpAMPConnectionSettingsRequest(
        com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private OpAMPConnectionSettingsRequest() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new OpAMPConnectionSettingsRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_OpAMPConnectionSettingsRequest_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_OpAMPConnectionSettingsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(OpAMPConnectionSettingsRequest.class, Builder.class);
    }

    private int bitField0_;
    public static final int CERTIFICATE_REQUEST_FIELD_NUMBER = 1;
    private CertificateRequest certificateRequest_;

    /**
     *
     *
     * <pre>
     * A request to create a client certificate. This is used to initiate a
     * Client Signing Request (CSR) flow.
     * Required.
     * </pre>
     *
     * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
     *
     * @return Whether the certificateRequest field is set.
     */
    @Override
    public boolean hasCertificateRequest() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * A request to create a client certificate. This is used to initiate a
     * Client Signing Request (CSR) flow.
     * Required.
     * </pre>
     *
     * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
     *
     * @return The certificateRequest.
     */
    @Override
    public CertificateRequest getCertificateRequest() {
      return certificateRequest_ == null
          ? CertificateRequest.getDefaultInstance()
          : certificateRequest_;
    }

    /**
     *
     *
     * <pre>
     * A request to create a client certificate. This is used to initiate a
     * Client Signing Request (CSR) flow.
     * Required.
     * </pre>
     *
     * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
     */
    @Override
    public CertificateRequestOrBuilder getCertificateRequestOrBuilder() {
      return certificateRequest_ == null
          ? CertificateRequest.getDefaultInstance()
          : certificateRequest_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getCertificateRequest());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(1, getCertificateRequest());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof OpAMPConnectionSettingsRequest)) {
        return super.equals(obj);
      }
      OpAMPConnectionSettingsRequest other = (OpAMPConnectionSettingsRequest) obj;

      if (hasCertificateRequest() != other.hasCertificateRequest()) return false;
      if (hasCertificateRequest()) {
        if (!getCertificateRequest().equals(other.getCertificateRequest())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCertificateRequest()) {
        hash = (37 * hash) + CERTIFICATE_REQUEST_FIELD_NUMBER;
        hash = (53 * hash) + getCertificateRequest().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static OpAMPConnectionSettingsRequest parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static OpAMPConnectionSettingsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static OpAMPConnectionSettingsRequest parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(
        com.google.protobuf.CodedInputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static OpAMPConnectionSettingsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(OpAMPConnectionSettingsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * OpAMPConnectionSettingsRequest is a request for the Server to produce
     * a OpAMPConnectionSettings in its response.
     * Status: [Development]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.OpAMPConnectionSettingsRequest}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.OpAMPConnectionSettingsRequest)
        OpAMPConnectionSettingsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_OpAMPConnectionSettingsRequest_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_OpAMPConnectionSettingsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(OpAMPConnectionSettingsRequest.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.OpAMPConnectionSettingsRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getCertificateRequestFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        certificateRequest_ = null;
        if (certificateRequestBuilder_ != null) {
          certificateRequestBuilder_.dispose();
          certificateRequestBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_OpAMPConnectionSettingsRequest_descriptor;
      }

      @Override
      public OpAMPConnectionSettingsRequest getDefaultInstanceForType() {
        return OpAMPConnectionSettingsRequest.getDefaultInstance();
      }

      @Override
      public OpAMPConnectionSettingsRequest build() {
        OpAMPConnectionSettingsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public OpAMPConnectionSettingsRequest buildPartial() {
        OpAMPConnectionSettingsRequest result = new OpAMPConnectionSettingsRequest(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(OpAMPConnectionSettingsRequest result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.certificateRequest_ =
              certificateRequestBuilder_ == null
                  ? certificateRequest_
                  : certificateRequestBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof OpAMPConnectionSettingsRequest) {
          return mergeFrom((OpAMPConnectionSettingsRequest) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(OpAMPConnectionSettingsRequest other) {
        if (other == OpAMPConnectionSettingsRequest.getDefaultInstance()) return this;
        if (other.hasCertificateRequest()) {
          mergeCertificateRequest(other.getCertificateRequest());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  input.readMessage(
                      getCertificateRequestFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private CertificateRequest certificateRequest_;
      private com.google.protobuf.SingleFieldBuilderV3<
              CertificateRequest, CertificateRequest.Builder, CertificateRequestOrBuilder>
          certificateRequestBuilder_;

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       *
       * @return Whether the certificateRequest field is set.
       */
      public boolean hasCertificateRequest() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       *
       * @return The certificateRequest.
       */
      public CertificateRequest getCertificateRequest() {
        if (certificateRequestBuilder_ == null) {
          return certificateRequest_ == null
              ? CertificateRequest.getDefaultInstance()
              : certificateRequest_;
        } else {
          return certificateRequestBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      public Builder setCertificateRequest(CertificateRequest value) {
        if (certificateRequestBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificateRequest_ = value;
        } else {
          certificateRequestBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      public Builder setCertificateRequest(CertificateRequest.Builder builderForValue) {
        if (certificateRequestBuilder_ == null) {
          certificateRequest_ = builderForValue.build();
        } else {
          certificateRequestBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      public Builder mergeCertificateRequest(CertificateRequest value) {
        if (certificateRequestBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)
              && certificateRequest_ != null
              && certificateRequest_ != CertificateRequest.getDefaultInstance()) {
            getCertificateRequestBuilder().mergeFrom(value);
          } else {
            certificateRequest_ = value;
          }
        } else {
          certificateRequestBuilder_.mergeFrom(value);
        }
        if (certificateRequest_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      public Builder clearCertificateRequest() {
        bitField0_ = (bitField0_ & ~0x00000001);
        certificateRequest_ = null;
        if (certificateRequestBuilder_ != null) {
          certificateRequestBuilder_.dispose();
          certificateRequestBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      public CertificateRequest.Builder getCertificateRequestBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getCertificateRequestFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      public CertificateRequestOrBuilder getCertificateRequestOrBuilder() {
        if (certificateRequestBuilder_ != null) {
          return certificateRequestBuilder_.getMessageOrBuilder();
        } else {
          return certificateRequest_ == null
              ? CertificateRequest.getDefaultInstance()
              : certificateRequest_;
        }
      }

      /**
       *
       *
       * <pre>
       * A request to create a client certificate. This is used to initiate a
       * Client Signing Request (CSR) flow.
       * Required.
       * </pre>
       *
       * <code>.opamp.proto.CertificateRequest certificate_request = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              CertificateRequest, CertificateRequest.Builder, CertificateRequestOrBuilder>
          getCertificateRequestFieldBuilder() {
        if (certificateRequestBuilder_ == null) {
          certificateRequestBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  CertificateRequest, CertificateRequest.Builder, CertificateRequestOrBuilder>(
                  getCertificateRequest(), getParentForChildren(), isClean());
          certificateRequest_ = null;
        }
        return certificateRequestBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.OpAMPConnectionSettingsRequest)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.OpAMPConnectionSettingsRequest)
    private static final OpAMPConnectionSettingsRequest DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new OpAMPConnectionSettingsRequest();
    }

    public static OpAMPConnectionSettingsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OpAMPConnectionSettingsRequest> PARSER =
        new com.google.protobuf.AbstractParser<OpAMPConnectionSettingsRequest>() {
          @Override
          public OpAMPConnectionSettingsRequest parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<OpAMPConnectionSettingsRequest> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<OpAMPConnectionSettingsRequest> getParserForType() {
      return PARSER;
    }

    @Override
    public OpAMPConnectionSettingsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface CertificateRequestOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.CertificateRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
     * The Server SHOULD validate the request and SHOULD respond with a
     * OpAMPConnectionSettings where the certificate.cert contains the issued
     * certificate.
     * </pre>
     *
     * <code>bytes csr = 1;</code>
     *
     * @return The csr.
     */
    com.google.protobuf.ByteString getCsr();
  }

  /**
   *
   *
   * <pre>
   * Status: [Development]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.CertificateRequest}
   */
  public static final class CertificateRequest extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.CertificateRequest)
      CertificateRequestOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CertificateRequest.newBuilder() to construct.
    private CertificateRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CertificateRequest() {
      csr_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new CertificateRequest();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_CertificateRequest_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_CertificateRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(CertificateRequest.class, Builder.class);
    }

    public static final int CSR_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString csr_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
     * The Server SHOULD validate the request and SHOULD respond with a
     * OpAMPConnectionSettings where the certificate.cert contains the issued
     * certificate.
     * </pre>
     *
     * <code>bytes csr = 1;</code>
     *
     * @return The csr.
     */
    @Override
    public com.google.protobuf.ByteString getCsr() {
      return csr_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!csr_.isEmpty()) {
        output.writeBytes(1, csr_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!csr_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, csr_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof CertificateRequest)) {
        return super.equals(obj);
      }
      CertificateRequest other = (CertificateRequest) obj;

      if (!getCsr().equals(other.getCsr())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CSR_FIELD_NUMBER;
      hash = (53 * hash) + getCsr().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static CertificateRequest parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CertificateRequest parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CertificateRequest parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CertificateRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CertificateRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CertificateRequest parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CertificateRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static CertificateRequest parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static CertificateRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static CertificateRequest parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static CertificateRequest parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static CertificateRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(CertificateRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Status: [Development]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.CertificateRequest}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.CertificateRequest)
        CertificateRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_CertificateRequest_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_CertificateRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(CertificateRequest.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.CertificateRequest.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        csr_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_CertificateRequest_descriptor;
      }

      @Override
      public CertificateRequest getDefaultInstanceForType() {
        return CertificateRequest.getDefaultInstance();
      }

      @Override
      public CertificateRequest build() {
        CertificateRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public CertificateRequest buildPartial() {
        CertificateRequest result = new CertificateRequest(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(CertificateRequest result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.csr_ = csr_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof CertificateRequest) {
          return mergeFrom((CertificateRequest) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(CertificateRequest other) {
        if (other == CertificateRequest.getDefaultInstance()) return this;
        if (other.getCsr() != com.google.protobuf.ByteString.EMPTY) {
          setCsr(other.getCsr());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  csr_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString csr_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
       * The Server SHOULD validate the request and SHOULD respond with a
       * OpAMPConnectionSettings where the certificate.cert contains the issued
       * certificate.
       * </pre>
       *
       * <code>bytes csr = 1;</code>
       *
       * @return The csr.
       */
      @Override
      public com.google.protobuf.ByteString getCsr() {
        return csr_;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
       * The Server SHOULD validate the request and SHOULD respond with a
       * OpAMPConnectionSettings where the certificate.cert contains the issued
       * certificate.
       * </pre>
       *
       * <code>bytes csr = 1;</code>
       *
       * @param value The csr to set.
       * @return This builder for chaining.
       */
      public Builder setCsr(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        csr_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
       * The Server SHOULD validate the request and SHOULD respond with a
       * OpAMPConnectionSettings where the certificate.cert contains the issued
       * certificate.
       * </pre>
       *
       * <code>bytes csr = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCsr() {
        bitField0_ = (bitField0_ & ~0x00000001);
        csr_ = getDefaultInstance().getCsr();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.CertificateRequest)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.CertificateRequest)
    private static final CertificateRequest DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new CertificateRequest();
    }

    public static CertificateRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CertificateRequest> PARSER =
        new com.google.protobuf.AbstractParser<CertificateRequest>() {
          @Override
          public CertificateRequest parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<CertificateRequest> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<CertificateRequest> getParserForType() {
      return PARSER;
    }

    @Override
    public CertificateRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AvailableComponentsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AvailableComponents)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    int getComponentsCount();

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    boolean containsComponents(String key);

    /** Use {@link #getComponentsMap()} instead. */
    @Deprecated
    java.util.Map<String, ComponentDetails> getComponents();

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    java.util.Map<String, ComponentDetails> getComponentsMap();

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    /* nullable */
    ComponentDetails getComponentsOrDefault(
        String key,
        /* nullable */
        ComponentDetails defaultValue);

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    ComponentDetails getComponentsOrThrow(String key);

    /**
     *
     *
     * <pre>
     * Agent-calculated hash of the components.
     * This hash should be included in every AvailableComponents message.
     * </pre>
     *
     * <code>bytes hash = 2;</code>
     *
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }

  /**
   *
   *
   * <pre>
   * AvailableComponents contains metadata relating to the components included
   * within the agent.
   * status: [Development]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.AvailableComponents}
   */
  public static final class AvailableComponents extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AvailableComponents)
      AvailableComponentsOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AvailableComponents.newBuilder() to construct.
    private AvailableComponents(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AvailableComponents() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AvailableComponents();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AvailableComponents_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetComponents();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AvailableComponents_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AvailableComponents.class, Builder.class);
    }

    public static final int COMPONENTS_FIELD_NUMBER = 1;

    private static final class ComponentsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, ComponentDetails> defaultEntry =
          com.google.protobuf.MapEntry.<String, ComponentDetails>newDefaultInstance(
              Opamp.internal_static_opamp_proto_AvailableComponents_ComponentsEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              ComponentDetails.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, ComponentDetails> components_;

    private com.google.protobuf.MapField<String, ComponentDetails> internalGetComponents() {
      if (components_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ComponentsDefaultEntryHolder.defaultEntry);
      }
      return components_;
    }

    public int getComponentsCount() {
      return internalGetComponents().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    @Override
    public boolean containsComponents(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetComponents().getMap().containsKey(key);
    }

    /** Use {@link #getComponentsMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, ComponentDetails> getComponents() {
      return getComponentsMap();
    }

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    @Override
    public java.util.Map<String, ComponentDetails> getComponentsMap() {
      return internalGetComponents().getMap();
    }

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    @Override
    public /* nullable */ ComponentDetails getComponentsOrDefault(
        String key,
        /* nullable */
        ComponentDetails defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, ComponentDetails> map = internalGetComponents().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * A map of a unique component ID to details about the component.
     * This may be omitted from the message if the server has not
     * explicitly requested it be sent by setting the ReportAvailableComponents
     * flag in the previous ServerToAgent message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
     */
    @Override
    public ComponentDetails getComponentsOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, ComponentDetails> map = internalGetComponents().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Agent-calculated hash of the components.
     * This hash should be included in every AvailableComponents message.
     * </pre>
     *
     * <code>bytes hash = 2;</code>
     *
     * @return The hash.
     */
    @Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetComponents(), ComponentsDefaultEntryHolder.defaultEntry, 1);
      if (!hash_.isEmpty()) {
        output.writeBytes(2, hash_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<String, ComponentDetails> entry :
          internalGetComponents().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, ComponentDetails> components__ =
            ComponentsDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, components__);
      }
      if (!hash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, hash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AvailableComponents)) {
        return super.equals(obj);
      }
      AvailableComponents other = (AvailableComponents) obj;

      if (!internalGetComponents().equals(other.internalGetComponents())) return false;
      if (!getHash().equals(other.getHash())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetComponents().getMap().isEmpty()) {
        hash = (37 * hash) + COMPONENTS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetComponents().hashCode();
      }
      hash = (37 * hash) + HASH_FIELD_NUMBER;
      hash = (53 * hash) + getHash().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AvailableComponents parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AvailableComponents parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AvailableComponents parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AvailableComponents parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AvailableComponents parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AvailableComponents parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AvailableComponents parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AvailableComponents parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AvailableComponents parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AvailableComponents parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AvailableComponents parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AvailableComponents parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AvailableComponents prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * AvailableComponents contains metadata relating to the components included
     * within the agent.
     * status: [Development]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.AvailableComponents}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AvailableComponents)
        AvailableComponentsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AvailableComponents_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetComponents();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableComponents();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AvailableComponents_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AvailableComponents.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AvailableComponents.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutableComponents().clear();
        hash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AvailableComponents_descriptor;
      }

      @Override
      public AvailableComponents getDefaultInstanceForType() {
        return AvailableComponents.getDefaultInstance();
      }

      @Override
      public AvailableComponents build() {
        AvailableComponents result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AvailableComponents buildPartial() {
        AvailableComponents result = new AvailableComponents(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(AvailableComponents result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.components_ =
              internalGetComponents().build(ComponentsDefaultEntryHolder.defaultEntry);
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.hash_ = hash_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AvailableComponents) {
          return mergeFrom((AvailableComponents) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AvailableComponents other) {
        if (other == AvailableComponents.getDefaultInstance()) return this;
        internalGetMutableComponents().mergeFrom(other.internalGetComponents());
        bitField0_ |= 0x00000001;
        if (other.getHash() != com.google.protobuf.ByteString.EMPTY) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  com.google.protobuf.MapEntry<String, ComponentDetails> components__ =
                      input.readMessage(
                          ComponentsDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutableComponents()
                      .ensureBuilderMap()
                      .put(components__.getKey(), components__.getValue());
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  hash_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private static final class ComponentsConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, ComponentDetailsOrBuilder, ComponentDetails> {
        @Override
        public ComponentDetails build(ComponentDetailsOrBuilder val) {
          if (val instanceof ComponentDetails) {
            return (ComponentDetails) val;
          }
          return ((ComponentDetails.Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, ComponentDetails> defaultEntry() {
          return ComponentsDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final ComponentsConverter componentsConverter = new ComponentsConverter();

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentDetailsOrBuilder, ComponentDetails, ComponentDetails.Builder>
          components_;

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentDetailsOrBuilder, ComponentDetails, ComponentDetails.Builder>
          internalGetComponents() {
        if (components_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(componentsConverter);
        }
        return components_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentDetailsOrBuilder, ComponentDetails, ComponentDetails.Builder>
          internalGetMutableComponents() {
        if (components_ == null) {
          components_ = new com.google.protobuf.MapFieldBuilder<>(componentsConverter);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return components_;
      }

      public int getComponentsCount() {
        return internalGetComponents().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      @Override
      public boolean containsComponents(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetComponents().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getComponentsMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, ComponentDetails> getComponents() {
        return getComponentsMap();
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      @Override
      public java.util.Map<String, ComponentDetails> getComponentsMap() {
        return internalGetComponents().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      @Override
      public /* nullable */ ComponentDetails getComponentsOrDefault(
          String key,
          /* nullable */
          ComponentDetails defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, ComponentDetailsOrBuilder> map =
            internalGetMutableComponents().ensureBuilderMap();
        return map.containsKey(key) ? componentsConverter.build(map.get(key)) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      @Override
      public ComponentDetails getComponentsOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, ComponentDetailsOrBuilder> map =
            internalGetMutableComponents().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return componentsConverter.build(map.get(key));
      }

      public Builder clearComponents() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableComponents().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      public Builder removeComponents(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutableComponents().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, ComponentDetails> getMutableComponents() {
        bitField0_ |= 0x00000001;
        return internalGetMutableComponents().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      public Builder putComponents(String key, ComponentDetails value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutableComponents().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      public Builder putAllComponents(java.util.Map<String, ComponentDetails> values) {
        for (java.util.Map.Entry<String, ComponentDetails> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableComponents().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of a unique component ID to details about the component.
       * This may be omitted from the message if the server has not
       * explicitly requested it be sent by setting the ReportAvailableComponents
       * flag in the previous ServerToAgent message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; components = 1;</code>
       */
      public ComponentDetails.Builder putComponentsBuilderIfAbsent(String key) {
        java.util.Map<String, ComponentDetailsOrBuilder> builderMap =
            internalGetMutableComponents().ensureBuilderMap();
        ComponentDetailsOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = ComponentDetails.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof ComponentDetails) {
          entry = ((ComponentDetails) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (ComponentDetails.Builder) entry;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Agent-calculated hash of the components.
       * This hash should be included in every AvailableComponents message.
       * </pre>
       *
       * <code>bytes hash = 2;</code>
       *
       * @return The hash.
       */
      @Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }

      /**
       *
       *
       * <pre>
       * Agent-calculated hash of the components.
       * This hash should be included in every AvailableComponents message.
       * </pre>
       *
       * <code>bytes hash = 2;</code>
       *
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        hash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Agent-calculated hash of the components.
       * This hash should be included in every AvailableComponents message.
       * </pre>
       *
       * <code>bytes hash = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AvailableComponents)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AvailableComponents)
    private static final AvailableComponents DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AvailableComponents();
    }

    public static AvailableComponents getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AvailableComponents> PARSER =
        new com.google.protobuf.AbstractParser<AvailableComponents>() {
          @Override
          public AvailableComponents parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AvailableComponents> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AvailableComponents> getParserForType() {
      return PARSER;
    }

    @Override
    public AvailableComponents getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ComponentDetailsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ComponentDetails)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    java.util.List<Anyvalue.KeyValue> getMetadataList();

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    Anyvalue.KeyValue getMetadata(int index);

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    int getMetadataCount();

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    java.util.List<? extends Anyvalue.KeyValueOrBuilder> getMetadataOrBuilderList();

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    Anyvalue.KeyValueOrBuilder getMetadataOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    int getSubComponentMapCount();

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    boolean containsSubComponentMap(String key);

    /** Use {@link #getSubComponentMapMap()} instead. */
    @Deprecated
    java.util.Map<String, ComponentDetails> getSubComponentMap();

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    java.util.Map<String, ComponentDetails> getSubComponentMapMap();

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    /* nullable */
    ComponentDetails getSubComponentMapOrDefault(
        String key,
        /* nullable */
        ComponentDetails defaultValue);

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    ComponentDetails getSubComponentMapOrThrow(String key);
  }

  /** Protobuf type {@code opamp.proto.ComponentDetails} */
  public static final class ComponentDetails extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ComponentDetails)
      ComponentDetailsOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ComponentDetails.newBuilder() to construct.
    private ComponentDetails(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ComponentDetails() {
      metadata_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ComponentDetails();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ComponentDetails_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 2:
          return internalGetSubComponentMap();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ComponentDetails_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ComponentDetails.class, Builder.class);
    }

    public static final int METADATA_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private java.util.List<Anyvalue.KeyValue> metadata_;

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    @Override
    public java.util.List<Anyvalue.KeyValue> getMetadataList() {
      return metadata_;
    }

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    @Override
    public java.util.List<? extends Anyvalue.KeyValueOrBuilder> getMetadataOrBuilderList() {
      return metadata_;
    }

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    @Override
    public int getMetadataCount() {
      return metadata_.size();
    }

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    @Override
    public Anyvalue.KeyValue getMetadata(int index) {
      return metadata_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Extra key/value pairs that may be used to describe the component.
     * The key/value pairs are according to semantic conventions, see:
     * https://opentelemetry.io/docs/specs/semconv/
     *
     * For example, you may use the "code" semantic conventions to
     * report the location of the code for a specific component:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
     *
     * Or you may use the "vcs" semantic conventions to report the
     * repository the component may be a part of:
     * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
     */
    @Override
    public Anyvalue.KeyValueOrBuilder getMetadataOrBuilder(int index) {
      return metadata_.get(index);
    }

    public static final int SUB_COMPONENT_MAP_FIELD_NUMBER = 2;

    private static final class SubComponentMapDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, ComponentDetails> defaultEntry =
          com.google.protobuf.MapEntry.<String, ComponentDetails>newDefaultInstance(
              Opamp.internal_static_opamp_proto_ComponentDetails_SubComponentMapEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              ComponentDetails.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, ComponentDetails> subComponentMap_;

    private com.google.protobuf.MapField<String, ComponentDetails> internalGetSubComponentMap() {
      if (subComponentMap_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SubComponentMapDefaultEntryHolder.defaultEntry);
      }
      return subComponentMap_;
    }

    public int getSubComponentMapCount() {
      return internalGetSubComponentMap().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    @Override
    public boolean containsSubComponentMap(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetSubComponentMap().getMap().containsKey(key);
    }

    /** Use {@link #getSubComponentMapMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, ComponentDetails> getSubComponentMap() {
      return getSubComponentMapMap();
    }

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    @Override
    public java.util.Map<String, ComponentDetails> getSubComponentMapMap() {
      return internalGetSubComponentMap().getMap();
    }

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    @Override
    public /* nullable */ ComponentDetails getSubComponentMapOrDefault(
        String key,
        /* nullable */
        ComponentDetails defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, ComponentDetails> map = internalGetSubComponentMap().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * A map of component ID to sub components details. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
     */
    @Override
    public ComponentDetails getSubComponentMapOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, ComponentDetails> map = internalGetSubComponentMap().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < metadata_.size(); i++) {
        output.writeMessage(1, metadata_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetSubComponentMap(), SubComponentMapDefaultEntryHolder.defaultEntry, 2);
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < metadata_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, metadata_.get(i));
      }
      for (java.util.Map.Entry<String, ComponentDetails> entry :
          internalGetSubComponentMap().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, ComponentDetails> subComponentMap__ =
            SubComponentMapDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, subComponentMap__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ComponentDetails)) {
        return super.equals(obj);
      }
      ComponentDetails other = (ComponentDetails) obj;

      if (!getMetadataList().equals(other.getMetadataList())) return false;
      if (!internalGetSubComponentMap().equals(other.internalGetSubComponentMap())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getMetadataCount() > 0) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataList().hashCode();
      }
      if (!internalGetSubComponentMap().getMap().isEmpty()) {
        hash = (37 * hash) + SUB_COMPONENT_MAP_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSubComponentMap().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ComponentDetails parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ComponentDetails parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ComponentDetails parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ComponentDetails parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ComponentDetails parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ComponentDetails parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ComponentDetails parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ComponentDetails parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ComponentDetails parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ComponentDetails parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ComponentDetails parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ComponentDetails parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ComponentDetails prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.ComponentDetails} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ComponentDetails)
        ComponentDetailsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ComponentDetails_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 2:
            return internalGetSubComponentMap();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableSubComponentMap();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ComponentDetails_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ComponentDetails.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ComponentDetails.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (metadataBuilder_ == null) {
          metadata_ = java.util.Collections.emptyList();
        } else {
          metadata_ = null;
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableSubComponentMap().clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ComponentDetails_descriptor;
      }

      @Override
      public ComponentDetails getDefaultInstanceForType() {
        return ComponentDetails.getDefaultInstance();
      }

      @Override
      public ComponentDetails build() {
        ComponentDetails result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ComponentDetails buildPartial() {
        ComponentDetails result = new ComponentDetails(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(ComponentDetails result) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            metadata_ = java.util.Collections.unmodifiableList(metadata_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
      }

      private void buildPartial0(ComponentDetails result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.subComponentMap_ =
              internalGetSubComponentMap().build(SubComponentMapDefaultEntryHolder.defaultEntry);
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ComponentDetails) {
          return mergeFrom((ComponentDetails) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ComponentDetails other) {
        if (other == ComponentDetails.getDefaultInstance()) return this;
        if (metadataBuilder_ == null) {
          if (!other.metadata_.isEmpty()) {
            if (metadata_.isEmpty()) {
              metadata_ = other.metadata_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureMetadataIsMutable();
              metadata_.addAll(other.metadata_);
            }
            onChanged();
          }
        } else {
          if (!other.metadata_.isEmpty()) {
            if (metadataBuilder_.isEmpty()) {
              metadataBuilder_.dispose();
              metadataBuilder_ = null;
              metadata_ = other.metadata_;
              bitField0_ = (bitField0_ & ~0x00000001);
              metadataBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getMetadataFieldBuilder()
                      : null;
            } else {
              metadataBuilder_.addAllMessages(other.metadata_);
            }
          }
        }
        internalGetMutableSubComponentMap().mergeFrom(other.internalGetSubComponentMap());
        bitField0_ |= 0x00000002;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  Anyvalue.KeyValue m =
                      input.readMessage(Anyvalue.KeyValue.parser(), extensionRegistry);
                  if (metadataBuilder_ == null) {
                    ensureMetadataIsMutable();
                    metadata_.add(m);
                  } else {
                    metadataBuilder_.addMessage(m);
                  }
                  break;
                } // case 10
              case 18:
                {
                  com.google.protobuf.MapEntry<String, ComponentDetails> subComponentMap__ =
                      input.readMessage(
                          SubComponentMapDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutableSubComponentMap()
                      .ensureBuilderMap()
                      .put(subComponentMap__.getKey(), subComponentMap__.getValue());
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private java.util.List<Anyvalue.KeyValue> metadata_ = java.util.Collections.emptyList();

      private void ensureMetadataIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          metadata_ = new java.util.ArrayList<Anyvalue.KeyValue>(metadata_);
          bitField0_ |= 0x00000001;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>
          metadataBuilder_;

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public java.util.List<Anyvalue.KeyValue> getMetadataList() {
        if (metadataBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadata_);
        } else {
          return metadataBuilder_.getMessageList();
        }
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public int getMetadataCount() {
        if (metadataBuilder_ == null) {
          return metadata_.size();
        } else {
          return metadataBuilder_.getCount();
        }
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Anyvalue.KeyValue getMetadata(int index) {
        if (metadataBuilder_ == null) {
          return metadata_.get(index);
        } else {
          return metadataBuilder_.getMessage(index);
        }
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder setMetadata(int index, Anyvalue.KeyValue value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataIsMutable();
          metadata_.set(index, value);
          onChanged();
        } else {
          metadataBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder setMetadata(int index, Anyvalue.KeyValue.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          ensureMetadataIsMutable();
          metadata_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder addMetadata(Anyvalue.KeyValue value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataIsMutable();
          metadata_.add(value);
          onChanged();
        } else {
          metadataBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder addMetadata(int index, Anyvalue.KeyValue value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataIsMutable();
          metadata_.add(index, value);
          onChanged();
        } else {
          metadataBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder addMetadata(Anyvalue.KeyValue.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          ensureMetadataIsMutable();
          metadata_.add(builderForValue.build());
          onChanged();
        } else {
          metadataBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder addMetadata(int index, Anyvalue.KeyValue.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          ensureMetadataIsMutable();
          metadata_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder addAllMetadata(Iterable<? extends Anyvalue.KeyValue> values) {
        if (metadataBuilder_ == null) {
          ensureMetadataIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, metadata_);
          onChanged();
        } else {
          metadataBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Builder removeMetadata(int index) {
        if (metadataBuilder_ == null) {
          ensureMetadataIsMutable();
          metadata_.remove(index);
          onChanged();
        } else {
          metadataBuilder_.remove(index);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Anyvalue.KeyValue.Builder getMetadataBuilder(int index) {
        return getMetadataFieldBuilder().getBuilder(index);
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Anyvalue.KeyValueOrBuilder getMetadataOrBuilder(int index) {
        if (metadataBuilder_ == null) {
          return metadata_.get(index);
        } else {
          return metadataBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public java.util.List<? extends Anyvalue.KeyValueOrBuilder> getMetadataOrBuilderList() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadata_);
        }
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Anyvalue.KeyValue.Builder addMetadataBuilder() {
        return getMetadataFieldBuilder().addBuilder(Anyvalue.KeyValue.getDefaultInstance());
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public Anyvalue.KeyValue.Builder addMetadataBuilder(int index) {
        return getMetadataFieldBuilder().addBuilder(index, Anyvalue.KeyValue.getDefaultInstance());
      }

      /**
       *
       *
       * <pre>
       * Extra key/value pairs that may be used to describe the component.
       * The key/value pairs are according to semantic conventions, see:
       * https://opentelemetry.io/docs/specs/semconv/
       *
       * For example, you may use the "code" semantic conventions to
       * report the location of the code for a specific component:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/code/
       *
       * Or you may use the "vcs" semantic conventions to report the
       * repository the component may be a part of:
       * https://opentelemetry.io/docs/specs/semconv/attributes-registry/vcs/
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue metadata = 1;</code>
       */
      public java.util.List<Anyvalue.KeyValue.Builder> getMetadataBuilderList() {
        return getMetadataFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>(
                  metadata_, ((bitField0_ & 0x00000001) != 0), getParentForChildren(), isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private static final class SubComponentMapConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, ComponentDetailsOrBuilder, ComponentDetails> {
        @Override
        public ComponentDetails build(ComponentDetailsOrBuilder val) {
          if (val instanceof ComponentDetails) {
            return (ComponentDetails) val;
          }
          return ((Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, ComponentDetails> defaultEntry() {
          return SubComponentMapDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final SubComponentMapConverter subComponentMapConverter =
          new SubComponentMapConverter();

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentDetailsOrBuilder, ComponentDetails, Builder>
          subComponentMap_;

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentDetailsOrBuilder, ComponentDetails, Builder>
          internalGetSubComponentMap() {
        if (subComponentMap_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(subComponentMapConverter);
        }
        return subComponentMap_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentDetailsOrBuilder, ComponentDetails, Builder>
          internalGetMutableSubComponentMap() {
        if (subComponentMap_ == null) {
          subComponentMap_ = new com.google.protobuf.MapFieldBuilder<>(subComponentMapConverter);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return subComponentMap_;
      }

      public int getSubComponentMapCount() {
        return internalGetSubComponentMap().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      @Override
      public boolean containsSubComponentMap(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetSubComponentMap().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getSubComponentMapMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, ComponentDetails> getSubComponentMap() {
        return getSubComponentMapMap();
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      @Override
      public java.util.Map<String, ComponentDetails> getSubComponentMapMap() {
        return internalGetSubComponentMap().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      @Override
      public /* nullable */ ComponentDetails getSubComponentMapOrDefault(
          String key,
          /* nullable */
          ComponentDetails defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, ComponentDetailsOrBuilder> map =
            internalGetMutableSubComponentMap().ensureBuilderMap();
        return map.containsKey(key) ? subComponentMapConverter.build(map.get(key)) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      @Override
      public ComponentDetails getSubComponentMapOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, ComponentDetailsOrBuilder> map =
            internalGetMutableSubComponentMap().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return subComponentMapConverter.build(map.get(key));
      }

      public Builder clearSubComponentMap() {
        bitField0_ = (bitField0_ & ~0x00000002);
        internalGetMutableSubComponentMap().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      public Builder removeSubComponentMap(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutableSubComponentMap().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, ComponentDetails> getMutableSubComponentMap() {
        bitField0_ |= 0x00000002;
        return internalGetMutableSubComponentMap().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      public Builder putSubComponentMap(String key, ComponentDetails value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutableSubComponentMap().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000002;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      public Builder putAllSubComponentMap(java.util.Map<String, ComponentDetails> values) {
        for (java.util.Map.Entry<String, ComponentDetails> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableSubComponentMap().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000002;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of component ID to sub components details. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentDetails&gt; sub_component_map = 2;</code>
       */
      public Builder putSubComponentMapBuilderIfAbsent(String key) {
        java.util.Map<String, ComponentDetailsOrBuilder> builderMap =
            internalGetMutableSubComponentMap().ensureBuilderMap();
        ComponentDetailsOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = ComponentDetails.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof ComponentDetails) {
          entry = ((ComponentDetails) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (Builder) entry;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ComponentDetails)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ComponentDetails)
    private static final ComponentDetails DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ComponentDetails();
    }

    public static ComponentDetails getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ComponentDetails> PARSER =
        new com.google.protobuf.AbstractParser<ComponentDetails>() {
          @Override
          public ComponentDetails parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ComponentDetails> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ComponentDetails> getParserForType() {
      return PARSER;
    }

    @Override
    public ComponentDetails getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ServerToAgentOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ServerToAgent)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
     * Used for multiplexing messages from/to multiple agents using one message stream.
     * </pre>
     *
     * <code>bytes instance_uid = 1;</code>
     *
     * @return The instanceUid.
     */
    com.google.protobuf.ByteString getInstanceUid();

    /**
     *
     *
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     *
     * @return Whether the errorResponse field is set.
     */
    boolean hasErrorResponse();

    /**
     *
     *
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     *
     * @return The errorResponse.
     */
    ServerErrorResponse getErrorResponse();

    /**
     *
     *
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     */
    ServerErrorResponseOrBuilder getErrorResponseOrBuilder();

    /**
     *
     *
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     *
     * @return Whether the remoteConfig field is set.
     */
    boolean hasRemoteConfig();

    /**
     *
     *
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     *
     * @return The remoteConfig.
     */
    AgentRemoteConfig getRemoteConfig();

    /**
     *
     *
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     */
    AgentRemoteConfigOrBuilder getRemoteConfigOrBuilder();

    /**
     *
     *
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     *
     * @return Whether the connectionSettings field is set.
     */
    boolean hasConnectionSettings();

    /**
     *
     *
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     *
     * @return The connectionSettings.
     */
    ConnectionSettingsOffers getConnectionSettings();

    /**
     *
     *
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     */
    ConnectionSettingsOffersOrBuilder getConnectionSettingsOrBuilder();

    /**
     *
     *
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     *
     * @return Whether the packagesAvailable field is set.
     */
    boolean hasPackagesAvailable();

    /**
     *
     *
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     *
     * @return The packagesAvailable.
     */
    PackagesAvailable getPackagesAvailable();

    /**
     *
     *
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     */
    PackagesAvailableOrBuilder getPackagesAvailableOrBuilder();

    /**
     *
     *
     * <pre>
     * Bit flags as defined by ServerToAgentFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 6;</code>
     *
     * @return The flags.
     */
    long getFlags();

    /**
     *
     *
     * <pre>
     * Bitmask of flags defined by ServerCapabilities enum.
     * All bits that are not defined in ServerCapabilities enum MUST be set to 0
     * by the Server. This allows extending the protocol and the ServerCapabilities
     * enum in the future such that old Servers automatically report that they
     * don't support the new capability.
     * This field MUST be set in the first ServerToAgent sent by the Server and MAY
     * be omitted in subsequent ServerToAgent messages by setting it to
     * UnspecifiedServerCapability value.
     * </pre>
     *
     * <code>uint64 capabilities = 7;</code>
     *
     * @return The capabilities.
     */
    long getCapabilities();

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     *
     * @return Whether the agentIdentification field is set.
     */
    boolean hasAgentIdentification();

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     *
     * @return The agentIdentification.
     */
    AgentIdentification getAgentIdentification();

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     */
    AgentIdentificationOrBuilder getAgentIdentificationOrBuilder();

    /**
     *
     *
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     *
     * @return Whether the command field is set.
     */
    boolean hasCommand();

    /**
     *
     *
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     *
     * @return The command.
     */
    ServerToAgentCommand getCommand();

    /**
     *
     *
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     */
    ServerToAgentCommandOrBuilder getCommandOrBuilder();

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
     *
     * @return Whether the customCapabilities field is set.
     */
    boolean hasCustomCapabilities();

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
     *
     * @return The customCapabilities.
     */
    CustomCapabilities getCustomCapabilities();

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
     */
    CustomCapabilitiesOrBuilder getCustomCapabilitiesOrBuilder();

    /**
     *
     *
     * <pre>
     * A custom message sent from the Server to an Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
     *
     * @return Whether the customMessage field is set.
     */
    boolean hasCustomMessage();

    /**
     *
     *
     * <pre>
     * A custom message sent from the Server to an Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
     *
     * @return The customMessage.
     */
    CustomMessage getCustomMessage();

    /**
     *
     *
     * <pre>
     * A custom message sent from the Server to an Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
     */
    CustomMessageOrBuilder getCustomMessageOrBuilder();
  }

  /** Protobuf type {@code opamp.proto.ServerToAgent} */
  public static final class ServerToAgent extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ServerToAgent)
      ServerToAgentOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ServerToAgent.newBuilder() to construct.
    private ServerToAgent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ServerToAgent() {
      instanceUid_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ServerToAgent();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ServerToAgent_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ServerToAgent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ServerToAgent.class, Builder.class);
    }

    private int bitField0_;
    public static final int INSTANCE_UID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString instanceUid_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
     * Used for multiplexing messages from/to multiple agents using one message stream.
     * </pre>
     *
     * <code>bytes instance_uid = 1;</code>
     *
     * @return The instanceUid.
     */
    @Override
    public com.google.protobuf.ByteString getInstanceUid() {
      return instanceUid_;
    }

    public static final int ERROR_RESPONSE_FIELD_NUMBER = 2;
    private ServerErrorResponse errorResponse_;

    /**
     *
     *
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     *
     * @return Whether the errorResponse field is set.
     */
    @Override
    public boolean hasErrorResponse() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     *
     * @return The errorResponse.
     */
    @Override
    public ServerErrorResponse getErrorResponse() {
      return errorResponse_ == null ? ServerErrorResponse.getDefaultInstance() : errorResponse_;
    }

    /**
     *
     *
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     */
    @Override
    public ServerErrorResponseOrBuilder getErrorResponseOrBuilder() {
      return errorResponse_ == null ? ServerErrorResponse.getDefaultInstance() : errorResponse_;
    }

    public static final int REMOTE_CONFIG_FIELD_NUMBER = 3;
    private AgentRemoteConfig remoteConfig_;

    /**
     *
     *
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     *
     * @return Whether the remoteConfig field is set.
     */
    @Override
    public boolean hasRemoteConfig() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     *
     * @return The remoteConfig.
     */
    @Override
    public AgentRemoteConfig getRemoteConfig() {
      return remoteConfig_ == null ? AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
    }

    /**
     *
     *
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     */
    @Override
    public AgentRemoteConfigOrBuilder getRemoteConfigOrBuilder() {
      return remoteConfig_ == null ? AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
    }

    public static final int CONNECTION_SETTINGS_FIELD_NUMBER = 4;
    private ConnectionSettingsOffers connectionSettings_;

    /**
     *
     *
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     *
     * @return Whether the connectionSettings field is set.
     */
    @Override
    public boolean hasConnectionSettings() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     *
     *
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     *
     * @return The connectionSettings.
     */
    @Override
    public ConnectionSettingsOffers getConnectionSettings() {
      return connectionSettings_ == null
          ? ConnectionSettingsOffers.getDefaultInstance()
          : connectionSettings_;
    }

    /**
     *
     *
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     */
    @Override
    public ConnectionSettingsOffersOrBuilder getConnectionSettingsOrBuilder() {
      return connectionSettings_ == null
          ? ConnectionSettingsOffers.getDefaultInstance()
          : connectionSettings_;
    }

    public static final int PACKAGES_AVAILABLE_FIELD_NUMBER = 5;
    private PackagesAvailable packagesAvailable_;

    /**
     *
     *
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     *
     * @return Whether the packagesAvailable field is set.
     */
    @Override
    public boolean hasPackagesAvailable() {
      return ((bitField0_ & 0x00000008) != 0);
    }

    /**
     *
     *
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     *
     * @return The packagesAvailable.
     */
    @Override
    public PackagesAvailable getPackagesAvailable() {
      return packagesAvailable_ == null
          ? PackagesAvailable.getDefaultInstance()
          : packagesAvailable_;
    }

    /**
     *
     *
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     */
    @Override
    public PackagesAvailableOrBuilder getPackagesAvailableOrBuilder() {
      return packagesAvailable_ == null
          ? PackagesAvailable.getDefaultInstance()
          : packagesAvailable_;
    }

    public static final int FLAGS_FIELD_NUMBER = 6;
    private long flags_ = 0L;

    /**
     *
     *
     * <pre>
     * Bit flags as defined by ServerToAgentFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 6;</code>
     *
     * @return The flags.
     */
    @Override
    public long getFlags() {
      return flags_;
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 7;
    private long capabilities_ = 0L;

    /**
     *
     *
     * <pre>
     * Bitmask of flags defined by ServerCapabilities enum.
     * All bits that are not defined in ServerCapabilities enum MUST be set to 0
     * by the Server. This allows extending the protocol and the ServerCapabilities
     * enum in the future such that old Servers automatically report that they
     * don't support the new capability.
     * This field MUST be set in the first ServerToAgent sent by the Server and MAY
     * be omitted in subsequent ServerToAgent messages by setting it to
     * UnspecifiedServerCapability value.
     * </pre>
     *
     * <code>uint64 capabilities = 7;</code>
     *
     * @return The capabilities.
     */
    @Override
    public long getCapabilities() {
      return capabilities_;
    }

    public static final int AGENT_IDENTIFICATION_FIELD_NUMBER = 8;
    private AgentIdentification agentIdentification_;

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     *
     * @return Whether the agentIdentification field is set.
     */
    @Override
    public boolean hasAgentIdentification() {
      return ((bitField0_ & 0x00000010) != 0);
    }

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     *
     * @return The agentIdentification.
     */
    @Override
    public AgentIdentification getAgentIdentification() {
      return agentIdentification_ == null
          ? AgentIdentification.getDefaultInstance()
          : agentIdentification_;
    }

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     */
    @Override
    public AgentIdentificationOrBuilder getAgentIdentificationOrBuilder() {
      return agentIdentification_ == null
          ? AgentIdentification.getDefaultInstance()
          : agentIdentification_;
    }

    public static final int COMMAND_FIELD_NUMBER = 9;
    private ServerToAgentCommand command_;

    /**
     *
     *
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     *
     * @return Whether the command field is set.
     */
    @Override
    public boolean hasCommand() {
      return ((bitField0_ & 0x00000020) != 0);
    }

    /**
     *
     *
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     *
     * @return The command.
     */
    @Override
    public ServerToAgentCommand getCommand() {
      return command_ == null ? ServerToAgentCommand.getDefaultInstance() : command_;
    }

    /**
     *
     *
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * Status: [Beta]
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     */
    @Override
    public ServerToAgentCommandOrBuilder getCommandOrBuilder() {
      return command_ == null ? ServerToAgentCommand.getDefaultInstance() : command_;
    }

    public static final int CUSTOM_CAPABILITIES_FIELD_NUMBER = 10;
    private CustomCapabilities customCapabilities_;

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
     *
     * @return Whether the customCapabilities field is set.
     */
    @Override
    public boolean hasCustomCapabilities() {
      return ((bitField0_ & 0x00000040) != 0);
    }

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
     *
     * @return The customCapabilities.
     */
    @Override
    public CustomCapabilities getCustomCapabilities() {
      return customCapabilities_ == null
          ? CustomCapabilities.getDefaultInstance()
          : customCapabilities_;
    }

    /**
     *
     *
     * <pre>
     * A message indicating custom capabilities supported by the Server.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
     */
    @Override
    public CustomCapabilitiesOrBuilder getCustomCapabilitiesOrBuilder() {
      return customCapabilities_ == null
          ? CustomCapabilities.getDefaultInstance()
          : customCapabilities_;
    }

    public static final int CUSTOM_MESSAGE_FIELD_NUMBER = 11;
    private CustomMessage customMessage_;

    /**
     *
     *
     * <pre>
     * A custom message sent from the Server to an Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
     *
     * @return Whether the customMessage field is set.
     */
    @Override
    public boolean hasCustomMessage() {
      return ((bitField0_ & 0x00000080) != 0);
    }

    /**
     *
     *
     * <pre>
     * A custom message sent from the Server to an Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
     *
     * @return The customMessage.
     */
    @Override
    public CustomMessage getCustomMessage() {
      return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
    }

    /**
     *
     *
     * <pre>
     * A custom message sent from the Server to an Agent.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
     */
    @Override
    public CustomMessageOrBuilder getCustomMessageOrBuilder() {
      return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!instanceUid_.isEmpty()) {
        output.writeBytes(1, instanceUid_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getErrorResponse());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getRemoteConfig());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(4, getConnectionSettings());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(5, getPackagesAvailable());
      }
      if (flags_ != 0L) {
        output.writeUInt64(6, flags_);
      }
      if (capabilities_ != 0L) {
        output.writeUInt64(7, capabilities_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(8, getAgentIdentification());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(9, getCommand());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(10, getCustomCapabilities());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(11, getCustomMessage());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!instanceUid_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, instanceUid_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getErrorResponse());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getRemoteConfig());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(4, getConnectionSettings());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(5, getPackagesAvailable());
      }
      if (flags_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(6, flags_);
      }
      if (capabilities_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(7, capabilities_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(8, getAgentIdentification());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(9, getCommand());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(10, getCustomCapabilities());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(11, getCustomMessage());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ServerToAgent)) {
        return super.equals(obj);
      }
      ServerToAgent other = (ServerToAgent) obj;

      if (!getInstanceUid().equals(other.getInstanceUid())) return false;
      if (hasErrorResponse() != other.hasErrorResponse()) return false;
      if (hasErrorResponse()) {
        if (!getErrorResponse().equals(other.getErrorResponse())) return false;
      }
      if (hasRemoteConfig() != other.hasRemoteConfig()) return false;
      if (hasRemoteConfig()) {
        if (!getRemoteConfig().equals(other.getRemoteConfig())) return false;
      }
      if (hasConnectionSettings() != other.hasConnectionSettings()) return false;
      if (hasConnectionSettings()) {
        if (!getConnectionSettings().equals(other.getConnectionSettings())) return false;
      }
      if (hasPackagesAvailable() != other.hasPackagesAvailable()) return false;
      if (hasPackagesAvailable()) {
        if (!getPackagesAvailable().equals(other.getPackagesAvailable())) return false;
      }
      if (getFlags() != other.getFlags()) return false;
      if (getCapabilities() != other.getCapabilities()) return false;
      if (hasAgentIdentification() != other.hasAgentIdentification()) return false;
      if (hasAgentIdentification()) {
        if (!getAgentIdentification().equals(other.getAgentIdentification())) return false;
      }
      if (hasCommand() != other.hasCommand()) return false;
      if (hasCommand()) {
        if (!getCommand().equals(other.getCommand())) return false;
      }
      if (hasCustomCapabilities() != other.hasCustomCapabilities()) return false;
      if (hasCustomCapabilities()) {
        if (!getCustomCapabilities().equals(other.getCustomCapabilities())) return false;
      }
      if (hasCustomMessage() != other.hasCustomMessage()) return false;
      if (hasCustomMessage()) {
        if (!getCustomMessage().equals(other.getCustomMessage())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + INSTANCE_UID_FIELD_NUMBER;
      hash = (53 * hash) + getInstanceUid().hashCode();
      if (hasErrorResponse()) {
        hash = (37 * hash) + ERROR_RESPONSE_FIELD_NUMBER;
        hash = (53 * hash) + getErrorResponse().hashCode();
      }
      if (hasRemoteConfig()) {
        hash = (37 * hash) + REMOTE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getRemoteConfig().hashCode();
      }
      if (hasConnectionSettings()) {
        hash = (37 * hash) + CONNECTION_SETTINGS_FIELD_NUMBER;
        hash = (53 * hash) + getConnectionSettings().hashCode();
      }
      if (hasPackagesAvailable()) {
        hash = (37 * hash) + PACKAGES_AVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getPackagesAvailable().hashCode();
      }
      hash = (37 * hash) + FLAGS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getFlags());
      hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getCapabilities());
      if (hasAgentIdentification()) {
        hash = (37 * hash) + AGENT_IDENTIFICATION_FIELD_NUMBER;
        hash = (53 * hash) + getAgentIdentification().hashCode();
      }
      if (hasCommand()) {
        hash = (37 * hash) + COMMAND_FIELD_NUMBER;
        hash = (53 * hash) + getCommand().hashCode();
      }
      if (hasCustomCapabilities()) {
        hash = (37 * hash) + CUSTOM_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCustomCapabilities().hashCode();
      }
      if (hasCustomMessage()) {
        hash = (37 * hash) + CUSTOM_MESSAGE_FIELD_NUMBER;
        hash = (53 * hash) + getCustomMessage().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ServerToAgent parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerToAgent parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerToAgent parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerToAgent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerToAgent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerToAgent parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerToAgent parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ServerToAgent parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ServerToAgent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ServerToAgent parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ServerToAgent parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ServerToAgent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ServerToAgent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.ServerToAgent} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ServerToAgent)
        ServerToAgentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ServerToAgent_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ServerToAgent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ServerToAgent.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ServerToAgent.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getErrorResponseFieldBuilder();
          getRemoteConfigFieldBuilder();
          getConnectionSettingsFieldBuilder();
          getPackagesAvailableFieldBuilder();
          getAgentIdentificationFieldBuilder();
          getCommandFieldBuilder();
          getCustomCapabilitiesFieldBuilder();
          getCustomMessageFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        instanceUid_ = com.google.protobuf.ByteString.EMPTY;
        errorResponse_ = null;
        if (errorResponseBuilder_ != null) {
          errorResponseBuilder_.dispose();
          errorResponseBuilder_ = null;
        }
        remoteConfig_ = null;
        if (remoteConfigBuilder_ != null) {
          remoteConfigBuilder_.dispose();
          remoteConfigBuilder_ = null;
        }
        connectionSettings_ = null;
        if (connectionSettingsBuilder_ != null) {
          connectionSettingsBuilder_.dispose();
          connectionSettingsBuilder_ = null;
        }
        packagesAvailable_ = null;
        if (packagesAvailableBuilder_ != null) {
          packagesAvailableBuilder_.dispose();
          packagesAvailableBuilder_ = null;
        }
        flags_ = 0L;
        capabilities_ = 0L;
        agentIdentification_ = null;
        if (agentIdentificationBuilder_ != null) {
          agentIdentificationBuilder_.dispose();
          agentIdentificationBuilder_ = null;
        }
        command_ = null;
        if (commandBuilder_ != null) {
          commandBuilder_.dispose();
          commandBuilder_ = null;
        }
        customCapabilities_ = null;
        if (customCapabilitiesBuilder_ != null) {
          customCapabilitiesBuilder_.dispose();
          customCapabilitiesBuilder_ = null;
        }
        customMessage_ = null;
        if (customMessageBuilder_ != null) {
          customMessageBuilder_.dispose();
          customMessageBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ServerToAgent_descriptor;
      }

      @Override
      public ServerToAgent getDefaultInstanceForType() {
        return ServerToAgent.getDefaultInstance();
      }

      @Override
      public ServerToAgent build() {
        ServerToAgent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ServerToAgent buildPartial() {
        ServerToAgent result = new ServerToAgent(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(ServerToAgent result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.instanceUid_ = instanceUid_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.errorResponse_ =
              errorResponseBuilder_ == null ? errorResponse_ : errorResponseBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.remoteConfig_ =
              remoteConfigBuilder_ == null ? remoteConfig_ : remoteConfigBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.connectionSettings_ =
              connectionSettingsBuilder_ == null
                  ? connectionSettings_
                  : connectionSettingsBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.packagesAvailable_ =
              packagesAvailableBuilder_ == null
                  ? packagesAvailable_
                  : packagesAvailableBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.flags_ = flags_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.capabilities_ = capabilities_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.agentIdentification_ =
              agentIdentificationBuilder_ == null
                  ? agentIdentification_
                  : agentIdentificationBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.command_ = commandBuilder_ == null ? command_ : commandBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.customCapabilities_ =
              customCapabilitiesBuilder_ == null
                  ? customCapabilities_
                  : customCapabilitiesBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.customMessage_ =
              customMessageBuilder_ == null ? customMessage_ : customMessageBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ServerToAgent) {
          return mergeFrom((ServerToAgent) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ServerToAgent other) {
        if (other == ServerToAgent.getDefaultInstance()) return this;
        if (other.getInstanceUid() != com.google.protobuf.ByteString.EMPTY) {
          setInstanceUid(other.getInstanceUid());
        }
        if (other.hasErrorResponse()) {
          mergeErrorResponse(other.getErrorResponse());
        }
        if (other.hasRemoteConfig()) {
          mergeRemoteConfig(other.getRemoteConfig());
        }
        if (other.hasConnectionSettings()) {
          mergeConnectionSettings(other.getConnectionSettings());
        }
        if (other.hasPackagesAvailable()) {
          mergePackagesAvailable(other.getPackagesAvailable());
        }
        if (other.getFlags() != 0L) {
          setFlags(other.getFlags());
        }
        if (other.getCapabilities() != 0L) {
          setCapabilities(other.getCapabilities());
        }
        if (other.hasAgentIdentification()) {
          mergeAgentIdentification(other.getAgentIdentification());
        }
        if (other.hasCommand()) {
          mergeCommand(other.getCommand());
        }
        if (other.hasCustomCapabilities()) {
          mergeCustomCapabilities(other.getCustomCapabilities());
        }
        if (other.hasCustomMessage()) {
          mergeCustomMessage(other.getCustomMessage());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  instanceUid_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  input.readMessage(getErrorResponseFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getRemoteConfigFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  input.readMessage(
                      getConnectionSettingsFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              case 42:
                {
                  input.readMessage(
                      getPackagesAvailableFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000010;
                  break;
                } // case 42
              case 48:
                {
                  flags_ = input.readUInt64();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
              case 56:
                {
                  capabilities_ = input.readUInt64();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 56
              case 66:
                {
                  input.readMessage(
                      getAgentIdentificationFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000080;
                  break;
                } // case 66
              case 74:
                {
                  input.readMessage(getCommandFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000100;
                  break;
                } // case 74
              case 82:
                {
                  input.readMessage(
                      getCustomCapabilitiesFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000200;
                  break;
                } // case 82
              case 90:
                {
                  input.readMessage(getCustomMessageFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000400;
                  break;
                } // case 90
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString instanceUid_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>bytes instance_uid = 1;</code>
       *
       * @return The instanceUid.
       */
      @Override
      public com.google.protobuf.ByteString getInstanceUid() {
        return instanceUid_;
      }

      /**
       *
       *
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>bytes instance_uid = 1;</code>
       *
       * @param value The instanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceUid(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        instanceUid_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>bytes instance_uid = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearInstanceUid() {
        bitField0_ = (bitField0_ & ~0x00000001);
        instanceUid_ = getDefaultInstance().getInstanceUid();
        onChanged();
        return this;
      }

      private ServerErrorResponse errorResponse_;
      private com.google.protobuf.SingleFieldBuilderV3<
              ServerErrorResponse, ServerErrorResponse.Builder, ServerErrorResponseOrBuilder>
          errorResponseBuilder_;

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       *
       * @return Whether the errorResponse field is set.
       */
      public boolean hasErrorResponse() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       *
       * @return The errorResponse.
       */
      public ServerErrorResponse getErrorResponse() {
        if (errorResponseBuilder_ == null) {
          return errorResponse_ == null ? ServerErrorResponse.getDefaultInstance() : errorResponse_;
        } else {
          return errorResponseBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder setErrorResponse(ServerErrorResponse value) {
        if (errorResponseBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          errorResponse_ = value;
        } else {
          errorResponseBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder setErrorResponse(ServerErrorResponse.Builder builderForValue) {
        if (errorResponseBuilder_ == null) {
          errorResponse_ = builderForValue.build();
        } else {
          errorResponseBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder mergeErrorResponse(ServerErrorResponse value) {
        if (errorResponseBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)
              && errorResponse_ != null
              && errorResponse_ != ServerErrorResponse.getDefaultInstance()) {
            getErrorResponseBuilder().mergeFrom(value);
          } else {
            errorResponse_ = value;
          }
        } else {
          errorResponseBuilder_.mergeFrom(value);
        }
        if (errorResponse_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder clearErrorResponse() {
        bitField0_ = (bitField0_ & ~0x00000002);
        errorResponse_ = null;
        if (errorResponseBuilder_ != null) {
          errorResponseBuilder_.dispose();
          errorResponseBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public ServerErrorResponse.Builder getErrorResponseBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getErrorResponseFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public ServerErrorResponseOrBuilder getErrorResponseOrBuilder() {
        if (errorResponseBuilder_ != null) {
          return errorResponseBuilder_.getMessageOrBuilder();
        } else {
          return errorResponse_ == null ? ServerErrorResponse.getDefaultInstance() : errorResponse_;
        }
      }

      /**
       *
       *
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              ServerErrorResponse, ServerErrorResponse.Builder, ServerErrorResponseOrBuilder>
          getErrorResponseFieldBuilder() {
        if (errorResponseBuilder_ == null) {
          errorResponseBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  ServerErrorResponse, ServerErrorResponse.Builder, ServerErrorResponseOrBuilder>(
                  getErrorResponse(), getParentForChildren(), isClean());
          errorResponse_ = null;
        }
        return errorResponseBuilder_;
      }

      private AgentRemoteConfig remoteConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentRemoteConfig, AgentRemoteConfig.Builder, AgentRemoteConfigOrBuilder>
          remoteConfigBuilder_;

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       *
       * @return Whether the remoteConfig field is set.
       */
      public boolean hasRemoteConfig() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       *
       * @return The remoteConfig.
       */
      public AgentRemoteConfig getRemoteConfig() {
        if (remoteConfigBuilder_ == null) {
          return remoteConfig_ == null ? AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
        } else {
          return remoteConfigBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder setRemoteConfig(AgentRemoteConfig value) {
        if (remoteConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          remoteConfig_ = value;
        } else {
          remoteConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder setRemoteConfig(AgentRemoteConfig.Builder builderForValue) {
        if (remoteConfigBuilder_ == null) {
          remoteConfig_ = builderForValue.build();
        } else {
          remoteConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder mergeRemoteConfig(AgentRemoteConfig value) {
        if (remoteConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && remoteConfig_ != null
              && remoteConfig_ != AgentRemoteConfig.getDefaultInstance()) {
            getRemoteConfigBuilder().mergeFrom(value);
          } else {
            remoteConfig_ = value;
          }
        } else {
          remoteConfigBuilder_.mergeFrom(value);
        }
        if (remoteConfig_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder clearRemoteConfig() {
        bitField0_ = (bitField0_ & ~0x00000004);
        remoteConfig_ = null;
        if (remoteConfigBuilder_ != null) {
          remoteConfigBuilder_.dispose();
          remoteConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public AgentRemoteConfig.Builder getRemoteConfigBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getRemoteConfigFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public AgentRemoteConfigOrBuilder getRemoteConfigOrBuilder() {
        if (remoteConfigBuilder_ != null) {
          return remoteConfigBuilder_.getMessageOrBuilder();
        } else {
          return remoteConfig_ == null ? AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
        }
      }

      /**
       *
       *
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentRemoteConfig, AgentRemoteConfig.Builder, AgentRemoteConfigOrBuilder>
          getRemoteConfigFieldBuilder() {
        if (remoteConfigBuilder_ == null) {
          remoteConfigBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AgentRemoteConfig, AgentRemoteConfig.Builder, AgentRemoteConfigOrBuilder>(
                  getRemoteConfig(), getParentForChildren(), isClean());
          remoteConfig_ = null;
        }
        return remoteConfigBuilder_;
      }

      private ConnectionSettingsOffers connectionSettings_;
      private com.google.protobuf.SingleFieldBuilderV3<
              ConnectionSettingsOffers,
              ConnectionSettingsOffers.Builder,
              ConnectionSettingsOffersOrBuilder>
          connectionSettingsBuilder_;

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       *
       * @return Whether the connectionSettings field is set.
       */
      public boolean hasConnectionSettings() {
        return ((bitField0_ & 0x00000008) != 0);
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       *
       * @return The connectionSettings.
       */
      public ConnectionSettingsOffers getConnectionSettings() {
        if (connectionSettingsBuilder_ == null) {
          return connectionSettings_ == null
              ? ConnectionSettingsOffers.getDefaultInstance()
              : connectionSettings_;
        } else {
          return connectionSettingsBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder setConnectionSettings(ConnectionSettingsOffers value) {
        if (connectionSettingsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          connectionSettings_ = value;
        } else {
          connectionSettingsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder setConnectionSettings(ConnectionSettingsOffers.Builder builderForValue) {
        if (connectionSettingsBuilder_ == null) {
          connectionSettings_ = builderForValue.build();
        } else {
          connectionSettingsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder mergeConnectionSettings(ConnectionSettingsOffers value) {
        if (connectionSettingsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)
              && connectionSettings_ != null
              && connectionSettings_ != ConnectionSettingsOffers.getDefaultInstance()) {
            getConnectionSettingsBuilder().mergeFrom(value);
          } else {
            connectionSettings_ = value;
          }
        } else {
          connectionSettingsBuilder_.mergeFrom(value);
        }
        if (connectionSettings_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder clearConnectionSettings() {
        bitField0_ = (bitField0_ & ~0x00000008);
        connectionSettings_ = null;
        if (connectionSettingsBuilder_ != null) {
          connectionSettingsBuilder_.dispose();
          connectionSettingsBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public ConnectionSettingsOffers.Builder getConnectionSettingsBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getConnectionSettingsFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public ConnectionSettingsOffersOrBuilder getConnectionSettingsOrBuilder() {
        if (connectionSettingsBuilder_ != null) {
          return connectionSettingsBuilder_.getMessageOrBuilder();
        } else {
          return connectionSettings_ == null
              ? ConnectionSettingsOffers.getDefaultInstance()
              : connectionSettings_;
        }
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              ConnectionSettingsOffers,
              ConnectionSettingsOffers.Builder,
              ConnectionSettingsOffersOrBuilder>
          getConnectionSettingsFieldBuilder() {
        if (connectionSettingsBuilder_ == null) {
          connectionSettingsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  ConnectionSettingsOffers,
                  ConnectionSettingsOffers.Builder,
                  ConnectionSettingsOffersOrBuilder>(
                  getConnectionSettings(), getParentForChildren(), isClean());
          connectionSettings_ = null;
        }
        return connectionSettingsBuilder_;
      }

      private PackagesAvailable packagesAvailable_;
      private com.google.protobuf.SingleFieldBuilderV3<
              PackagesAvailable, PackagesAvailable.Builder, PackagesAvailableOrBuilder>
          packagesAvailableBuilder_;

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       *
       * @return Whether the packagesAvailable field is set.
       */
      public boolean hasPackagesAvailable() {
        return ((bitField0_ & 0x00000010) != 0);
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       *
       * @return The packagesAvailable.
       */
      public PackagesAvailable getPackagesAvailable() {
        if (packagesAvailableBuilder_ == null) {
          return packagesAvailable_ == null
              ? PackagesAvailable.getDefaultInstance()
              : packagesAvailable_;
        } else {
          return packagesAvailableBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder setPackagesAvailable(PackagesAvailable value) {
        if (packagesAvailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          packagesAvailable_ = value;
        } else {
          packagesAvailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder setPackagesAvailable(PackagesAvailable.Builder builderForValue) {
        if (packagesAvailableBuilder_ == null) {
          packagesAvailable_ = builderForValue.build();
        } else {
          packagesAvailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder mergePackagesAvailable(PackagesAvailable value) {
        if (packagesAvailableBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)
              && packagesAvailable_ != null
              && packagesAvailable_ != PackagesAvailable.getDefaultInstance()) {
            getPackagesAvailableBuilder().mergeFrom(value);
          } else {
            packagesAvailable_ = value;
          }
        } else {
          packagesAvailableBuilder_.mergeFrom(value);
        }
        if (packagesAvailable_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder clearPackagesAvailable() {
        bitField0_ = (bitField0_ & ~0x00000010);
        packagesAvailable_ = null;
        if (packagesAvailableBuilder_ != null) {
          packagesAvailableBuilder_.dispose();
          packagesAvailableBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public PackagesAvailable.Builder getPackagesAvailableBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getPackagesAvailableFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public PackagesAvailableOrBuilder getPackagesAvailableOrBuilder() {
        if (packagesAvailableBuilder_ != null) {
          return packagesAvailableBuilder_.getMessageOrBuilder();
        } else {
          return packagesAvailable_ == null
              ? PackagesAvailable.getDefaultInstance()
              : packagesAvailable_;
        }
      }

      /**
       *
       *
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              PackagesAvailable, PackagesAvailable.Builder, PackagesAvailableOrBuilder>
          getPackagesAvailableFieldBuilder() {
        if (packagesAvailableBuilder_ == null) {
          packagesAvailableBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  PackagesAvailable, PackagesAvailable.Builder, PackagesAvailableOrBuilder>(
                  getPackagesAvailable(), getParentForChildren(), isClean());
          packagesAvailable_ = null;
        }
        return packagesAvailableBuilder_;
      }

      private long flags_;

      /**
       *
       *
       * <pre>
       * Bit flags as defined by ServerToAgentFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 6;</code>
       *
       * @return The flags.
       */
      @Override
      public long getFlags() {
        return flags_;
      }

      /**
       *
       *
       * <pre>
       * Bit flags as defined by ServerToAgentFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 6;</code>
       *
       * @param value The flags to set.
       * @return This builder for chaining.
       */
      public Builder setFlags(long value) {

        flags_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Bit flags as defined by ServerToAgentFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 6;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearFlags() {
        bitField0_ = (bitField0_ & ~0x00000020);
        flags_ = 0L;
        onChanged();
        return this;
      }

      private long capabilities_;

      /**
       *
       *
       * <pre>
       * Bitmask of flags defined by ServerCapabilities enum.
       * All bits that are not defined in ServerCapabilities enum MUST be set to 0
       * by the Server. This allows extending the protocol and the ServerCapabilities
       * enum in the future such that old Servers automatically report that they
       * don't support the new capability.
       * This field MUST be set in the first ServerToAgent sent by the Server and MAY
       * be omitted in subsequent ServerToAgent messages by setting it to
       * UnspecifiedServerCapability value.
       * </pre>
       *
       * <code>uint64 capabilities = 7;</code>
       *
       * @return The capabilities.
       */
      @Override
      public long getCapabilities() {
        return capabilities_;
      }

      /**
       *
       *
       * <pre>
       * Bitmask of flags defined by ServerCapabilities enum.
       * All bits that are not defined in ServerCapabilities enum MUST be set to 0
       * by the Server. This allows extending the protocol and the ServerCapabilities
       * enum in the future such that old Servers automatically report that they
       * don't support the new capability.
       * This field MUST be set in the first ServerToAgent sent by the Server and MAY
       * be omitted in subsequent ServerToAgent messages by setting it to
       * UnspecifiedServerCapability value.
       * </pre>
       *
       * <code>uint64 capabilities = 7;</code>
       *
       * @param value The capabilities to set.
       * @return This builder for chaining.
       */
      public Builder setCapabilities(long value) {

        capabilities_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Bitmask of flags defined by ServerCapabilities enum.
       * All bits that are not defined in ServerCapabilities enum MUST be set to 0
       * by the Server. This allows extending the protocol and the ServerCapabilities
       * enum in the future such that old Servers automatically report that they
       * don't support the new capability.
       * This field MUST be set in the first ServerToAgent sent by the Server and MAY
       * be omitted in subsequent ServerToAgent messages by setting it to
       * UnspecifiedServerCapability value.
       * </pre>
       *
       * <code>uint64 capabilities = 7;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCapabilities() {
        bitField0_ = (bitField0_ & ~0x00000040);
        capabilities_ = 0L;
        onChanged();
        return this;
      }

      private AgentIdentification agentIdentification_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentIdentification, AgentIdentification.Builder, AgentIdentificationOrBuilder>
          agentIdentificationBuilder_;

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       *
       * @return Whether the agentIdentification field is set.
       */
      public boolean hasAgentIdentification() {
        return ((bitField0_ & 0x00000080) != 0);
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       *
       * @return The agentIdentification.
       */
      public AgentIdentification getAgentIdentification() {
        if (agentIdentificationBuilder_ == null) {
          return agentIdentification_ == null
              ? AgentIdentification.getDefaultInstance()
              : agentIdentification_;
        } else {
          return agentIdentificationBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder setAgentIdentification(AgentIdentification value) {
        if (agentIdentificationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          agentIdentification_ = value;
        } else {
          agentIdentificationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder setAgentIdentification(AgentIdentification.Builder builderForValue) {
        if (agentIdentificationBuilder_ == null) {
          agentIdentification_ = builderForValue.build();
        } else {
          agentIdentificationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder mergeAgentIdentification(AgentIdentification value) {
        if (agentIdentificationBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)
              && agentIdentification_ != null
              && agentIdentification_ != AgentIdentification.getDefaultInstance()) {
            getAgentIdentificationBuilder().mergeFrom(value);
          } else {
            agentIdentification_ = value;
          }
        } else {
          agentIdentificationBuilder_.mergeFrom(value);
        }
        if (agentIdentification_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder clearAgentIdentification() {
        bitField0_ = (bitField0_ & ~0x00000080);
        agentIdentification_ = null;
        if (agentIdentificationBuilder_ != null) {
          agentIdentificationBuilder_.dispose();
          agentIdentificationBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public AgentIdentification.Builder getAgentIdentificationBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getAgentIdentificationFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public AgentIdentificationOrBuilder getAgentIdentificationOrBuilder() {
        if (agentIdentificationBuilder_ != null) {
          return agentIdentificationBuilder_.getMessageOrBuilder();
        } else {
          return agentIdentification_ == null
              ? AgentIdentification.getDefaultInstance()
              : agentIdentification_;
        }
      }

      /**
       *
       *
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentIdentification, AgentIdentification.Builder, AgentIdentificationOrBuilder>
          getAgentIdentificationFieldBuilder() {
        if (agentIdentificationBuilder_ == null) {
          agentIdentificationBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AgentIdentification, AgentIdentification.Builder, AgentIdentificationOrBuilder>(
                  getAgentIdentification(), getParentForChildren(), isClean());
          agentIdentification_ = null;
        }
        return agentIdentificationBuilder_;
      }

      private ServerToAgentCommand command_;
      private com.google.protobuf.SingleFieldBuilderV3<
              ServerToAgentCommand, ServerToAgentCommand.Builder, ServerToAgentCommandOrBuilder>
          commandBuilder_;

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       *
       * @return Whether the command field is set.
       */
      public boolean hasCommand() {
        return ((bitField0_ & 0x00000100) != 0);
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       *
       * @return The command.
       */
      public ServerToAgentCommand getCommand() {
        if (commandBuilder_ == null) {
          return command_ == null ? ServerToAgentCommand.getDefaultInstance() : command_;
        } else {
          return commandBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder setCommand(ServerToAgentCommand value) {
        if (commandBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          command_ = value;
        } else {
          commandBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder setCommand(ServerToAgentCommand.Builder builderForValue) {
        if (commandBuilder_ == null) {
          command_ = builderForValue.build();
        } else {
          commandBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder mergeCommand(ServerToAgentCommand value) {
        if (commandBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)
              && command_ != null
              && command_ != ServerToAgentCommand.getDefaultInstance()) {
            getCommandBuilder().mergeFrom(value);
          } else {
            command_ = value;
          }
        } else {
          commandBuilder_.mergeFrom(value);
        }
        if (command_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder clearCommand() {
        bitField0_ = (bitField0_ & ~0x00000100);
        command_ = null;
        if (commandBuilder_ != null) {
          commandBuilder_.dispose();
          commandBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public ServerToAgentCommand.Builder getCommandBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getCommandFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public ServerToAgentCommandOrBuilder getCommandOrBuilder() {
        if (commandBuilder_ != null) {
          return commandBuilder_.getMessageOrBuilder();
        } else {
          return command_ == null ? ServerToAgentCommand.getDefaultInstance() : command_;
        }
      }

      /**
       *
       *
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * Status: [Beta]
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              ServerToAgentCommand, ServerToAgentCommand.Builder, ServerToAgentCommandOrBuilder>
          getCommandFieldBuilder() {
        if (commandBuilder_ == null) {
          commandBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  ServerToAgentCommand,
                  ServerToAgentCommand.Builder,
                  ServerToAgentCommandOrBuilder>(getCommand(), getParentForChildren(), isClean());
          command_ = null;
        }
        return commandBuilder_;
      }

      private CustomCapabilities customCapabilities_;
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomCapabilities, CustomCapabilities.Builder, CustomCapabilitiesOrBuilder>
          customCapabilitiesBuilder_;

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       *
       * @return Whether the customCapabilities field is set.
       */
      public boolean hasCustomCapabilities() {
        return ((bitField0_ & 0x00000200) != 0);
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       *
       * @return The customCapabilities.
       */
      public CustomCapabilities getCustomCapabilities() {
        if (customCapabilitiesBuilder_ == null) {
          return customCapabilities_ == null
              ? CustomCapabilities.getDefaultInstance()
              : customCapabilities_;
        } else {
          return customCapabilitiesBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      public Builder setCustomCapabilities(CustomCapabilities value) {
        if (customCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          customCapabilities_ = value;
        } else {
          customCapabilitiesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      public Builder setCustomCapabilities(CustomCapabilities.Builder builderForValue) {
        if (customCapabilitiesBuilder_ == null) {
          customCapabilities_ = builderForValue.build();
        } else {
          customCapabilitiesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      public Builder mergeCustomCapabilities(CustomCapabilities value) {
        if (customCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)
              && customCapabilities_ != null
              && customCapabilities_ != CustomCapabilities.getDefaultInstance()) {
            getCustomCapabilitiesBuilder().mergeFrom(value);
          } else {
            customCapabilities_ = value;
          }
        } else {
          customCapabilitiesBuilder_.mergeFrom(value);
        }
        if (customCapabilities_ != null) {
          bitField0_ |= 0x00000200;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      public Builder clearCustomCapabilities() {
        bitField0_ = (bitField0_ & ~0x00000200);
        customCapabilities_ = null;
        if (customCapabilitiesBuilder_ != null) {
          customCapabilitiesBuilder_.dispose();
          customCapabilitiesBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      public CustomCapabilities.Builder getCustomCapabilitiesBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getCustomCapabilitiesFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      public CustomCapabilitiesOrBuilder getCustomCapabilitiesOrBuilder() {
        if (customCapabilitiesBuilder_ != null) {
          return customCapabilitiesBuilder_.getMessageOrBuilder();
        } else {
          return customCapabilities_ == null
              ? CustomCapabilities.getDefaultInstance()
              : customCapabilities_;
        }
      }

      /**
       *
       *
       * <pre>
       * A message indicating custom capabilities supported by the Server.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomCapabilities custom_capabilities = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomCapabilities, CustomCapabilities.Builder, CustomCapabilitiesOrBuilder>
          getCustomCapabilitiesFieldBuilder() {
        if (customCapabilitiesBuilder_ == null) {
          customCapabilitiesBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  CustomCapabilities, CustomCapabilities.Builder, CustomCapabilitiesOrBuilder>(
                  getCustomCapabilities(), getParentForChildren(), isClean());
          customCapabilities_ = null;
        }
        return customCapabilitiesBuilder_;
      }

      private CustomMessage customMessage_;
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomMessage, CustomMessage.Builder, CustomMessageOrBuilder>
          customMessageBuilder_;

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       *
       * @return Whether the customMessage field is set.
       */
      public boolean hasCustomMessage() {
        return ((bitField0_ & 0x00000400) != 0);
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       *
       * @return The customMessage.
       */
      public CustomMessage getCustomMessage() {
        if (customMessageBuilder_ == null) {
          return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
        } else {
          return customMessageBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      public Builder setCustomMessage(CustomMessage value) {
        if (customMessageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          customMessage_ = value;
        } else {
          customMessageBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      public Builder setCustomMessage(CustomMessage.Builder builderForValue) {
        if (customMessageBuilder_ == null) {
          customMessage_ = builderForValue.build();
        } else {
          customMessageBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      public Builder mergeCustomMessage(CustomMessage value) {
        if (customMessageBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)
              && customMessage_ != null
              && customMessage_ != CustomMessage.getDefaultInstance()) {
            getCustomMessageBuilder().mergeFrom(value);
          } else {
            customMessage_ = value;
          }
        } else {
          customMessageBuilder_.mergeFrom(value);
        }
        if (customMessage_ != null) {
          bitField0_ |= 0x00000400;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      public Builder clearCustomMessage() {
        bitField0_ = (bitField0_ & ~0x00000400);
        customMessage_ = null;
        if (customMessageBuilder_ != null) {
          customMessageBuilder_.dispose();
          customMessageBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      public CustomMessage.Builder getCustomMessageBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getCustomMessageFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      public CustomMessageOrBuilder getCustomMessageOrBuilder() {
        if (customMessageBuilder_ != null) {
          return customMessageBuilder_.getMessageOrBuilder();
        } else {
          return customMessage_ == null ? CustomMessage.getDefaultInstance() : customMessage_;
        }
      }

      /**
       *
       *
       * <pre>
       * A custom message sent from the Server to an Agent.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.CustomMessage custom_message = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              CustomMessage, CustomMessage.Builder, CustomMessageOrBuilder>
          getCustomMessageFieldBuilder() {
        if (customMessageBuilder_ == null) {
          customMessageBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  CustomMessage, CustomMessage.Builder, CustomMessageOrBuilder>(
                  getCustomMessage(), getParentForChildren(), isClean());
          customMessage_ = null;
        }
        return customMessageBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ServerToAgent)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ServerToAgent)
    private static final ServerToAgent DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ServerToAgent();
    }

    public static ServerToAgent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerToAgent> PARSER =
        new com.google.protobuf.AbstractParser<ServerToAgent>() {
          @Override
          public ServerToAgent parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ServerToAgent> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ServerToAgent> getParserForType() {
      return PARSER;
    }

    @Override
    public ServerToAgent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface OpAMPConnectionSettingsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.OpAMPConnectionSettings)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The destinationEndpoint.
     */
    String getDestinationEndpoint();

    /**
     *
     *
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The bytes for destinationEndpoint.
     */
    com.google.protobuf.ByteString getDestinationEndpointBytes();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return The headers.
     */
    Headers getHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    HeadersOrBuilder getHeadersOrBuilder();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return Whether the certificate field is set.
     */
    boolean hasCertificate();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return The certificate.
     */
    TLSCertificate getCertificate();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    TLSCertificateOrBuilder getCertificateOrBuilder();

    /**
     *
     *
     * <pre>
     * The Agent MUST periodically send an AgentToServer message if the
     * AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
     * field MUST be set.
     *
     * An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
     *
     * A heartbeat is used to keep the connection active and inform the server that the Agent
     * is still alive and active.
     *
     * If this field has no value or is set to 0, the Agent should not send any heartbeats.
     * Status: [Development]
     * </pre>
     *
     * <code>uint64 heartbeat_interval_seconds = 4;</code>
     *
     * @return The heartbeatIntervalSeconds.
     */
    long getHeartbeatIntervalSeconds();
  }

  /**
   *
   *
   * <pre>
   * The OpAMPConnectionSettings message is a collection of fields which comprise an
   * offer from the Server to the Agent to use the specified settings for OpAMP
   * connection.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.OpAMPConnectionSettings}
   */
  public static final class OpAMPConnectionSettings extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.OpAMPConnectionSettings)
      OpAMPConnectionSettingsOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use OpAMPConnectionSettings.newBuilder() to construct.
    private OpAMPConnectionSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private OpAMPConnectionSettings() {
      destinationEndpoint_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new OpAMPConnectionSettings();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(OpAMPConnectionSettings.class, Builder.class);
    }

    private int bitField0_;
    public static final int DESTINATION_ENDPOINT_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object destinationEndpoint_ = "";

    /**
     *
     *
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The destinationEndpoint.
     */
    @Override
    public String getDestinationEndpoint() {
      Object ref = destinationEndpoint_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        destinationEndpoint_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The bytes for destinationEndpoint.
     */
    @Override
    public com.google.protobuf.ByteString getDestinationEndpointBytes() {
      Object ref = destinationEndpoint_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        destinationEndpoint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HEADERS_FIELD_NUMBER = 2;
    private Headers headers_;

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return Whether the headers field is set.
     */
    @Override
    public boolean hasHeaders() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return The headers.
     */
    @Override
    public Headers getHeaders() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    @Override
    public HeadersOrBuilder getHeadersOrBuilder() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    public static final int CERTIFICATE_FIELD_NUMBER = 3;
    private TLSCertificate certificate_;

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return Whether the certificate field is set.
     */
    @Override
    public boolean hasCertificate() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return The certificate.
     */
    @Override
    public TLSCertificate getCertificate() {
      return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
    }

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    @Override
    public TLSCertificateOrBuilder getCertificateOrBuilder() {
      return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
    }

    public static final int HEARTBEAT_INTERVAL_SECONDS_FIELD_NUMBER = 4;
    private long heartbeatIntervalSeconds_ = 0L;

    /**
     *
     *
     * <pre>
     * The Agent MUST periodically send an AgentToServer message if the
     * AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
     * field MUST be set.
     *
     * An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
     *
     * A heartbeat is used to keep the connection active and inform the server that the Agent
     * is still alive and active.
     *
     * If this field has no value or is set to 0, the Agent should not send any heartbeats.
     * Status: [Development]
     * </pre>
     *
     * <code>uint64 heartbeat_interval_seconds = 4;</code>
     *
     * @return The heartbeatIntervalSeconds.
     */
    @Override
    public long getHeartbeatIntervalSeconds() {
      return heartbeatIntervalSeconds_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, destinationEndpoint_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getHeaders());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getCertificate());
      }
      if (heartbeatIntervalSeconds_ != 0L) {
        output.writeUInt64(4, heartbeatIntervalSeconds_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, destinationEndpoint_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getHeaders());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getCertificate());
      }
      if (heartbeatIntervalSeconds_ != 0L) {
        size +=
            com.google.protobuf.CodedOutputStream.computeUInt64Size(4, heartbeatIntervalSeconds_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof OpAMPConnectionSettings)) {
        return super.equals(obj);
      }
      OpAMPConnectionSettings other = (OpAMPConnectionSettings) obj;

      if (!getDestinationEndpoint().equals(other.getDestinationEndpoint())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders().equals(other.getHeaders())) return false;
      }
      if (hasCertificate() != other.hasCertificate()) return false;
      if (hasCertificate()) {
        if (!getCertificate().equals(other.getCertificate())) return false;
      }
      if (getHeartbeatIntervalSeconds() != other.getHeartbeatIntervalSeconds()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DESTINATION_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getDestinationEndpoint().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      if (hasCertificate()) {
        hash = (37 * hash) + CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getCertificate().hashCode();
      }
      hash = (37 * hash) + HEARTBEAT_INTERVAL_SECONDS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getHeartbeatIntervalSeconds());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static OpAMPConnectionSettings parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OpAMPConnectionSettings parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OpAMPConnectionSettings parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OpAMPConnectionSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OpAMPConnectionSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OpAMPConnectionSettings parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OpAMPConnectionSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static OpAMPConnectionSettings parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static OpAMPConnectionSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static OpAMPConnectionSettings parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static OpAMPConnectionSettings parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static OpAMPConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(OpAMPConnectionSettings prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * The OpAMPConnectionSettings message is a collection of fields which comprise an
     * offer from the Server to the Agent to use the specified settings for OpAMP
     * connection.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.OpAMPConnectionSettings}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.OpAMPConnectionSettings)
        OpAMPConnectionSettingsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable
            .ensureFieldAccessorsInitialized(OpAMPConnectionSettings.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.OpAMPConnectionSettings.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getHeadersFieldBuilder();
          getCertificateFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        destinationEndpoint_ = "";
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        certificate_ = null;
        if (certificateBuilder_ != null) {
          certificateBuilder_.dispose();
          certificateBuilder_ = null;
        }
        heartbeatIntervalSeconds_ = 0L;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
      }

      @Override
      public OpAMPConnectionSettings getDefaultInstanceForType() {
        return OpAMPConnectionSettings.getDefaultInstance();
      }

      @Override
      public OpAMPConnectionSettings build() {
        OpAMPConnectionSettings result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public OpAMPConnectionSettings buildPartial() {
        OpAMPConnectionSettings result = new OpAMPConnectionSettings(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(OpAMPConnectionSettings result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.destinationEndpoint_ = destinationEndpoint_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.headers_ = headersBuilder_ == null ? headers_ : headersBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.certificate_ =
              certificateBuilder_ == null ? certificate_ : certificateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.heartbeatIntervalSeconds_ = heartbeatIntervalSeconds_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof OpAMPConnectionSettings) {
          return mergeFrom((OpAMPConnectionSettings) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(OpAMPConnectionSettings other) {
        if (other == OpAMPConnectionSettings.getDefaultInstance()) return this;
        if (!other.getDestinationEndpoint().isEmpty()) {
          destinationEndpoint_ = other.destinationEndpoint_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        if (other.hasCertificate()) {
          mergeCertificate(other.getCertificate());
        }
        if (other.getHeartbeatIntervalSeconds() != 0L) {
          setHeartbeatIntervalSeconds(other.getHeartbeatIntervalSeconds());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  destinationEndpoint_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  input.readMessage(getHeadersFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getCertificateFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 32:
                {
                  heartbeatIntervalSeconds_ = input.readUInt64();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object destinationEndpoint_ = "";

      /**
       *
       *
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return The destinationEndpoint.
       */
      public String getDestinationEndpoint() {
        Object ref = destinationEndpoint_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          destinationEndpoint_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return The bytes for destinationEndpoint.
       */
      public com.google.protobuf.ByteString getDestinationEndpointBytes() {
        Object ref = destinationEndpoint_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          destinationEndpoint_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @param value The destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpoint(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        destinationEndpoint_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearDestinationEndpoint() {
        destinationEndpoint_ = getDefaultInstance().getDestinationEndpoint();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @param value The bytes for destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpointBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        destinationEndpoint_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          headersBuilder_;

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       *
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       *
       * @return The headers.
       */
      public Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
        } else {
          headersBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder mergeHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)
              && headers_ != null
              && headers_ != Headers.getDefaultInstance()) {
            getHeadersBuilder().mergeFrom(value);
          } else {
            headers_ = value;
          }
        } else {
          headersBuilder_.mergeFrom(value);
        }
        if (headers_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder clearHeaders() {
        bitField0_ = (bitField0_ & ~0x00000002);
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Headers.Builder getHeadersBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  Headers, Headers.Builder, HeadersOrBuilder>(
                  getHeaders(), getParentForChildren(), isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      private TLSCertificate certificate_;
      private com.google.protobuf.SingleFieldBuilderV3<
              TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>
          certificateBuilder_;

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       *
       * @return Whether the certificate field is set.
       */
      public boolean hasCertificate() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       *
       * @return The certificate.
       */
      public TLSCertificate getCertificate() {
        if (certificateBuilder_ == null) {
          return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
        } else {
          return certificateBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificate_ = value;
        } else {
          certificateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(TLSCertificate.Builder builderForValue) {
        if (certificateBuilder_ == null) {
          certificate_ = builderForValue.build();
        } else {
          certificateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder mergeCertificate(TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && certificate_ != null
              && certificate_ != TLSCertificate.getDefaultInstance()) {
            getCertificateBuilder().mergeFrom(value);
          } else {
            certificate_ = value;
          }
        } else {
          certificateBuilder_.mergeFrom(value);
        }
        if (certificate_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder clearCertificate() {
        bitField0_ = (bitField0_ & ~0x00000004);
        certificate_ = null;
        if (certificateBuilder_ != null) {
          certificateBuilder_.dispose();
          certificateBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public TLSCertificate.Builder getCertificateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getCertificateFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public TLSCertificateOrBuilder getCertificateOrBuilder() {
        if (certificateBuilder_ != null) {
          return certificateBuilder_.getMessageOrBuilder();
        } else {
          return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
        }
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>
          getCertificateFieldBuilder() {
        if (certificateBuilder_ == null) {
          certificateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>(
                  getCertificate(), getParentForChildren(), isClean());
          certificate_ = null;
        }
        return certificateBuilder_;
      }

      private long heartbeatIntervalSeconds_;

      /**
       *
       *
       * <pre>
       * The Agent MUST periodically send an AgentToServer message if the
       * AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
       * field MUST be set.
       *
       * An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
       *
       * A heartbeat is used to keep the connection active and inform the server that the Agent
       * is still alive and active.
       *
       * If this field has no value or is set to 0, the Agent should not send any heartbeats.
       * Status: [Development]
       * </pre>
       *
       * <code>uint64 heartbeat_interval_seconds = 4;</code>
       *
       * @return The heartbeatIntervalSeconds.
       */
      @Override
      public long getHeartbeatIntervalSeconds() {
        return heartbeatIntervalSeconds_;
      }

      /**
       *
       *
       * <pre>
       * The Agent MUST periodically send an AgentToServer message if the
       * AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
       * field MUST be set.
       *
       * An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
       *
       * A heartbeat is used to keep the connection active and inform the server that the Agent
       * is still alive and active.
       *
       * If this field has no value or is set to 0, the Agent should not send any heartbeats.
       * Status: [Development]
       * </pre>
       *
       * <code>uint64 heartbeat_interval_seconds = 4;</code>
       *
       * @param value The heartbeatIntervalSeconds to set.
       * @return This builder for chaining.
       */
      public Builder setHeartbeatIntervalSeconds(long value) {

        heartbeatIntervalSeconds_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent MUST periodically send an AgentToServer message if the
       * AgentCapabilities_ReportsHeartbeat capability is true. At a minimum the instance_uid
       * field MUST be set.
       *
       * An HTTP Client MUST use the value as polling interval, if heartbeat_interval_seconds is non-zero.
       *
       * A heartbeat is used to keep the connection active and inform the server that the Agent
       * is still alive and active.
       *
       * If this field has no value or is set to 0, the Agent should not send any heartbeats.
       * Status: [Development]
       * </pre>
       *
       * <code>uint64 heartbeat_interval_seconds = 4;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHeartbeatIntervalSeconds() {
        bitField0_ = (bitField0_ & ~0x00000008);
        heartbeatIntervalSeconds_ = 0L;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.OpAMPConnectionSettings)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.OpAMPConnectionSettings)
    private static final OpAMPConnectionSettings DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new OpAMPConnectionSettings();
    }

    public static OpAMPConnectionSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OpAMPConnectionSettings> PARSER =
        new com.google.protobuf.AbstractParser<OpAMPConnectionSettings>() {
          @Override
          public OpAMPConnectionSettings parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<OpAMPConnectionSettings> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<OpAMPConnectionSettings> getParserForType() {
      return PARSER;
    }

    @Override
    public OpAMPConnectionSettings getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface TelemetryConnectionSettingsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.TelemetryConnectionSettings)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The destinationEndpoint.
     */
    String getDestinationEndpoint();

    /**
     *
     *
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The bytes for destinationEndpoint.
     */
    com.google.protobuf.ByteString getDestinationEndpointBytes();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return The headers.
     */
    Headers getHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    HeadersOrBuilder getHeadersOrBuilder();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return Whether the certificate field is set.
     */
    boolean hasCertificate();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return The certificate.
     */
    TLSCertificate getCertificate();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    TLSCertificateOrBuilder getCertificateOrBuilder();
  }

  /**
   *
   *
   * <pre>
   * The TelemetryConnectionSettings message is a collection of fields which comprise an
   * offer from the Server to the Agent to use the specified settings for a network
   * connection to report own telemetry.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.TelemetryConnectionSettings}
   */
  public static final class TelemetryConnectionSettings
      extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.TelemetryConnectionSettings)
      TelemetryConnectionSettingsOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use TelemetryConnectionSettings.newBuilder() to construct.
    private TelemetryConnectionSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private TelemetryConnectionSettings() {
      destinationEndpoint_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new TelemetryConnectionSettings();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(TelemetryConnectionSettings.class, Builder.class);
    }

    private int bitField0_;
    public static final int DESTINATION_ENDPOINT_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object destinationEndpoint_ = "";

    /**
     *
     *
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The destinationEndpoint.
     */
    @Override
    public String getDestinationEndpoint() {
      Object ref = destinationEndpoint_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        destinationEndpoint_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The bytes for destinationEndpoint.
     */
    @Override
    public com.google.protobuf.ByteString getDestinationEndpointBytes() {
      Object ref = destinationEndpoint_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        destinationEndpoint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HEADERS_FIELD_NUMBER = 2;
    private Headers headers_;

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return Whether the headers field is set.
     */
    @Override
    public boolean hasHeaders() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return The headers.
     */
    @Override
    public Headers getHeaders() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    @Override
    public HeadersOrBuilder getHeadersOrBuilder() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    public static final int CERTIFICATE_FIELD_NUMBER = 3;
    private TLSCertificate certificate_;

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return Whether the certificate field is set.
     */
    @Override
    public boolean hasCertificate() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return The certificate.
     */
    @Override
    public TLSCertificate getCertificate() {
      return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
    }

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    @Override
    public TLSCertificateOrBuilder getCertificateOrBuilder() {
      return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, destinationEndpoint_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getHeaders());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getCertificate());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, destinationEndpoint_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getHeaders());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getCertificate());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof TelemetryConnectionSettings)) {
        return super.equals(obj);
      }
      TelemetryConnectionSettings other = (TelemetryConnectionSettings) obj;

      if (!getDestinationEndpoint().equals(other.getDestinationEndpoint())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders().equals(other.getHeaders())) return false;
      }
      if (hasCertificate() != other.hasCertificate()) return false;
      if (hasCertificate()) {
        if (!getCertificate().equals(other.getCertificate())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DESTINATION_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getDestinationEndpoint().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      if (hasCertificate()) {
        hash = (37 * hash) + CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getCertificate().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static TelemetryConnectionSettings parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static TelemetryConnectionSettings parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static TelemetryConnectionSettings parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static TelemetryConnectionSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static TelemetryConnectionSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static TelemetryConnectionSettings parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static TelemetryConnectionSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static TelemetryConnectionSettings parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static TelemetryConnectionSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static TelemetryConnectionSettings parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static TelemetryConnectionSettings parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static TelemetryConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(TelemetryConnectionSettings prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * The TelemetryConnectionSettings message is a collection of fields which comprise an
     * offer from the Server to the Agent to use the specified settings for a network
     * connection to report own telemetry.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.TelemetryConnectionSettings}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.TelemetryConnectionSettings)
        TelemetryConnectionSettingsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable
            .ensureFieldAccessorsInitialized(TelemetryConnectionSettings.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.TelemetryConnectionSettings.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getHeadersFieldBuilder();
          getCertificateFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        destinationEndpoint_ = "";
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        certificate_ = null;
        if (certificateBuilder_ != null) {
          certificateBuilder_.dispose();
          certificateBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
      }

      @Override
      public TelemetryConnectionSettings getDefaultInstanceForType() {
        return TelemetryConnectionSettings.getDefaultInstance();
      }

      @Override
      public TelemetryConnectionSettings build() {
        TelemetryConnectionSettings result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public TelemetryConnectionSettings buildPartial() {
        TelemetryConnectionSettings result = new TelemetryConnectionSettings(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(TelemetryConnectionSettings result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.destinationEndpoint_ = destinationEndpoint_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.headers_ = headersBuilder_ == null ? headers_ : headersBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.certificate_ =
              certificateBuilder_ == null ? certificate_ : certificateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof TelemetryConnectionSettings) {
          return mergeFrom((TelemetryConnectionSettings) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(TelemetryConnectionSettings other) {
        if (other == TelemetryConnectionSettings.getDefaultInstance()) return this;
        if (!other.getDestinationEndpoint().isEmpty()) {
          destinationEndpoint_ = other.destinationEndpoint_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        if (other.hasCertificate()) {
          mergeCertificate(other.getCertificate());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  destinationEndpoint_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  input.readMessage(getHeadersFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getCertificateFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object destinationEndpoint_ = "";

      /**
       *
       *
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return The destinationEndpoint.
       */
      public String getDestinationEndpoint() {
        Object ref = destinationEndpoint_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          destinationEndpoint_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return The bytes for destinationEndpoint.
       */
      public com.google.protobuf.ByteString getDestinationEndpointBytes() {
        Object ref = destinationEndpoint_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          destinationEndpoint_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @param value The destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpoint(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        destinationEndpoint_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearDestinationEndpoint() {
        destinationEndpoint_ = getDefaultInstance().getDestinationEndpoint();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @param value The bytes for destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpointBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        destinationEndpoint_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          headersBuilder_;

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       *
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       *
       * @return The headers.
       */
      public Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
        } else {
          headersBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder mergeHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)
              && headers_ != null
              && headers_ != Headers.getDefaultInstance()) {
            getHeadersBuilder().mergeFrom(value);
          } else {
            headers_ = value;
          }
        } else {
          headersBuilder_.mergeFrom(value);
        }
        if (headers_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder clearHeaders() {
        bitField0_ = (bitField0_ & ~0x00000002);
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Headers.Builder getHeadersBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  Headers, Headers.Builder, HeadersOrBuilder>(
                  getHeaders(), getParentForChildren(), isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      private TLSCertificate certificate_;
      private com.google.protobuf.SingleFieldBuilderV3<
              TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>
          certificateBuilder_;

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       *
       * @return Whether the certificate field is set.
       */
      public boolean hasCertificate() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       *
       * @return The certificate.
       */
      public TLSCertificate getCertificate() {
        if (certificateBuilder_ == null) {
          return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
        } else {
          return certificateBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificate_ = value;
        } else {
          certificateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(TLSCertificate.Builder builderForValue) {
        if (certificateBuilder_ == null) {
          certificate_ = builderForValue.build();
        } else {
          certificateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder mergeCertificate(TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && certificate_ != null
              && certificate_ != TLSCertificate.getDefaultInstance()) {
            getCertificateBuilder().mergeFrom(value);
          } else {
            certificate_ = value;
          }
        } else {
          certificateBuilder_.mergeFrom(value);
        }
        if (certificate_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder clearCertificate() {
        bitField0_ = (bitField0_ & ~0x00000004);
        certificate_ = null;
        if (certificateBuilder_ != null) {
          certificateBuilder_.dispose();
          certificateBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public TLSCertificate.Builder getCertificateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getCertificateFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public TLSCertificateOrBuilder getCertificateOrBuilder() {
        if (certificateBuilder_ != null) {
          return certificateBuilder_.getMessageOrBuilder();
        } else {
          return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
        }
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>
          getCertificateFieldBuilder() {
        if (certificateBuilder_ == null) {
          certificateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>(
                  getCertificate(), getParentForChildren(), isClean());
          certificate_ = null;
        }
        return certificateBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.TelemetryConnectionSettings)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.TelemetryConnectionSettings)
    private static final TelemetryConnectionSettings DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new TelemetryConnectionSettings();
    }

    public static TelemetryConnectionSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TelemetryConnectionSettings> PARSER =
        new com.google.protobuf.AbstractParser<TelemetryConnectionSettings>() {
          @Override
          public TelemetryConnectionSettings parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<TelemetryConnectionSettings> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<TelemetryConnectionSettings> getParserForType() {
      return PARSER;
    }

    @Override
    public TelemetryConnectionSettings getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface OtherConnectionSettingsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.OtherConnectionSettings)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The destinationEndpoint.
     */
    String getDestinationEndpoint();

    /**
     *
     *
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The bytes for destinationEndpoint.
     */
    com.google.protobuf.ByteString getDestinationEndpointBytes();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return The headers.
     */
    Headers getHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    HeadersOrBuilder getHeadersOrBuilder();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return Whether the certificate field is set.
     */
    boolean hasCertificate();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return The certificate.
     */
    TLSCertificate getCertificate();

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    TLSCertificateOrBuilder getCertificateOrBuilder();

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    int getOtherSettingsCount();

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    boolean containsOtherSettings(String key);

    /** Use {@link #getOtherSettingsMap()} instead. */
    @Deprecated
    java.util.Map<String, String> getOtherSettings();

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    java.util.Map<String, String> getOtherSettingsMap();

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    /* nullable */
    String getOtherSettingsOrDefault(
        String key,
        /* nullable */
        String defaultValue);

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    String getOtherSettingsOrThrow(String key);
  }

  /**
   *
   *
   * <pre>
   * The OtherConnectionSettings message is a collection of fields which comprise an
   * offer from the Server to the Agent to use the specified settings for a network
   * connection. It is not required that all fields in this message are specified.
   * The Server may specify only some of the fields, in which case it means that
   * the Server offers the Agent to change only those fields, while keeping the
   * rest of the fields unchanged.
   *
   * For example the Server may send a ConnectionSettings message with only the
   * certificate field set, while all other fields are unset. This means that
   * the Server wants the Agent to use a new certificate and continue sending to
   * the destination it is currently sending using the current header and other
   * settings.
   *
   * For fields which reference other messages the field is considered unset
   * when the reference is unset.
   *
   * For primitive field (string) we rely on the "flags" to describe that the
   * field is not set (this is done to overcome the limitation of old protoc
   * compilers don't generate methods that allow to check for the presence of
   * the field.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.OtherConnectionSettings}
   */
  public static final class OtherConnectionSettings extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.OtherConnectionSettings)
      OtherConnectionSettingsOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use OtherConnectionSettings.newBuilder() to construct.
    private OtherConnectionSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private OtherConnectionSettings() {
      destinationEndpoint_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new OtherConnectionSettings();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_OtherConnectionSettings_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 4:
          return internalGetOtherSettings();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(OtherConnectionSettings.class, Builder.class);
    }

    private int bitField0_;
    public static final int DESTINATION_ENDPOINT_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object destinationEndpoint_ = "";

    /**
     *
     *
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The destinationEndpoint.
     */
    @Override
    public String getDestinationEndpoint() {
      Object ref = destinationEndpoint_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        destinationEndpoint_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     *
     * @return The bytes for destinationEndpoint.
     */
    @Override
    public com.google.protobuf.ByteString getDestinationEndpointBytes() {
      Object ref = destinationEndpoint_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        destinationEndpoint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HEADERS_FIELD_NUMBER = 2;
    private Headers headers_;

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return Whether the headers field is set.
     */
    @Override
    public boolean hasHeaders() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     *
     * @return The headers.
     */
    @Override
    public Headers getHeaders() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    @Override
    public HeadersOrBuilder getHeadersOrBuilder() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    public static final int CERTIFICATE_FIELD_NUMBER = 3;
    private TLSCertificate certificate_;

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return Whether the certificate field is set.
     */
    @Override
    public boolean hasCertificate() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     *
     * @return The certificate.
     */
    @Override
    public TLSCertificate getCertificate() {
      return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
    }

    /**
     *
     *
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    @Override
    public TLSCertificateOrBuilder getCertificateOrBuilder() {
      return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
    }

    public static final int OTHER_SETTINGS_FIELD_NUMBER = 4;

    private static final class OtherSettingsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, String> defaultEntry =
          com.google.protobuf.MapEntry.<String, String>newDefaultInstance(
              Opamp
                  .internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.STRING,
              "");
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, String> otherSettings_;

    private com.google.protobuf.MapField<String, String> internalGetOtherSettings() {
      if (otherSettings_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OtherSettingsDefaultEntryHolder.defaultEntry);
      }
      return otherSettings_;
    }

    public int getOtherSettingsCount() {
      return internalGetOtherSettings().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @Override
    public boolean containsOtherSettings(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetOtherSettings().getMap().containsKey(key);
    }

    /** Use {@link #getOtherSettingsMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, String> getOtherSettings() {
      return getOtherSettingsMap();
    }

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @Override
    public java.util.Map<String, String> getOtherSettingsMap() {
      return internalGetOtherSettings().getMap();
    }

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @Override
    public /* nullable */ String getOtherSettingsOrDefault(
        String key,
        /* nullable */
        String defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, String> map = internalGetOtherSettings().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @Override
    public String getOtherSettingsOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, String> map = internalGetOtherSettings().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, destinationEndpoint_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getHeaders());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getCertificate());
      }
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetOtherSettings(), OtherSettingsDefaultEntryHolder.defaultEntry, 4);
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, destinationEndpoint_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getHeaders());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getCertificate());
      }
      for (java.util.Map.Entry<String, String> entry :
          internalGetOtherSettings().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, String> otherSettings__ =
            OtherSettingsDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, otherSettings__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof OtherConnectionSettings)) {
        return super.equals(obj);
      }
      OtherConnectionSettings other = (OtherConnectionSettings) obj;

      if (!getDestinationEndpoint().equals(other.getDestinationEndpoint())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders().equals(other.getHeaders())) return false;
      }
      if (hasCertificate() != other.hasCertificate()) return false;
      if (hasCertificate()) {
        if (!getCertificate().equals(other.getCertificate())) return false;
      }
      if (!internalGetOtherSettings().equals(other.internalGetOtherSettings())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DESTINATION_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getDestinationEndpoint().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      if (hasCertificate()) {
        hash = (37 * hash) + CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getCertificate().hashCode();
      }
      if (!internalGetOtherSettings().getMap().isEmpty()) {
        hash = (37 * hash) + OTHER_SETTINGS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOtherSettings().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static OtherConnectionSettings parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OtherConnectionSettings parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OtherConnectionSettings parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OtherConnectionSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OtherConnectionSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static OtherConnectionSettings parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static OtherConnectionSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static OtherConnectionSettings parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static OtherConnectionSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static OtherConnectionSettings parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static OtherConnectionSettings parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static OtherConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(OtherConnectionSettings prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * The OtherConnectionSettings message is a collection of fields which comprise an
     * offer from the Server to the Agent to use the specified settings for a network
     * connection. It is not required that all fields in this message are specified.
     * The Server may specify only some of the fields, in which case it means that
     * the Server offers the Agent to change only those fields, while keeping the
     * rest of the fields unchanged.
     *
     * For example the Server may send a ConnectionSettings message with only the
     * certificate field set, while all other fields are unset. This means that
     * the Server wants the Agent to use a new certificate and continue sending to
     * the destination it is currently sending using the current header and other
     * settings.
     *
     * For fields which reference other messages the field is considered unset
     * when the reference is unset.
     *
     * For primitive field (string) we rely on the "flags" to describe that the
     * field is not set (this is done to overcome the limitation of old protoc
     * compilers don't generate methods that allow to check for the presence of
     * the field.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.OtherConnectionSettings}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.OtherConnectionSettings)
        OtherConnectionSettingsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_OtherConnectionSettings_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 4:
            return internalGetOtherSettings();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 4:
            return internalGetMutableOtherSettings();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable
            .ensureFieldAccessorsInitialized(OtherConnectionSettings.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.OtherConnectionSettings.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getHeadersFieldBuilder();
          getCertificateFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        destinationEndpoint_ = "";
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        certificate_ = null;
        if (certificateBuilder_ != null) {
          certificateBuilder_.dispose();
          certificateBuilder_ = null;
        }
        internalGetMutableOtherSettings().clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_OtherConnectionSettings_descriptor;
      }

      @Override
      public OtherConnectionSettings getDefaultInstanceForType() {
        return OtherConnectionSettings.getDefaultInstance();
      }

      @Override
      public OtherConnectionSettings build() {
        OtherConnectionSettings result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public OtherConnectionSettings buildPartial() {
        OtherConnectionSettings result = new OtherConnectionSettings(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(OtherConnectionSettings result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.destinationEndpoint_ = destinationEndpoint_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.headers_ = headersBuilder_ == null ? headers_ : headersBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.certificate_ =
              certificateBuilder_ == null ? certificate_ : certificateBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.otherSettings_ = internalGetOtherSettings();
          result.otherSettings_.makeImmutable();
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof OtherConnectionSettings) {
          return mergeFrom((OtherConnectionSettings) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(OtherConnectionSettings other) {
        if (other == OtherConnectionSettings.getDefaultInstance()) return this;
        if (!other.getDestinationEndpoint().isEmpty()) {
          destinationEndpoint_ = other.destinationEndpoint_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        if (other.hasCertificate()) {
          mergeCertificate(other.getCertificate());
        }
        internalGetMutableOtherSettings().mergeFrom(other.internalGetOtherSettings());
        bitField0_ |= 0x00000008;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  destinationEndpoint_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  input.readMessage(getHeadersFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getCertificateFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  com.google.protobuf.MapEntry<String, String> otherSettings__ =
                      input.readMessage(
                          OtherSettingsDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutableOtherSettings()
                      .getMutableMap()
                      .put(otherSettings__.getKey(), otherSettings__.getValue());
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object destinationEndpoint_ = "";

      /**
       *
       *
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return The destinationEndpoint.
       */
      public String getDestinationEndpoint() {
        Object ref = destinationEndpoint_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          destinationEndpoint_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return The bytes for destinationEndpoint.
       */
      public com.google.protobuf.ByteString getDestinationEndpointBytes() {
        Object ref = destinationEndpoint_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          destinationEndpoint_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @param value The destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpoint(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        destinationEndpoint_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearDestinationEndpoint() {
        destinationEndpoint_ = getDefaultInstance().getDestinationEndpoint();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       *
       * @param value The bytes for destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpointBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        destinationEndpoint_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          headersBuilder_;

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       *
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       *
       * @return The headers.
       */
      public Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
        } else {
          headersBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder mergeHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)
              && headers_ != null
              && headers_ != Headers.getDefaultInstance()) {
            getHeadersBuilder().mergeFrom(value);
          } else {
            headers_ = value;
          }
        } else {
          headersBuilder_.mergeFrom(value);
        }
        if (headers_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder clearHeaders() {
        bitField0_ = (bitField0_ & ~0x00000002);
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Headers.Builder getHeadersBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  Headers, Headers.Builder, HeadersOrBuilder>(
                  getHeaders(), getParentForChildren(), isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      private TLSCertificate certificate_;
      private com.google.protobuf.SingleFieldBuilderV3<
              TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>
          certificateBuilder_;

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       *
       * @return Whether the certificate field is set.
       */
      public boolean hasCertificate() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       *
       * @return The certificate.
       */
      public TLSCertificate getCertificate() {
        if (certificateBuilder_ == null) {
          return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
        } else {
          return certificateBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificate_ = value;
        } else {
          certificateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(TLSCertificate.Builder builderForValue) {
        if (certificateBuilder_ == null) {
          certificate_ = builderForValue.build();
        } else {
          certificateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder mergeCertificate(TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && certificate_ != null
              && certificate_ != TLSCertificate.getDefaultInstance()) {
            getCertificateBuilder().mergeFrom(value);
          } else {
            certificate_ = value;
          }
        } else {
          certificateBuilder_.mergeFrom(value);
        }
        if (certificate_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder clearCertificate() {
        bitField0_ = (bitField0_ & ~0x00000004);
        certificate_ = null;
        if (certificateBuilder_ != null) {
          certificateBuilder_.dispose();
          certificateBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public TLSCertificate.Builder getCertificateBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getCertificateFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public TLSCertificateOrBuilder getCertificateOrBuilder() {
        if (certificateBuilder_ != null) {
          return certificateBuilder_.getMessageOrBuilder();
        } else {
          return certificate_ == null ? TLSCertificate.getDefaultInstance() : certificate_;
        }
      }

      /**
       *
       *
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>
          getCertificateFieldBuilder() {
        if (certificateBuilder_ == null) {
          certificateBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  TLSCertificate, TLSCertificate.Builder, TLSCertificateOrBuilder>(
                  getCertificate(), getParentForChildren(), isClean());
          certificate_ = null;
        }
        return certificateBuilder_;
      }

      private com.google.protobuf.MapField<String, String> otherSettings_;

      private com.google.protobuf.MapField<String, String> internalGetOtherSettings() {
        if (otherSettings_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              OtherSettingsDefaultEntryHolder.defaultEntry);
        }
        return otherSettings_;
      }

      private com.google.protobuf.MapField<String, String> internalGetMutableOtherSettings() {
        if (otherSettings_ == null) {
          otherSettings_ =
              com.google.protobuf.MapField.newMapField(
                  OtherSettingsDefaultEntryHolder.defaultEntry);
        }
        if (!otherSettings_.isMutable()) {
          otherSettings_ = otherSettings_.copy();
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return otherSettings_;
      }

      public int getOtherSettingsCount() {
        return internalGetOtherSettings().getMap().size();
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @Override
      public boolean containsOtherSettings(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetOtherSettings().getMap().containsKey(key);
      }

      /** Use {@link #getOtherSettingsMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, String> getOtherSettings() {
        return getOtherSettingsMap();
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @Override
      public java.util.Map<String, String> getOtherSettingsMap() {
        return internalGetOtherSettings().getMap();
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @Override
      public /* nullable */ String getOtherSettingsOrDefault(
          String key,
          /* nullable */
          String defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, String> map = internalGetOtherSettings().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @Override
      public String getOtherSettingsOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, String> map = internalGetOtherSettings().getMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearOtherSettings() {
        bitField0_ = (bitField0_ & ~0x00000008);
        internalGetMutableOtherSettings().getMutableMap().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      public Builder removeOtherSettings(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutableOtherSettings().getMutableMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, String> getMutableOtherSettings() {
        bitField0_ |= 0x00000008;
        return internalGetMutableOtherSettings().getMutableMap();
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      public Builder putOtherSettings(String key, String value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutableOtherSettings().getMutableMap().put(key, value);
        bitField0_ |= 0x00000008;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      public Builder putAllOtherSettings(java.util.Map<String, String> values) {
        internalGetMutableOtherSettings().getMutableMap().putAll(values);
        bitField0_ |= 0x00000008;
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.OtherConnectionSettings)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.OtherConnectionSettings)
    private static final OtherConnectionSettings DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new OtherConnectionSettings();
    }

    public static OtherConnectionSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OtherConnectionSettings> PARSER =
        new com.google.protobuf.AbstractParser<OtherConnectionSettings>() {
          @Override
          public OtherConnectionSettings parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<OtherConnectionSettings> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<OtherConnectionSettings> getParserForType() {
      return PARSER;
    }

    @Override
    public OtherConnectionSettings getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface HeadersOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.Headers)
      com.google.protobuf.MessageOrBuilder {

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    java.util.List<Header> getHeadersList();

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    Header getHeaders(int index);

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    int getHeadersCount();

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    java.util.List<? extends HeaderOrBuilder> getHeadersOrBuilderList();

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    HeaderOrBuilder getHeadersOrBuilder(int index);
  }

  /**
   *
   *
   * <pre>
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.Headers}
   */
  public static final class Headers extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.Headers)
      HeadersOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use Headers.newBuilder() to construct.
    private Headers(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private Headers() {
      headers_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new Headers();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_Headers_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_Headers_fieldAccessorTable
          .ensureFieldAccessorsInitialized(Headers.class, Builder.class);
    }

    public static final int HEADERS_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private java.util.List<Header> headers_;

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    @Override
    public java.util.List<Header> getHeadersList() {
      return headers_;
    }

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    @Override
    public java.util.List<? extends HeaderOrBuilder> getHeadersOrBuilderList() {
      return headers_;
    }

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    @Override
    public int getHeadersCount() {
      return headers_.size();
    }

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    @Override
    public Header getHeaders(int index) {
      return headers_.get(index);
    }

    /** <code>repeated .opamp.proto.Header headers = 1;</code> */
    @Override
    public HeaderOrBuilder getHeadersOrBuilder(int index) {
      return headers_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < headers_.size(); i++) {
        output.writeMessage(1, headers_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < headers_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, headers_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof Headers)) {
        return super.equals(obj);
      }
      Headers other = (Headers) obj;

      if (!getHeadersList().equals(other.getHeadersList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getHeadersCount() > 0) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeadersList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Headers parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static Headers parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static Headers parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static Headers parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static Headers parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static Headers parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static Headers parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static Headers parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static Headers parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static Headers parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static Headers parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static Headers parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(Headers prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.Headers}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.Headers)
        HeadersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_Headers_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_Headers_fieldAccessorTable
            .ensureFieldAccessorsInitialized(Headers.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.Headers.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (headersBuilder_ == null) {
          headers_ = java.util.Collections.emptyList();
        } else {
          headers_ = null;
          headersBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_Headers_descriptor;
      }

      @Override
      public Headers getDefaultInstanceForType() {
        return Headers.getDefaultInstance();
      }

      @Override
      public Headers build() {
        Headers result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public Headers buildPartial() {
        Headers result = new Headers(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Headers result) {
        if (headersBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            headers_ = java.util.Collections.unmodifiableList(headers_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.headers_ = headers_;
        } else {
          result.headers_ = headersBuilder_.build();
        }
      }

      private void buildPartial0(Headers result) {
        int from_bitField0_ = bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Headers) {
          return mergeFrom((Headers) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Headers other) {
        if (other == Headers.getDefaultInstance()) return this;
        if (headersBuilder_ == null) {
          if (!other.headers_.isEmpty()) {
            if (headers_.isEmpty()) {
              headers_ = other.headers_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureHeadersIsMutable();
              headers_.addAll(other.headers_);
            }
            onChanged();
          }
        } else {
          if (!other.headers_.isEmpty()) {
            if (headersBuilder_.isEmpty()) {
              headersBuilder_.dispose();
              headersBuilder_ = null;
              headers_ = other.headers_;
              bitField0_ = (bitField0_ & ~0x00000001);
              headersBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getHeadersFieldBuilder()
                      : null;
            } else {
              headersBuilder_.addAllMessages(other.headers_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  Header m = input.readMessage(Header.parser(), extensionRegistry);
                  if (headersBuilder_ == null) {
                    ensureHeadersIsMutable();
                    headers_.add(m);
                  } else {
                    headersBuilder_.addMessage(m);
                  }
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private java.util.List<Header> headers_ = java.util.Collections.emptyList();

      private void ensureHeadersIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          headers_ = new java.util.ArrayList<Header>(headers_);
          bitField0_ |= 0x00000001;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<Header, Header.Builder, HeaderOrBuilder>
          headersBuilder_;

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public java.util.List<Header> getHeadersList() {
        if (headersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(headers_);
        } else {
          return headersBuilder_.getMessageList();
        }
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public int getHeadersCount() {
        if (headersBuilder_ == null) {
          return headers_.size();
        } else {
          return headersBuilder_.getCount();
        }
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Header getHeaders(int index) {
        if (headersBuilder_ == null) {
          return headers_.get(index);
        } else {
          return headersBuilder_.getMessage(index);
        }
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder setHeaders(int index, Header value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHeadersIsMutable();
          headers_.set(index, value);
          onChanged();
        } else {
          headersBuilder_.setMessage(index, value);
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder setHeaders(int index, Header.Builder builderForValue) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.set(index, builderForValue.build());
          onChanged();
        } else {
          headersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder addHeaders(Header value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHeadersIsMutable();
          headers_.add(value);
          onChanged();
        } else {
          headersBuilder_.addMessage(value);
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder addHeaders(int index, Header value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHeadersIsMutable();
          headers_.add(index, value);
          onChanged();
        } else {
          headersBuilder_.addMessage(index, value);
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder addHeaders(Header.Builder builderForValue) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.add(builderForValue.build());
          onChanged();
        } else {
          headersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder addHeaders(int index, Header.Builder builderForValue) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.add(index, builderForValue.build());
          onChanged();
        } else {
          headersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder addAllHeaders(Iterable<? extends Header> values) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, headers_);
          onChanged();
        } else {
          headersBuilder_.addAllMessages(values);
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder clearHeaders() {
        if (headersBuilder_ == null) {
          headers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          headersBuilder_.clear();
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Builder removeHeaders(int index) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.remove(index);
          onChanged();
        } else {
          headersBuilder_.remove(index);
        }
        return this;
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Header.Builder getHeadersBuilder(int index) {
        return getHeadersFieldBuilder().getBuilder(index);
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public HeaderOrBuilder getHeadersOrBuilder(int index) {
        if (headersBuilder_ == null) {
          return headers_.get(index);
        } else {
          return headersBuilder_.getMessageOrBuilder(index);
        }
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public java.util.List<? extends HeaderOrBuilder> getHeadersOrBuilderList() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(headers_);
        }
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Header.Builder addHeadersBuilder() {
        return getHeadersFieldBuilder().addBuilder(Header.getDefaultInstance());
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public Header.Builder addHeadersBuilder(int index) {
        return getHeadersFieldBuilder().addBuilder(index, Header.getDefaultInstance());
      }

      /** <code>repeated .opamp.proto.Header headers = 1;</code> */
      public java.util.List<Header.Builder> getHeadersBuilderList() {
        return getHeadersFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<Header, Header.Builder, HeaderOrBuilder>
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  Header, Header.Builder, HeaderOrBuilder>(
                  headers_, ((bitField0_ & 0x00000001) != 0), getParentForChildren(), isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.Headers)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.Headers)
    private static final Headers DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new Headers();
    }

    public static Headers getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Headers> PARSER =
        new com.google.protobuf.AbstractParser<Headers>() {
          @Override
          public Headers parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<Headers> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Headers> getParserForType() {
      return PARSER;
    }

    @Override
    public Headers getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface HeaderOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.Header)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string key = 1;</code>
     *
     * @return The key.
     */
    String getKey();

    /**
     * <code>string key = 1;</code>
     *
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString getKeyBytes();

    /**
     * <code>string value = 2;</code>
     *
     * @return The value.
     */
    String getValue();

    /**
     * <code>string value = 2;</code>
     *
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString getValueBytes();
  }

  /**
   *
   *
   * <pre>
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.Header}
   */
  public static final class Header extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.Header)
      HeaderOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use Header.newBuilder() to construct.
    private Header(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private Header() {
      key_ = "";
      value_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new Header();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_Header_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_Header_fieldAccessorTable
          .ensureFieldAccessorsInitialized(Header.class, Builder.class);
    }

    public static final int KEY_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object key_ = "";

    /**
     * <code>string key = 1;</code>
     *
     * @return The key.
     */
    @Override
    public String getKey() {
      Object ref = key_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        key_ = s;
        return s;
      }
    }

    /**
     * <code>string key = 1;</code>
     *
     * @return The bytes for key.
     */
    @Override
    public com.google.protobuf.ByteString getKeyBytes() {
      Object ref = key_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private volatile Object value_ = "";

    /**
     * <code>string value = 2;</code>
     *
     * @return The value.
     */
    @Override
    public String getValue() {
      Object ref = value_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        value_ = s;
        return s;
      }
    }

    /**
     * <code>string value = 2;</code>
     *
     * @return The bytes for value.
     */
    @Override
    public com.google.protobuf.ByteString getValueBytes() {
      Object ref = value_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        value_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(key_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(value_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(key_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(value_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof Header)) {
        return super.equals(obj);
      }
      Header other = (Header) obj;

      if (!getKey().equals(other.getKey())) return false;
      if (!getValue().equals(other.getValue())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + KEY_FIELD_NUMBER;
      hash = (53 * hash) + getKey().hashCode();
      hash = (37 * hash) + VALUE_FIELD_NUMBER;
      hash = (53 * hash) + getValue().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Header parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static Header parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static Header parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static Header parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static Header parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static Header parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static Header parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static Header parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static Header parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static Header parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static Header parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static Header parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(Header prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.Header}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.Header)
        HeaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_Header_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_Header_fieldAccessorTable
            .ensureFieldAccessorsInitialized(Header.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.Header.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = "";
        value_ = "";
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_Header_descriptor;
      }

      @Override
      public Header getDefaultInstanceForType() {
        return Header.getDefaultInstance();
      }

      @Override
      public Header build() {
        Header result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public Header buildPartial() {
        Header result = new Header(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(Header result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = key_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.value_ = value_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Header) {
          return mergeFrom((Header) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Header other) {
        if (other == Header.getDefaultInstance()) return this;
        if (!other.getKey().isEmpty()) {
          key_ = other.key_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getValue().isEmpty()) {
          value_ = other.value_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  key_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  value_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object key_ = "";

      /**
       * <code>string key = 1;</code>
       *
       * @return The key.
       */
      public String getKey() {
        Object ref = key_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          key_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       * <code>string key = 1;</code>
       *
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString getKeyBytes() {
        Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <code>string key = 1;</code>
       *
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       * <code>string key = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       * <code>string key = 1;</code>
       *
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Object value_ = "";

      /**
       * <code>string value = 2;</code>
       *
       * @return The value.
       */
      public String getValue() {
        Object ref = value_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          value_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       * <code>string value = 2;</code>
       *
       * @return The bytes for value.
       */
      public com.google.protobuf.ByteString getValueBytes() {
        Object ref = value_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       * <code>string value = 2;</code>
       *
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       * <code>string value = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        value_ = getDefaultInstance().getValue();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      /**
       * <code>string value = 2;</code>
       *
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.Header)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.Header)
    private static final Header DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new Header();
    }

    public static Header getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Header> PARSER =
        new com.google.protobuf.AbstractParser<Header>() {
          @Override
          public Header parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<Header> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Header> getParserForType() {
      return PARSER;
    }

    @Override
    public Header getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface TLSCertificateOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.TLSCertificate)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * PEM-encoded certificate. Required.
     * </pre>
     *
     * <code>bytes cert = 1;</code>
     *
     * @return The cert.
     */
    com.google.protobuf.ByteString getCert();

    /**
     *
     *
     * <pre>
     * PEM-encoded private key of the certificate. Required.
     * </pre>
     *
     * <code>bytes private_key = 2;</code>
     *
     * @return The privateKey.
     */
    com.google.protobuf.ByteString getPrivateKey();

    /**
     *
     *
     * <pre>
     * PEM-encoded certificate of the signing CA.
     * Optional. MUST be specified if the certificate is CA-signed.
     * Can be stored by TLS-terminating intermediary proxies in order to verify
     * the connecting client's certificate in the future.
     * It is not recommended that the Agent accepts this CA as an authority for
     * any purposes.
     * </pre>
     *
     * <code>bytes ca_cert = 3;</code>
     *
     * @return The caCert.
     */
    com.google.protobuf.ByteString getCaCert();
  }

  /**
   *
   *
   * <pre>
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.TLSCertificate}
   */
  public static final class TLSCertificate extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.TLSCertificate)
      TLSCertificateOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use TLSCertificate.newBuilder() to construct.
    private TLSCertificate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private TLSCertificate() {
      cert_ = com.google.protobuf.ByteString.EMPTY;
      privateKey_ = com.google.protobuf.ByteString.EMPTY;
      caCert_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new TLSCertificate();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_TLSCertificate_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_TLSCertificate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(TLSCertificate.class, Builder.class);
    }

    public static final int CERT_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString cert_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * PEM-encoded certificate. Required.
     * </pre>
     *
     * <code>bytes cert = 1;</code>
     *
     * @return The cert.
     */
    @Override
    public com.google.protobuf.ByteString getCert() {
      return cert_;
    }

    public static final int PRIVATE_KEY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * PEM-encoded private key of the certificate. Required.
     * </pre>
     *
     * <code>bytes private_key = 2;</code>
     *
     * @return The privateKey.
     */
    @Override
    public com.google.protobuf.ByteString getPrivateKey() {
      return privateKey_;
    }

    public static final int CA_CERT_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString caCert_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * PEM-encoded certificate of the signing CA.
     * Optional. MUST be specified if the certificate is CA-signed.
     * Can be stored by TLS-terminating intermediary proxies in order to verify
     * the connecting client's certificate in the future.
     * It is not recommended that the Agent accepts this CA as an authority for
     * any purposes.
     * </pre>
     *
     * <code>bytes ca_cert = 3;</code>
     *
     * @return The caCert.
     */
    @Override
    public com.google.protobuf.ByteString getCaCert() {
      return caCert_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!cert_.isEmpty()) {
        output.writeBytes(1, cert_);
      }
      if (!privateKey_.isEmpty()) {
        output.writeBytes(2, privateKey_);
      }
      if (!caCert_.isEmpty()) {
        output.writeBytes(3, caCert_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!cert_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, cert_);
      }
      if (!privateKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, privateKey_);
      }
      if (!caCert_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, caCert_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof TLSCertificate)) {
        return super.equals(obj);
      }
      TLSCertificate other = (TLSCertificate) obj;

      if (!getCert().equals(other.getCert())) return false;
      if (!getPrivateKey().equals(other.getPrivateKey())) return false;
      if (!getCaCert().equals(other.getCaCert())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CERT_FIELD_NUMBER;
      hash = (53 * hash) + getCert().hashCode();
      hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getPrivateKey().hashCode();
      hash = (37 * hash) + CA_CERT_FIELD_NUMBER;
      hash = (53 * hash) + getCaCert().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static TLSCertificate parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static TLSCertificate parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static TLSCertificate parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static TLSCertificate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static TLSCertificate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static TLSCertificate parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static TLSCertificate parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static TLSCertificate parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static TLSCertificate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static TLSCertificate parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static TLSCertificate parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static TLSCertificate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(TLSCertificate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.TLSCertificate}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.TLSCertificate)
        TLSCertificateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_TLSCertificate_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_TLSCertificate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(TLSCertificate.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.TLSCertificate.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        cert_ = com.google.protobuf.ByteString.EMPTY;
        privateKey_ = com.google.protobuf.ByteString.EMPTY;
        caCert_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_TLSCertificate_descriptor;
      }

      @Override
      public TLSCertificate getDefaultInstanceForType() {
        return TLSCertificate.getDefaultInstance();
      }

      @Override
      public TLSCertificate build() {
        TLSCertificate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public TLSCertificate buildPartial() {
        TLSCertificate result = new TLSCertificate(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(TLSCertificate result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.cert_ = cert_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.privateKey_ = privateKey_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.caCert_ = caCert_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof TLSCertificate) {
          return mergeFrom((TLSCertificate) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(TLSCertificate other) {
        if (other == TLSCertificate.getDefaultInstance()) return this;
        if (other.getCert() != com.google.protobuf.ByteString.EMPTY) {
          setCert(other.getCert());
        }
        if (other.getPrivateKey() != com.google.protobuf.ByteString.EMPTY) {
          setPrivateKey(other.getPrivateKey());
        }
        if (other.getCaCert() != com.google.protobuf.ByteString.EMPTY) {
          setCaCert(other.getCaCert());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  cert_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  privateKey_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  caCert_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString cert_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * PEM-encoded certificate. Required.
       * </pre>
       *
       * <code>bytes cert = 1;</code>
       *
       * @return The cert.
       */
      @Override
      public com.google.protobuf.ByteString getCert() {
        return cert_;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded certificate. Required.
       * </pre>
       *
       * <code>bytes cert = 1;</code>
       *
       * @param value The cert to set.
       * @return This builder for chaining.
       */
      public Builder setCert(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        cert_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded certificate. Required.
       * </pre>
       *
       * <code>bytes cert = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCert() {
        bitField0_ = (bitField0_ & ~0x00000001);
        cert_ = getDefaultInstance().getCert();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * PEM-encoded private key of the certificate. Required.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       *
       * @return The privateKey.
       */
      @Override
      public com.google.protobuf.ByteString getPrivateKey() {
        return privateKey_;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded private key of the certificate. Required.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       *
       * @param value The privateKey to set.
       * @return This builder for chaining.
       */
      public Builder setPrivateKey(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        privateKey_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded private key of the certificate. Required.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearPrivateKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        privateKey_ = getDefaultInstance().getPrivateKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString caCert_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * PEM-encoded certificate of the signing CA.
       * Optional. MUST be specified if the certificate is CA-signed.
       * Can be stored by TLS-terminating intermediary proxies in order to verify
       * the connecting client's certificate in the future.
       * It is not recommended that the Agent accepts this CA as an authority for
       * any purposes.
       * </pre>
       *
       * <code>bytes ca_cert = 3;</code>
       *
       * @return The caCert.
       */
      @Override
      public com.google.protobuf.ByteString getCaCert() {
        return caCert_;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded certificate of the signing CA.
       * Optional. MUST be specified if the certificate is CA-signed.
       * Can be stored by TLS-terminating intermediary proxies in order to verify
       * the connecting client's certificate in the future.
       * It is not recommended that the Agent accepts this CA as an authority for
       * any purposes.
       * </pre>
       *
       * <code>bytes ca_cert = 3;</code>
       *
       * @param value The caCert to set.
       * @return This builder for chaining.
       */
      public Builder setCaCert(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        caCert_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * PEM-encoded certificate of the signing CA.
       * Optional. MUST be specified if the certificate is CA-signed.
       * Can be stored by TLS-terminating intermediary proxies in order to verify
       * the connecting client's certificate in the future.
       * It is not recommended that the Agent accepts this CA as an authority for
       * any purposes.
       * </pre>
       *
       * <code>bytes ca_cert = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCaCert() {
        bitField0_ = (bitField0_ & ~0x00000004);
        caCert_ = getDefaultInstance().getCaCert();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.TLSCertificate)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.TLSCertificate)
    private static final TLSCertificate DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new TLSCertificate();
    }

    public static TLSCertificate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TLSCertificate> PARSER =
        new com.google.protobuf.AbstractParser<TLSCertificate>() {
          @Override
          public TLSCertificate parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<TLSCertificate> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<TLSCertificate> getParserForType() {
      return PARSER;
    }

    @Override
    public TLSCertificate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ConnectionSettingsOffersOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ConnectionSettingsOffers)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Hash of all settings, including settings that may be omitted from this message
     * because they are unchanged.
     * </pre>
     *
     * <code>bytes hash = 1;</code>
     *
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();

    /**
     *
     *
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     *
     * @return Whether the opamp field is set.
     */
    boolean hasOpamp();

    /**
     *
     *
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     *
     * @return The opamp.
     */
    OpAMPConnectionSettings getOpamp();

    /**
     *
     *
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     */
    OpAMPConnectionSettingsOrBuilder getOpampOrBuilder();

    /**
     *
     *
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     *
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     *
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     *
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     *
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     *
     * @return Whether the ownMetrics field is set.
     */
    boolean hasOwnMetrics();

    /**
     *
     *
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     *
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     *
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     *
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     *
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     *
     * @return The ownMetrics.
     */
    TelemetryConnectionSettings getOwnMetrics();

    /**
     *
     *
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     *
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     *
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     *
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     *
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     */
    TelemetryConnectionSettingsOrBuilder getOwnMetricsOrBuilder();

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     *
     * @return Whether the ownTraces field is set.
     */
    boolean hasOwnTraces();

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     *
     * @return The ownTraces.
     */
    TelemetryConnectionSettings getOwnTraces();

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     */
    TelemetryConnectionSettingsOrBuilder getOwnTracesOrBuilder();

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     *
     * @return Whether the ownLogs field is set.
     */
    boolean hasOwnLogs();

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     *
     * @return The ownLogs.
     */
    TelemetryConnectionSettings getOwnLogs();

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     */
    TelemetryConnectionSettingsOrBuilder getOwnLogsOrBuilder();

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    int getOtherConnectionsCount();

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    boolean containsOtherConnections(String key);

    /** Use {@link #getOtherConnectionsMap()} instead. */
    @Deprecated
    java.util.Map<String, OtherConnectionSettings> getOtherConnections();

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    java.util.Map<String, OtherConnectionSettings> getOtherConnectionsMap();

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    /* nullable */
    OtherConnectionSettings getOtherConnectionsOrDefault(
        String key,
        /* nullable */
        OtherConnectionSettings defaultValue);

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    OtherConnectionSettings getOtherConnectionsOrThrow(String key);
  }

  /**
   *
   *
   * <pre>
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.ConnectionSettingsOffers}
   */
  public static final class ConnectionSettingsOffers extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ConnectionSettingsOffers)
      ConnectionSettingsOffersOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ConnectionSettingsOffers.newBuilder() to construct.
    private ConnectionSettingsOffers(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ConnectionSettingsOffers() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ConnectionSettingsOffers();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 6:
          return internalGetOtherConnections();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ConnectionSettingsOffers.class, Builder.class);
    }

    private int bitField0_;
    public static final int HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Hash of all settings, including settings that may be omitted from this message
     * because they are unchanged.
     * </pre>
     *
     * <code>bytes hash = 1;</code>
     *
     * @return The hash.
     */
    @Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    public static final int OPAMP_FIELD_NUMBER = 2;
    private OpAMPConnectionSettings opamp_;

    /**
     *
     *
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     *
     * @return Whether the opamp field is set.
     */
    @Override
    public boolean hasOpamp() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     *
     * @return The opamp.
     */
    @Override
    public OpAMPConnectionSettings getOpamp() {
      return opamp_ == null ? OpAMPConnectionSettings.getDefaultInstance() : opamp_;
    }

    /**
     *
     *
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     */
    @Override
    public OpAMPConnectionSettingsOrBuilder getOpampOrBuilder() {
      return opamp_ == null ? OpAMPConnectionSettings.getDefaultInstance() : opamp_;
    }

    public static final int OWN_METRICS_FIELD_NUMBER = 3;
    private TelemetryConnectionSettings ownMetrics_;

    /**
     *
     *
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     *
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     *
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     *
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     *
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     *
     * @return Whether the ownMetrics field is set.
     */
    @Override
    public boolean hasOwnMetrics() {
      return ((bitField0_ & 0x00000002) != 0);
    }

    /**
     *
     *
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     *
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     *
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     *
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     *
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     *
     * @return The ownMetrics.
     */
    @Override
    public TelemetryConnectionSettings getOwnMetrics() {
      return ownMetrics_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownMetrics_;
    }

    /**
     *
     *
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     *
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     *
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     *
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     *
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     */
    @Override
    public TelemetryConnectionSettingsOrBuilder getOwnMetricsOrBuilder() {
      return ownMetrics_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownMetrics_;
    }

    public static final int OWN_TRACES_FIELD_NUMBER = 4;
    private TelemetryConnectionSettings ownTraces_;

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     *
     * @return Whether the ownTraces field is set.
     */
    @Override
    public boolean hasOwnTraces() {
      return ((bitField0_ & 0x00000004) != 0);
    }

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     *
     * @return The ownTraces.
     */
    @Override
    public TelemetryConnectionSettings getOwnTraces() {
      return ownTraces_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
    }

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     */
    @Override
    public TelemetryConnectionSettingsOrBuilder getOwnTracesOrBuilder() {
      return ownTraces_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
    }

    public static final int OWN_LOGS_FIELD_NUMBER = 5;
    private TelemetryConnectionSettings ownLogs_;

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     *
     * @return Whether the ownLogs field is set.
     */
    @Override
    public boolean hasOwnLogs() {
      return ((bitField0_ & 0x00000008) != 0);
    }

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     *
     * @return The ownLogs.
     */
    @Override
    public TelemetryConnectionSettings getOwnLogs() {
      return ownLogs_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
    }

    /**
     *
     *
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     */
    @Override
    public TelemetryConnectionSettingsOrBuilder getOwnLogsOrBuilder() {
      return ownLogs_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
    }

    public static final int OTHER_CONNECTIONS_FIELD_NUMBER = 6;

    private static final class OtherConnectionsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, OtherConnectionSettings> defaultEntry =
          com.google.protobuf.MapEntry.<String, OtherConnectionSettings>newDefaultInstance(
              Opamp
                  .internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              OtherConnectionSettings.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, OtherConnectionSettings> otherConnections_;

    private com.google.protobuf.MapField<String, OtherConnectionSettings>
        internalGetOtherConnections() {
      if (otherConnections_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OtherConnectionsDefaultEntryHolder.defaultEntry);
      }
      return otherConnections_;
    }

    public int getOtherConnectionsCount() {
      return internalGetOtherConnections().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @Override
    public boolean containsOtherConnections(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetOtherConnections().getMap().containsKey(key);
    }

    /** Use {@link #getOtherConnectionsMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, OtherConnectionSettings> getOtherConnections() {
      return getOtherConnectionsMap();
    }

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @Override
    public java.util.Map<String, OtherConnectionSettings> getOtherConnectionsMap() {
      return internalGetOtherConnections().getMap();
    }

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @Override
    public /* nullable */ OtherConnectionSettings getOtherConnectionsOrDefault(
        String key,
        /* nullable */
        OtherConnectionSettings defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, OtherConnectionSettings> map = internalGetOtherConnections().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @Override
    public OtherConnectionSettings getOtherConnectionsOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, OtherConnectionSettings> map = internalGetOtherConnections().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!hash_.isEmpty()) {
        output.writeBytes(1, hash_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(2, getOpamp());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getOwnMetrics());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(4, getOwnTraces());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(5, getOwnLogs());
      }
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output,
          internalGetOtherConnections(),
          OtherConnectionsDefaultEntryHolder.defaultEntry,
          6);
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!hash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, hash_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(2, getOpamp());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getOwnMetrics());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, getOwnTraces());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(5, getOwnLogs());
      }
      for (java.util.Map.Entry<String, OtherConnectionSettings> entry :
          internalGetOtherConnections().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, OtherConnectionSettings> otherConnections__ =
            OtherConnectionsDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, otherConnections__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ConnectionSettingsOffers)) {
        return super.equals(obj);
      }
      ConnectionSettingsOffers other = (ConnectionSettingsOffers) obj;

      if (!getHash().equals(other.getHash())) return false;
      if (hasOpamp() != other.hasOpamp()) return false;
      if (hasOpamp()) {
        if (!getOpamp().equals(other.getOpamp())) return false;
      }
      if (hasOwnMetrics() != other.hasOwnMetrics()) return false;
      if (hasOwnMetrics()) {
        if (!getOwnMetrics().equals(other.getOwnMetrics())) return false;
      }
      if (hasOwnTraces() != other.hasOwnTraces()) return false;
      if (hasOwnTraces()) {
        if (!getOwnTraces().equals(other.getOwnTraces())) return false;
      }
      if (hasOwnLogs() != other.hasOwnLogs()) return false;
      if (hasOwnLogs()) {
        if (!getOwnLogs().equals(other.getOwnLogs())) return false;
      }
      if (!internalGetOtherConnections().equals(other.internalGetOtherConnections())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + HASH_FIELD_NUMBER;
      hash = (53 * hash) + getHash().hashCode();
      if (hasOpamp()) {
        hash = (37 * hash) + OPAMP_FIELD_NUMBER;
        hash = (53 * hash) + getOpamp().hashCode();
      }
      if (hasOwnMetrics()) {
        hash = (37 * hash) + OWN_METRICS_FIELD_NUMBER;
        hash = (53 * hash) + getOwnMetrics().hashCode();
      }
      if (hasOwnTraces()) {
        hash = (37 * hash) + OWN_TRACES_FIELD_NUMBER;
        hash = (53 * hash) + getOwnTraces().hashCode();
      }
      if (hasOwnLogs()) {
        hash = (37 * hash) + OWN_LOGS_FIELD_NUMBER;
        hash = (53 * hash) + getOwnLogs().hashCode();
      }
      if (!internalGetOtherConnections().getMap().isEmpty()) {
        hash = (37 * hash) + OTHER_CONNECTIONS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOtherConnections().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ConnectionSettingsOffers parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ConnectionSettingsOffers parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ConnectionSettingsOffers parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ConnectionSettingsOffers parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ConnectionSettingsOffers parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ConnectionSettingsOffers parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ConnectionSettingsOffers parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ConnectionSettingsOffers parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ConnectionSettingsOffers parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ConnectionSettingsOffers parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ConnectionSettingsOffers parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ConnectionSettingsOffers parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ConnectionSettingsOffers prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.ConnectionSettingsOffers}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ConnectionSettingsOffers)
        ConnectionSettingsOffersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 6:
            return internalGetOtherConnections();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 6:
            return internalGetMutableOtherConnections();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ConnectionSettingsOffers.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ConnectionSettingsOffers.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getOpampFieldBuilder();
          getOwnMetricsFieldBuilder();
          getOwnTracesFieldBuilder();
          getOwnLogsFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        hash_ = com.google.protobuf.ByteString.EMPTY;
        opamp_ = null;
        if (opampBuilder_ != null) {
          opampBuilder_.dispose();
          opampBuilder_ = null;
        }
        ownMetrics_ = null;
        if (ownMetricsBuilder_ != null) {
          ownMetricsBuilder_.dispose();
          ownMetricsBuilder_ = null;
        }
        ownTraces_ = null;
        if (ownTracesBuilder_ != null) {
          ownTracesBuilder_.dispose();
          ownTracesBuilder_ = null;
        }
        ownLogs_ = null;
        if (ownLogsBuilder_ != null) {
          ownLogsBuilder_.dispose();
          ownLogsBuilder_ = null;
        }
        internalGetMutableOtherConnections().clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
      }

      @Override
      public ConnectionSettingsOffers getDefaultInstanceForType() {
        return ConnectionSettingsOffers.getDefaultInstance();
      }

      @Override
      public ConnectionSettingsOffers build() {
        ConnectionSettingsOffers result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ConnectionSettingsOffers buildPartial() {
        ConnectionSettingsOffers result = new ConnectionSettingsOffers(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(ConnectionSettingsOffers result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.hash_ = hash_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.opamp_ = opampBuilder_ == null ? opamp_ : opampBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.ownMetrics_ =
              ownMetricsBuilder_ == null ? ownMetrics_ : ownMetricsBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.ownTraces_ = ownTracesBuilder_ == null ? ownTraces_ : ownTracesBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.ownLogs_ = ownLogsBuilder_ == null ? ownLogs_ : ownLogsBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.otherConnections_ =
              internalGetOtherConnections().build(OtherConnectionsDefaultEntryHolder.defaultEntry);
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ConnectionSettingsOffers) {
          return mergeFrom((ConnectionSettingsOffers) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ConnectionSettingsOffers other) {
        if (other == ConnectionSettingsOffers.getDefaultInstance()) return this;
        if (other.getHash() != com.google.protobuf.ByteString.EMPTY) {
          setHash(other.getHash());
        }
        if (other.hasOpamp()) {
          mergeOpamp(other.getOpamp());
        }
        if (other.hasOwnMetrics()) {
          mergeOwnMetrics(other.getOwnMetrics());
        }
        if (other.hasOwnTraces()) {
          mergeOwnTraces(other.getOwnTraces());
        }
        if (other.hasOwnLogs()) {
          mergeOwnLogs(other.getOwnLogs());
        }
        internalGetMutableOtherConnections().mergeFrom(other.internalGetOtherConnections());
        bitField0_ |= 0x00000020;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  hash_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  input.readMessage(getOpampFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getOwnMetricsFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  input.readMessage(getOwnTracesFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              case 42:
                {
                  input.readMessage(getOwnLogsFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000010;
                  break;
                } // case 42
              case 50:
                {
                  com.google.protobuf.MapEntry<String, OtherConnectionSettings> otherConnections__ =
                      input.readMessage(
                          OtherConnectionsDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutableOtherConnections()
                      .ensureBuilderMap()
                      .put(otherConnections__.getKey(), otherConnections__.getValue());
                  bitField0_ |= 0x00000020;
                  break;
                } // case 50
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Hash of all settings, including settings that may be omitted from this message
       * because they are unchanged.
       * </pre>
       *
       * <code>bytes hash = 1;</code>
       *
       * @return The hash.
       */
      @Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }

      /**
       *
       *
       * <pre>
       * Hash of all settings, including settings that may be omitted from this message
       * because they are unchanged.
       * </pre>
       *
       * <code>bytes hash = 1;</code>
       *
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        hash_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Hash of all settings, including settings that may be omitted from this message
       * because they are unchanged.
       * </pre>
       *
       * <code>bytes hash = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000001);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }

      private OpAMPConnectionSettings opamp_;
      private com.google.protobuf.SingleFieldBuilderV3<
              OpAMPConnectionSettings,
              OpAMPConnectionSettings.Builder,
              OpAMPConnectionSettingsOrBuilder>
          opampBuilder_;

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       *
       * @return Whether the opamp field is set.
       */
      public boolean hasOpamp() {
        return ((bitField0_ & 0x00000002) != 0);
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       *
       * @return The opamp.
       */
      public OpAMPConnectionSettings getOpamp() {
        if (opampBuilder_ == null) {
          return opamp_ == null ? OpAMPConnectionSettings.getDefaultInstance() : opamp_;
        } else {
          return opampBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder setOpamp(OpAMPConnectionSettings value) {
        if (opampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          opamp_ = value;
        } else {
          opampBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder setOpamp(OpAMPConnectionSettings.Builder builderForValue) {
        if (opampBuilder_ == null) {
          opamp_ = builderForValue.build();
        } else {
          opampBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder mergeOpamp(OpAMPConnectionSettings value) {
        if (opampBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)
              && opamp_ != null
              && opamp_ != OpAMPConnectionSettings.getDefaultInstance()) {
            getOpampBuilder().mergeFrom(value);
          } else {
            opamp_ = value;
          }
        } else {
          opampBuilder_.mergeFrom(value);
        }
        if (opamp_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder clearOpamp() {
        bitField0_ = (bitField0_ & ~0x00000002);
        opamp_ = null;
        if (opampBuilder_ != null) {
          opampBuilder_.dispose();
          opampBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public OpAMPConnectionSettings.Builder getOpampBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getOpampFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public OpAMPConnectionSettingsOrBuilder getOpampOrBuilder() {
        if (opampBuilder_ != null) {
          return opampBuilder_.getMessageOrBuilder();
        } else {
          return opamp_ == null ? OpAMPConnectionSettings.getDefaultInstance() : opamp_;
        }
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              OpAMPConnectionSettings,
              OpAMPConnectionSettings.Builder,
              OpAMPConnectionSettingsOrBuilder>
          getOpampFieldBuilder() {
        if (opampBuilder_ == null) {
          opampBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  OpAMPConnectionSettings,
                  OpAMPConnectionSettings.Builder,
                  OpAMPConnectionSettingsOrBuilder>(getOpamp(), getParentForChildren(), isClean());
          opamp_ = null;
        }
        return opampBuilder_;
      }

      private TelemetryConnectionSettings ownMetrics_;
      private com.google.protobuf.SingleFieldBuilderV3<
              TelemetryConnectionSettings,
              TelemetryConnectionSettings.Builder,
              TelemetryConnectionSettingsOrBuilder>
          ownMetricsBuilder_;

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       *
       * @return Whether the ownMetrics field is set.
       */
      public boolean hasOwnMetrics() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       *
       * @return The ownMetrics.
       */
      public TelemetryConnectionSettings getOwnMetrics() {
        if (ownMetricsBuilder_ == null) {
          return ownMetrics_ == null
              ? TelemetryConnectionSettings.getDefaultInstance()
              : ownMetrics_;
        } else {
          return ownMetricsBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder setOwnMetrics(TelemetryConnectionSettings value) {
        if (ownMetricsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ownMetrics_ = value;
        } else {
          ownMetricsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder setOwnMetrics(TelemetryConnectionSettings.Builder builderForValue) {
        if (ownMetricsBuilder_ == null) {
          ownMetrics_ = builderForValue.build();
        } else {
          ownMetricsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder mergeOwnMetrics(TelemetryConnectionSettings value) {
        if (ownMetricsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && ownMetrics_ != null
              && ownMetrics_ != TelemetryConnectionSettings.getDefaultInstance()) {
            getOwnMetricsBuilder().mergeFrom(value);
          } else {
            ownMetrics_ = value;
          }
        } else {
          ownMetricsBuilder_.mergeFrom(value);
        }
        if (ownMetrics_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder clearOwnMetrics() {
        bitField0_ = (bitField0_ & ~0x00000004);
        ownMetrics_ = null;
        if (ownMetricsBuilder_ != null) {
          ownMetricsBuilder_.dispose();
          ownMetricsBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public TelemetryConnectionSettings.Builder getOwnMetricsBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getOwnMetricsFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public TelemetryConnectionSettingsOrBuilder getOwnMetricsOrBuilder() {
        if (ownMetricsBuilder_ != null) {
          return ownMetricsBuilder_.getMessageOrBuilder();
        } else {
          return ownMetrics_ == null
              ? TelemetryConnectionSettings.getDefaultInstance()
              : ownMetrics_;
        }
      }

      /**
       *
       *
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       *
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       *
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       *
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       *
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              TelemetryConnectionSettings,
              TelemetryConnectionSettings.Builder,
              TelemetryConnectionSettingsOrBuilder>
          getOwnMetricsFieldBuilder() {
        if (ownMetricsBuilder_ == null) {
          ownMetricsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  TelemetryConnectionSettings,
                  TelemetryConnectionSettings.Builder,
                  TelemetryConnectionSettingsOrBuilder>(
                  getOwnMetrics(), getParentForChildren(), isClean());
          ownMetrics_ = null;
        }
        return ownMetricsBuilder_;
      }

      private TelemetryConnectionSettings ownTraces_;
      private com.google.protobuf.SingleFieldBuilderV3<
              TelemetryConnectionSettings,
              TelemetryConnectionSettings.Builder,
              TelemetryConnectionSettingsOrBuilder>
          ownTracesBuilder_;

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       *
       * @return Whether the ownTraces field is set.
       */
      public boolean hasOwnTraces() {
        return ((bitField0_ & 0x00000008) != 0);
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       *
       * @return The ownTraces.
       */
      public TelemetryConnectionSettings getOwnTraces() {
        if (ownTracesBuilder_ == null) {
          return ownTraces_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
        } else {
          return ownTracesBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder setOwnTraces(TelemetryConnectionSettings value) {
        if (ownTracesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ownTraces_ = value;
        } else {
          ownTracesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder setOwnTraces(TelemetryConnectionSettings.Builder builderForValue) {
        if (ownTracesBuilder_ == null) {
          ownTraces_ = builderForValue.build();
        } else {
          ownTracesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder mergeOwnTraces(TelemetryConnectionSettings value) {
        if (ownTracesBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)
              && ownTraces_ != null
              && ownTraces_ != TelemetryConnectionSettings.getDefaultInstance()) {
            getOwnTracesBuilder().mergeFrom(value);
          } else {
            ownTraces_ = value;
          }
        } else {
          ownTracesBuilder_.mergeFrom(value);
        }
        if (ownTraces_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder clearOwnTraces() {
        bitField0_ = (bitField0_ & ~0x00000008);
        ownTraces_ = null;
        if (ownTracesBuilder_ != null) {
          ownTracesBuilder_.dispose();
          ownTracesBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public TelemetryConnectionSettings.Builder getOwnTracesBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getOwnTracesFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public TelemetryConnectionSettingsOrBuilder getOwnTracesOrBuilder() {
        if (ownTracesBuilder_ != null) {
          return ownTracesBuilder_.getMessageOrBuilder();
        } else {
          return ownTraces_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
        }
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              TelemetryConnectionSettings,
              TelemetryConnectionSettings.Builder,
              TelemetryConnectionSettingsOrBuilder>
          getOwnTracesFieldBuilder() {
        if (ownTracesBuilder_ == null) {
          ownTracesBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  TelemetryConnectionSettings,
                  TelemetryConnectionSettings.Builder,
                  TelemetryConnectionSettingsOrBuilder>(
                  getOwnTraces(), getParentForChildren(), isClean());
          ownTraces_ = null;
        }
        return ownTracesBuilder_;
      }

      private TelemetryConnectionSettings ownLogs_;
      private com.google.protobuf.SingleFieldBuilderV3<
              TelemetryConnectionSettings,
              TelemetryConnectionSettings.Builder,
              TelemetryConnectionSettingsOrBuilder>
          ownLogsBuilder_;

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       *
       * @return Whether the ownLogs field is set.
       */
      public boolean hasOwnLogs() {
        return ((bitField0_ & 0x00000010) != 0);
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       *
       * @return The ownLogs.
       */
      public TelemetryConnectionSettings getOwnLogs() {
        if (ownLogsBuilder_ == null) {
          return ownLogs_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
        } else {
          return ownLogsBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder setOwnLogs(TelemetryConnectionSettings value) {
        if (ownLogsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ownLogs_ = value;
        } else {
          ownLogsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder setOwnLogs(TelemetryConnectionSettings.Builder builderForValue) {
        if (ownLogsBuilder_ == null) {
          ownLogs_ = builderForValue.build();
        } else {
          ownLogsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder mergeOwnLogs(TelemetryConnectionSettings value) {
        if (ownLogsBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)
              && ownLogs_ != null
              && ownLogs_ != TelemetryConnectionSettings.getDefaultInstance()) {
            getOwnLogsBuilder().mergeFrom(value);
          } else {
            ownLogs_ = value;
          }
        } else {
          ownLogsBuilder_.mergeFrom(value);
        }
        if (ownLogs_ != null) {
          bitField0_ |= 0x00000010;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder clearOwnLogs() {
        bitField0_ = (bitField0_ & ~0x00000010);
        ownLogs_ = null;
        if (ownLogsBuilder_ != null) {
          ownLogsBuilder_.dispose();
          ownLogsBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public TelemetryConnectionSettings.Builder getOwnLogsBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getOwnLogsFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public TelemetryConnectionSettingsOrBuilder getOwnLogsOrBuilder() {
        if (ownLogsBuilder_ != null) {
          return ownLogsBuilder_.getMessageOrBuilder();
        } else {
          return ownLogs_ == null ? TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
        }
      }

      /**
       *
       *
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              TelemetryConnectionSettings,
              TelemetryConnectionSettings.Builder,
              TelemetryConnectionSettingsOrBuilder>
          getOwnLogsFieldBuilder() {
        if (ownLogsBuilder_ == null) {
          ownLogsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  TelemetryConnectionSettings,
                  TelemetryConnectionSettings.Builder,
                  TelemetryConnectionSettingsOrBuilder>(
                  getOwnLogs(), getParentForChildren(), isClean());
          ownLogs_ = null;
        }
        return ownLogsBuilder_;
      }

      private static final class OtherConnectionsConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, OtherConnectionSettingsOrBuilder, OtherConnectionSettings> {
        @Override
        public OtherConnectionSettings build(OtherConnectionSettingsOrBuilder val) {
          if (val instanceof OtherConnectionSettings) {
            return (OtherConnectionSettings) val;
          }
          return ((OtherConnectionSettings.Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, OtherConnectionSettings> defaultEntry() {
          return OtherConnectionsDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final OtherConnectionsConverter otherConnectionsConverter =
          new OtherConnectionsConverter();

      private com.google.protobuf.MapFieldBuilder<
              String,
              OtherConnectionSettingsOrBuilder,
              OtherConnectionSettings,
              OtherConnectionSettings.Builder>
          otherConnections_;

      private com.google.protobuf.MapFieldBuilder<
              String,
              OtherConnectionSettingsOrBuilder,
              OtherConnectionSettings,
              OtherConnectionSettings.Builder>
          internalGetOtherConnections() {
        if (otherConnections_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(otherConnectionsConverter);
        }
        return otherConnections_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String,
              OtherConnectionSettingsOrBuilder,
              OtherConnectionSettings,
              OtherConnectionSettings.Builder>
          internalGetMutableOtherConnections() {
        if (otherConnections_ == null) {
          otherConnections_ = new com.google.protobuf.MapFieldBuilder<>(otherConnectionsConverter);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return otherConnections_;
      }

      public int getOtherConnectionsCount() {
        return internalGetOtherConnections().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @Override
      public boolean containsOtherConnections(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetOtherConnections().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getOtherConnectionsMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, OtherConnectionSettings> getOtherConnections() {
        return getOtherConnectionsMap();
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @Override
      public java.util.Map<String, OtherConnectionSettings> getOtherConnectionsMap() {
        return internalGetOtherConnections().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @Override
      public /* nullable */ OtherConnectionSettings getOtherConnectionsOrDefault(
          String key,
          /* nullable */
          OtherConnectionSettings defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, OtherConnectionSettingsOrBuilder> map =
            internalGetMutableOtherConnections().ensureBuilderMap();
        return map.containsKey(key) ? otherConnectionsConverter.build(map.get(key)) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @Override
      public OtherConnectionSettings getOtherConnectionsOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, OtherConnectionSettingsOrBuilder> map =
            internalGetMutableOtherConnections().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return otherConnectionsConverter.build(map.get(key));
      }

      public Builder clearOtherConnections() {
        bitField0_ = (bitField0_ & ~0x00000020);
        internalGetMutableOtherConnections().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      public Builder removeOtherConnections(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutableOtherConnections().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, OtherConnectionSettings> getMutableOtherConnections() {
        bitField0_ |= 0x00000020;
        return internalGetMutableOtherConnections().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      public Builder putOtherConnections(String key, OtherConnectionSettings value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutableOtherConnections().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000020;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      public Builder putAllOtherConnections(java.util.Map<String, OtherConnectionSettings> values) {
        for (java.util.Map.Entry<String, OtherConnectionSettings> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableOtherConnections().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000020;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      public OtherConnectionSettings.Builder putOtherConnectionsBuilderIfAbsent(String key) {
        java.util.Map<String, OtherConnectionSettingsOrBuilder> builderMap =
            internalGetMutableOtherConnections().ensureBuilderMap();
        OtherConnectionSettingsOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = OtherConnectionSettings.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof OtherConnectionSettings) {
          entry = ((OtherConnectionSettings) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (OtherConnectionSettings.Builder) entry;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ConnectionSettingsOffers)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ConnectionSettingsOffers)
    private static final ConnectionSettingsOffers DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ConnectionSettingsOffers();
    }

    public static ConnectionSettingsOffers getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ConnectionSettingsOffers> PARSER =
        new com.google.protobuf.AbstractParser<ConnectionSettingsOffers>() {
          @Override
          public ConnectionSettingsOffers parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ConnectionSettingsOffers> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ConnectionSettingsOffers> getParserForType() {
      return PARSER;
    }

    @Override
    public ConnectionSettingsOffers getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PackagesAvailableOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackagesAvailable)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    int getPackagesCount();

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    boolean containsPackages(String key);

    /** Use {@link #getPackagesMap()} instead. */
    @Deprecated
    java.util.Map<String, PackageAvailable> getPackages();

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    java.util.Map<String, PackageAvailable> getPackagesMap();

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    /* nullable */
    PackageAvailable getPackagesOrDefault(
        String key,
        /* nullable */
        PackageAvailable defaultValue);

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    PackageAvailable getPackagesOrThrow(String key);

    /**
     *
     *
     * <pre>
     * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
     * value in subsequent PackageStatuses messages. This in turn allows the management
     * Server to identify that a different set of packages is available for the Agent
     * and specify the available packages in the next ServerToAgent message.
     *
     * This field MUST be always set if the management Server supports packages
     * of agents.
     *
     * The hash is calculated as an aggregate of all packages names and content.
     * </pre>
     *
     * <code>bytes all_packages_hash = 2;</code>
     *
     * @return The allPackagesHash.
     */
    com.google.protobuf.ByteString getAllPackagesHash();
  }

  /**
   *
   *
   * <pre>
   * List of packages that the Server offers to the Agent.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackagesAvailable}
   */
  public static final class PackagesAvailable extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackagesAvailable)
      PackagesAvailableOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use PackagesAvailable.newBuilder() to construct.
    private PackagesAvailable(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PackagesAvailable() {
      allPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new PackagesAvailable();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_PackagesAvailable_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetPackages();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(PackagesAvailable.class, Builder.class);
    }

    public static final int PACKAGES_FIELD_NUMBER = 1;

    private static final class PackagesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, PackageAvailable> defaultEntry =
          com.google.protobuf.MapEntry.<String, PackageAvailable>newDefaultInstance(
              Opamp.internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              PackageAvailable.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, PackageAvailable> packages_;

    private com.google.protobuf.MapField<String, PackageAvailable> internalGetPackages() {
      if (packages_ == null) {
        return com.google.protobuf.MapField.emptyMapField(PackagesDefaultEntryHolder.defaultEntry);
      }
      return packages_;
    }

    public int getPackagesCount() {
      return internalGetPackages().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @Override
    public boolean containsPackages(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetPackages().getMap().containsKey(key);
    }

    /** Use {@link #getPackagesMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, PackageAvailable> getPackages() {
      return getPackagesMap();
    }

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @Override
    public java.util.Map<String, PackageAvailable> getPackagesMap() {
      return internalGetPackages().getMap();
    }

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @Override
    public /* nullable */ PackageAvailable getPackagesOrDefault(
        String key,
        /* nullable */
        PackageAvailable defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, PackageAvailable> map = internalGetPackages().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @Override
    public PackageAvailable getPackagesOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, PackageAvailable> map = internalGetPackages().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ALL_PACKAGES_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString allPackagesHash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
     * value in subsequent PackageStatuses messages. This in turn allows the management
     * Server to identify that a different set of packages is available for the Agent
     * and specify the available packages in the next ServerToAgent message.
     *
     * This field MUST be always set if the management Server supports packages
     * of agents.
     *
     * The hash is calculated as an aggregate of all packages names and content.
     * </pre>
     *
     * <code>bytes all_packages_hash = 2;</code>
     *
     * @return The allPackagesHash.
     */
    @Override
    public com.google.protobuf.ByteString getAllPackagesHash() {
      return allPackagesHash_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetPackages(), PackagesDefaultEntryHolder.defaultEntry, 1);
      if (!allPackagesHash_.isEmpty()) {
        output.writeBytes(2, allPackagesHash_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<String, PackageAvailable> entry :
          internalGetPackages().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, PackageAvailable> packages__ =
            PackagesDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, packages__);
      }
      if (!allPackagesHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, allPackagesHash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof PackagesAvailable)) {
        return super.equals(obj);
      }
      PackagesAvailable other = (PackagesAvailable) obj;

      if (!internalGetPackages().equals(other.internalGetPackages())) return false;
      if (!getAllPackagesHash().equals(other.getAllPackagesHash())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetPackages().getMap().isEmpty()) {
        hash = (37 * hash) + PACKAGES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPackages().hashCode();
      }
      hash = (37 * hash) + ALL_PACKAGES_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getAllPackagesHash().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PackagesAvailable parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackagesAvailable parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackagesAvailable parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackagesAvailable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackagesAvailable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackagesAvailable parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackagesAvailable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackagesAvailable parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackagesAvailable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static PackagesAvailable parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackagesAvailable parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackagesAvailable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(PackagesAvailable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * List of packages that the Server offers to the Agent.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackagesAvailable}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackagesAvailable)
        PackagesAvailableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_PackagesAvailable_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetPackages();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutablePackages();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(PackagesAvailable.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackagesAvailable.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutablePackages().clear();
        allPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_PackagesAvailable_descriptor;
      }

      @Override
      public PackagesAvailable getDefaultInstanceForType() {
        return PackagesAvailable.getDefaultInstance();
      }

      @Override
      public PackagesAvailable build() {
        PackagesAvailable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PackagesAvailable buildPartial() {
        PackagesAvailable result = new PackagesAvailable(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(PackagesAvailable result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.packages_ = internalGetPackages().build(PackagesDefaultEntryHolder.defaultEntry);
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.allPackagesHash_ = allPackagesHash_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PackagesAvailable) {
          return mergeFrom((PackagesAvailable) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PackagesAvailable other) {
        if (other == PackagesAvailable.getDefaultInstance()) return this;
        internalGetMutablePackages().mergeFrom(other.internalGetPackages());
        bitField0_ |= 0x00000001;
        if (other.getAllPackagesHash() != com.google.protobuf.ByteString.EMPTY) {
          setAllPackagesHash(other.getAllPackagesHash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  com.google.protobuf.MapEntry<String, PackageAvailable> packages__ =
                      input.readMessage(
                          PackagesDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutablePackages()
                      .ensureBuilderMap()
                      .put(packages__.getKey(), packages__.getValue());
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  allPackagesHash_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private static final class PackagesConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, PackageAvailableOrBuilder, PackageAvailable> {
        @Override
        public PackageAvailable build(PackageAvailableOrBuilder val) {
          if (val instanceof PackageAvailable) {
            return (PackageAvailable) val;
          }
          return ((PackageAvailable.Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, PackageAvailable> defaultEntry() {
          return PackagesDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final PackagesConverter packagesConverter = new PackagesConverter();

      private com.google.protobuf.MapFieldBuilder<
              String, PackageAvailableOrBuilder, PackageAvailable, PackageAvailable.Builder>
          packages_;

      private com.google.protobuf.MapFieldBuilder<
              String, PackageAvailableOrBuilder, PackageAvailable, PackageAvailable.Builder>
          internalGetPackages() {
        if (packages_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(packagesConverter);
        }
        return packages_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String, PackageAvailableOrBuilder, PackageAvailable, PackageAvailable.Builder>
          internalGetMutablePackages() {
        if (packages_ == null) {
          packages_ = new com.google.protobuf.MapFieldBuilder<>(packagesConverter);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return packages_;
      }

      public int getPackagesCount() {
        return internalGetPackages().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @Override
      public boolean containsPackages(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetPackages().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getPackagesMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, PackageAvailable> getPackages() {
        return getPackagesMap();
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @Override
      public java.util.Map<String, PackageAvailable> getPackagesMap() {
        return internalGetPackages().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @Override
      public /* nullable */ PackageAvailable getPackagesOrDefault(
          String key,
          /* nullable */
          PackageAvailable defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, PackageAvailableOrBuilder> map =
            internalGetMutablePackages().ensureBuilderMap();
        return map.containsKey(key) ? packagesConverter.build(map.get(key)) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @Override
      public PackageAvailable getPackagesOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, PackageAvailableOrBuilder> map =
            internalGetMutablePackages().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return packagesConverter.build(map.get(key));
      }

      public Builder clearPackages() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutablePackages().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      public Builder removePackages(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutablePackages().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, PackageAvailable> getMutablePackages() {
        bitField0_ |= 0x00000001;
        return internalGetMutablePackages().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      public Builder putPackages(String key, PackageAvailable value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutablePackages().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      public Builder putAllPackages(java.util.Map<String, PackageAvailable> values) {
        for (java.util.Map.Entry<String, PackageAvailable> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutablePackages().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      public PackageAvailable.Builder putPackagesBuilderIfAbsent(String key) {
        java.util.Map<String, PackageAvailableOrBuilder> builderMap =
            internalGetMutablePackages().ensureBuilderMap();
        PackageAvailableOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = PackageAvailable.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof PackageAvailable) {
          entry = ((PackageAvailable) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (PackageAvailable.Builder) entry;
      }

      private com.google.protobuf.ByteString allPackagesHash_ =
          com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
       * value in subsequent PackageStatuses messages. This in turn allows the management
       * Server to identify that a different set of packages is available for the Agent
       * and specify the available packages in the next ServerToAgent message.
       *
       * This field MUST be always set if the management Server supports packages
       * of agents.
       *
       * The hash is calculated as an aggregate of all packages names and content.
       * </pre>
       *
       * <code>bytes all_packages_hash = 2;</code>
       *
       * @return The allPackagesHash.
       */
      @Override
      public com.google.protobuf.ByteString getAllPackagesHash() {
        return allPackagesHash_;
      }

      /**
       *
       *
       * <pre>
       * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
       * value in subsequent PackageStatuses messages. This in turn allows the management
       * Server to identify that a different set of packages is available for the Agent
       * and specify the available packages in the next ServerToAgent message.
       *
       * This field MUST be always set if the management Server supports packages
       * of agents.
       *
       * The hash is calculated as an aggregate of all packages names and content.
       * </pre>
       *
       * <code>bytes all_packages_hash = 2;</code>
       *
       * @param value The allPackagesHash to set.
       * @return This builder for chaining.
       */
      public Builder setAllPackagesHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        allPackagesHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
       * value in subsequent PackageStatuses messages. This in turn allows the management
       * Server to identify that a different set of packages is available for the Agent
       * and specify the available packages in the next ServerToAgent message.
       *
       * This field MUST be always set if the management Server supports packages
       * of agents.
       *
       * The hash is calculated as an aggregate of all packages names and content.
       * </pre>
       *
       * <code>bytes all_packages_hash = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearAllPackagesHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        allPackagesHash_ = getDefaultInstance().getAllPackagesHash();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.PackagesAvailable)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackagesAvailable)
    private static final PackagesAvailable DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new PackagesAvailable();
    }

    public static PackagesAvailable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackagesAvailable> PARSER =
        new com.google.protobuf.AbstractParser<PackagesAvailable>() {
          @Override
          public PackagesAvailable parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<PackagesAvailable> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PackagesAvailable> getParserForType() {
      return PARSER;
    }

    @Override
    public PackagesAvailable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PackageAvailableOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageAvailable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();

    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     *
     * @return The type.
     */
    PackageType getType();

    /**
     *
     *
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     *
     * @return The version.
     */
    String getVersion();

    /**
     *
     *
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     *
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString getVersionBytes();

    /**
     *
     *
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     *
     * @return Whether the file field is set.
     */
    boolean hasFile();

    /**
     *
     *
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     *
     * @return The file.
     */
    DownloadableFile getFile();

    /**
     *
     *
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     */
    DownloadableFileOrBuilder getFileOrBuilder();

    /**
     *
     *
     * <pre>
     * The hash of the package. SHOULD be calculated based on all other fields of the
     * PackageAvailable message and content of the file of the package. The hash is
     * used by the Agent to determine if the package it has is different from the
     * package the Server is offering.
     * </pre>
     *
     * <code>bytes hash = 4;</code>
     *
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }

  /**
   *
   *
   * <pre>
   * Each Agent is composed of one or more packages. A package has a name and
   * content stored in a file. The content of the files, functionality
   * provided by the packages, how they are stored and used by the Agent side is Agent
   * type-specific and is outside the concerns of the OpAMP protocol.
   *
   * If the Agent does not have an installed package with the specified name then
   * it SHOULD download it from the specified URL and install it.
   *
   * If the Agent already has an installed package with the specified name
   * but with a different hash then the Agent SHOULD download and
   * install the package again, since it is a different version of the same package.
   *
   * If the Agent has an installed package with the specified name and the same
   * hash then the Agent does not need to do anything, it already
   * has the right version of the package.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageAvailable}
   */
  public static final class PackageAvailable extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageAvailable)
      PackageAvailableOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use PackageAvailable.newBuilder() to construct.
    private PackageAvailable(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PackageAvailable() {
      type_ = 0;
      version_ = "";
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new PackageAvailable();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_PackageAvailable_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_PackageAvailable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(PackageAvailable.class, Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;

    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    @Override
    public int getTypeValue() {
      return type_;
    }

    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     *
     * @return The type.
     */
    @Override
    public PackageType getType() {
      PackageType result = PackageType.forNumber(type_);
      return result == null ? PackageType.UNRECOGNIZED : result;
    }

    public static final int VERSION_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private volatile Object version_ = "";

    /**
     *
     *
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     *
     * @return The version.
     */
    @Override
    public String getVersion() {
      Object ref = version_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        version_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     *
     * @return The bytes for version.
     */
    @Override
    public com.google.protobuf.ByteString getVersionBytes() {
      Object ref = version_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILE_FIELD_NUMBER = 3;
    private DownloadableFile file_;

    /**
     *
     *
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     *
     * @return Whether the file field is set.
     */
    @Override
    public boolean hasFile() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     *
     * @return The file.
     */
    @Override
    public DownloadableFile getFile() {
      return file_ == null ? DownloadableFile.getDefaultInstance() : file_;
    }

    /**
     *
     *
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     */
    @Override
    public DownloadableFileOrBuilder getFileOrBuilder() {
      return file_ == null ? DownloadableFile.getDefaultInstance() : file_;
    }

    public static final int HASH_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * The hash of the package. SHOULD be calculated based on all other fields of the
     * PackageAvailable message and content of the file of the package. The hash is
     * used by the Agent to determine if the package it has is different from the
     * package the Server is offering.
     * </pre>
     *
     * <code>bytes hash = 4;</code>
     *
     * @return The hash.
     */
    @Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (type_ != PackageType.PackageType_TopLevel.getNumber()) {
        output.writeEnum(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(version_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, version_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(3, getFile());
      }
      if (!hash_.isEmpty()) {
        output.writeBytes(4, hash_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != PackageType.PackageType_TopLevel.getNumber()) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(version_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, version_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, getFile());
      }
      if (!hash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(4, hash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof PackageAvailable)) {
        return super.equals(obj);
      }
      PackageAvailable other = (PackageAvailable) obj;

      if (type_ != other.type_) return false;
      if (!getVersion().equals(other.getVersion())) return false;
      if (hasFile() != other.hasFile()) return false;
      if (hasFile()) {
        if (!getFile().equals(other.getFile())) return false;
      }
      if (!getHash().equals(other.getHash())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getVersion().hashCode();
      if (hasFile()) {
        hash = (37 * hash) + FILE_FIELD_NUMBER;
        hash = (53 * hash) + getFile().hashCode();
      }
      hash = (37 * hash) + HASH_FIELD_NUMBER;
      hash = (53 * hash) + getHash().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PackageAvailable parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageAvailable parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageAvailable parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageAvailable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageAvailable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageAvailable parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageAvailable parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageAvailable parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageAvailable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static PackageAvailable parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageAvailable parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageAvailable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(PackageAvailable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Each Agent is composed of one or more packages. A package has a name and
     * content stored in a file. The content of the files, functionality
     * provided by the packages, how they are stored and used by the Agent side is Agent
     * type-specific and is outside the concerns of the OpAMP protocol.
     *
     * If the Agent does not have an installed package with the specified name then
     * it SHOULD download it from the specified URL and install it.
     *
     * If the Agent already has an installed package with the specified name
     * but with a different hash then the Agent SHOULD download and
     * install the package again, since it is a different version of the same package.
     *
     * If the Agent has an installed package with the specified name and the same
     * hash then the Agent does not need to do anything, it already
     * has the right version of the package.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageAvailable}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageAvailable)
        PackageAvailableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_PackageAvailable_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_PackageAvailable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(PackageAvailable.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageAvailable.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getFileFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        version_ = "";
        file_ = null;
        if (fileBuilder_ != null) {
          fileBuilder_.dispose();
          fileBuilder_ = null;
        }
        hash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_PackageAvailable_descriptor;
      }

      @Override
      public PackageAvailable getDefaultInstanceForType() {
        return PackageAvailable.getDefaultInstance();
      }

      @Override
      public PackageAvailable build() {
        PackageAvailable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PackageAvailable buildPartial() {
        PackageAvailable result = new PackageAvailable(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(PackageAvailable result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.file_ = fileBuilder_ == null ? file_ : fileBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.hash_ = hash_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PackageAvailable) {
          return mergeFrom((PackageAvailable) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PackageAvailable other) {
        if (other == PackageAvailable.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (!other.getVersion().isEmpty()) {
          version_ = other.version_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasFile()) {
          mergeFile(other.getFile());
        }
        if (other.getHash() != com.google.protobuf.ByteString.EMPTY) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  type_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              case 18:
                {
                  version_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getFileFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  hash_ = input.readBytes();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private int type_ = 0;

      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       *
       * @return The enum numeric value on the wire for type.
       */
      @Override
      public int getTypeValue() {
        return type_;
      }

      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       *
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       *
       * @return The type.
       */
      @Override
      public PackageType getType() {
        PackageType result = PackageType.forNumber(type_);
        return result == null ? PackageType.UNRECOGNIZED : result;
      }

      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       *
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(PackageType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private Object version_ = "";

      /**
       *
       *
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       *
       * @return The version.
       */
      public String getVersion() {
        Object ref = version_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          version_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       *
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString getVersionBytes() {
        Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       *
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       *
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private DownloadableFile file_;
      private com.google.protobuf.SingleFieldBuilderV3<
              DownloadableFile, DownloadableFile.Builder, DownloadableFileOrBuilder>
          fileBuilder_;

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       *
       * @return Whether the file field is set.
       */
      public boolean hasFile() {
        return ((bitField0_ & 0x00000004) != 0);
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       *
       * @return The file.
       */
      public DownloadableFile getFile() {
        if (fileBuilder_ == null) {
          return file_ == null ? DownloadableFile.getDefaultInstance() : file_;
        } else {
          return fileBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder setFile(DownloadableFile value) {
        if (fileBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          file_ = value;
        } else {
          fileBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder setFile(DownloadableFile.Builder builderForValue) {
        if (fileBuilder_ == null) {
          file_ = builderForValue.build();
        } else {
          fileBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder mergeFile(DownloadableFile value) {
        if (fileBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)
              && file_ != null
              && file_ != DownloadableFile.getDefaultInstance()) {
            getFileBuilder().mergeFrom(value);
          } else {
            file_ = value;
          }
        } else {
          fileBuilder_.mergeFrom(value);
        }
        if (file_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder clearFile() {
        bitField0_ = (bitField0_ & ~0x00000004);
        file_ = null;
        if (fileBuilder_ != null) {
          fileBuilder_.dispose();
          fileBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public DownloadableFile.Builder getFileBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getFileFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public DownloadableFileOrBuilder getFileOrBuilder() {
        if (fileBuilder_ != null) {
          return fileBuilder_.getMessageOrBuilder();
        } else {
          return file_ == null ? DownloadableFile.getDefaultInstance() : file_;
        }
      }

      /**
       *
       *
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              DownloadableFile, DownloadableFile.Builder, DownloadableFileOrBuilder>
          getFileFieldBuilder() {
        if (fileBuilder_ == null) {
          fileBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  DownloadableFile, DownloadableFile.Builder, DownloadableFileOrBuilder>(
                  getFile(), getParentForChildren(), isClean());
          file_ = null;
        }
        return fileBuilder_;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * The hash of the package. SHOULD be calculated based on all other fields of the
       * PackageAvailable message and content of the file of the package. The hash is
       * used by the Agent to determine if the package it has is different from the
       * package the Server is offering.
       * </pre>
       *
       * <code>bytes hash = 4;</code>
       *
       * @return The hash.
       */
      @Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }

      /**
       *
       *
       * <pre>
       * The hash of the package. SHOULD be calculated based on all other fields of the
       * PackageAvailable message and content of the file of the package. The hash is
       * used by the Agent to determine if the package it has is different from the
       * package the Server is offering.
       * </pre>
       *
       * <code>bytes hash = 4;</code>
       *
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        hash_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The hash of the package. SHOULD be calculated based on all other fields of the
       * PackageAvailable message and content of the file of the package. The hash is
       * used by the Agent to determine if the package it has is different from the
       * package the Server is offering.
       * </pre>
       *
       * <code>bytes hash = 4;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000008);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageAvailable)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageAvailable)
    private static final PackageAvailable DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new PackageAvailable();
    }

    public static PackageAvailable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageAvailable> PARSER =
        new com.google.protobuf.AbstractParser<PackageAvailable>() {
          @Override
          public PackageAvailable parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<PackageAvailable> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PackageAvailable> getParserForType() {
      return PARSER;
    }

    @Override
    public PackageAvailable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface DownloadableFileOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.DownloadableFile)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     *
     * @return The downloadUrl.
     */
    String getDownloadUrl();

    /**
     *
     *
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     *
     * @return The bytes for downloadUrl.
     */
    com.google.protobuf.ByteString getDownloadUrlBytes();

    /**
     *
     *
     * <pre>
     * The hash of the file content. Can be used by the Agent to verify that the file
     * was downloaded correctly.
     * </pre>
     *
     * <code>bytes content_hash = 2;</code>
     *
     * @return The contentHash.
     */
    com.google.protobuf.ByteString getContentHash();

    /**
     *
     *
     * <pre>
     * Optional signature of the file content. Can be used by the Agent to verify the
     * authenticity of the downloaded file, for example can be the
     * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
     * The exact signing and verification method is Agent specific. See
     * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
     * for recommendations.
     * </pre>
     *
     * <code>bytes signature = 3;</code>
     *
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();

    /**
     *
     *
     * <pre>
     * Optional headers to use when downloading a file. Typically used to set
     * access tokens or other authorization headers. For HTTP-based protocols
     * the Agent should set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 4;</code>
     *
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when downloading a file. Typically used to set
     * access tokens or other authorization headers. For HTTP-based protocols
     * the Agent should set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 4;</code>
     *
     * @return The headers.
     */
    Headers getHeaders();

    /**
     *
     *
     * <pre>
     * Optional headers to use when downloading a file. Typically used to set
     * access tokens or other authorization headers. For HTTP-based protocols
     * the Agent should set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 4;</code>
     */
    HeadersOrBuilder getHeadersOrBuilder();
  }

  /**
   *
   *
   * <pre>
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.DownloadableFile}
   */
  public static final class DownloadableFile extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.DownloadableFile)
      DownloadableFileOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use DownloadableFile.newBuilder() to construct.
    private DownloadableFile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private DownloadableFile() {
      downloadUrl_ = "";
      contentHash_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new DownloadableFile();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_DownloadableFile_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_DownloadableFile_fieldAccessorTable
          .ensureFieldAccessorsInitialized(DownloadableFile.class, Builder.class);
    }

    private int bitField0_;
    public static final int DOWNLOAD_URL_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object downloadUrl_ = "";

    /**
     *
     *
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     *
     * @return The downloadUrl.
     */
    @Override
    public String getDownloadUrl() {
      Object ref = downloadUrl_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        downloadUrl_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     *
     * @return The bytes for downloadUrl.
     */
    @Override
    public com.google.protobuf.ByteString getDownloadUrlBytes() {
      Object ref = downloadUrl_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        downloadUrl_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTENT_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString contentHash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * The hash of the file content. Can be used by the Agent to verify that the file
     * was downloaded correctly.
     * </pre>
     *
     * <code>bytes content_hash = 2;</code>
     *
     * @return The contentHash.
     */
    @Override
    public com.google.protobuf.ByteString getContentHash() {
      return contentHash_;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Optional signature of the file content. Can be used by the Agent to verify the
     * authenticity of the downloaded file, for example can be the
     * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
     * The exact signing and verification method is Agent specific. See
     * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
     * for recommendations.
     * </pre>
     *
     * <code>bytes signature = 3;</code>
     *
     * @return The signature.
     */
    @Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }

    public static final int HEADERS_FIELD_NUMBER = 4;
    private Headers headers_;

    /**
     *
     *
     * <pre>
     * Optional headers to use when downloading a file. Typically used to set
     * access tokens or other authorization headers. For HTTP-based protocols
     * the Agent should set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 4;</code>
     *
     * @return Whether the headers field is set.
     */
    @Override
    public boolean hasHeaders() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when downloading a file. Typically used to set
     * access tokens or other authorization headers. For HTTP-based protocols
     * the Agent should set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 4;</code>
     *
     * @return The headers.
     */
    @Override
    public Headers getHeaders() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    /**
     *
     *
     * <pre>
     * Optional headers to use when downloading a file. Typically used to set
     * access tokens or other authorization headers. For HTTP-based protocols
     * the Agent should set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 4;</code>
     */
    @Override
    public HeadersOrBuilder getHeadersOrBuilder() {
      return headers_ == null ? Headers.getDefaultInstance() : headers_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(downloadUrl_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, downloadUrl_);
      }
      if (!contentHash_.isEmpty()) {
        output.writeBytes(2, contentHash_);
      }
      if (!signature_.isEmpty()) {
        output.writeBytes(3, signature_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(4, getHeaders());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(downloadUrl_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, downloadUrl_);
      }
      if (!contentHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, contentHash_);
      }
      if (!signature_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, signature_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(4, getHeaders());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof DownloadableFile)) {
        return super.equals(obj);
      }
      DownloadableFile other = (DownloadableFile) obj;

      if (!getDownloadUrl().equals(other.getDownloadUrl())) return false;
      if (!getContentHash().equals(other.getContentHash())) return false;
      if (!getSignature().equals(other.getSignature())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders().equals(other.getHeaders())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DOWNLOAD_URL_FIELD_NUMBER;
      hash = (53 * hash) + getDownloadUrl().hashCode();
      hash = (37 * hash) + CONTENT_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getContentHash().hashCode();
      hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
      hash = (53 * hash) + getSignature().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static DownloadableFile parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static DownloadableFile parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static DownloadableFile parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static DownloadableFile parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static DownloadableFile parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static DownloadableFile parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static DownloadableFile parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static DownloadableFile parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static DownloadableFile parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static DownloadableFile parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static DownloadableFile parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static DownloadableFile parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(DownloadableFile prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.DownloadableFile}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.DownloadableFile)
        DownloadableFileOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_DownloadableFile_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_DownloadableFile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(DownloadableFile.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.DownloadableFile.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getHeadersFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        downloadUrl_ = "";
        contentHash_ = com.google.protobuf.ByteString.EMPTY;
        signature_ = com.google.protobuf.ByteString.EMPTY;
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_DownloadableFile_descriptor;
      }

      @Override
      public DownloadableFile getDefaultInstanceForType() {
        return DownloadableFile.getDefaultInstance();
      }

      @Override
      public DownloadableFile build() {
        DownloadableFile result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public DownloadableFile buildPartial() {
        DownloadableFile result = new DownloadableFile(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(DownloadableFile result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.downloadUrl_ = downloadUrl_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.contentHash_ = contentHash_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.signature_ = signature_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.headers_ = headersBuilder_ == null ? headers_ : headersBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof DownloadableFile) {
          return mergeFrom((DownloadableFile) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(DownloadableFile other) {
        if (other == DownloadableFile.getDefaultInstance()) return this;
        if (!other.getDownloadUrl().isEmpty()) {
          downloadUrl_ = other.downloadUrl_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.getContentHash() != com.google.protobuf.ByteString.EMPTY) {
          setContentHash(other.getContentHash());
        }
        if (other.getSignature() != com.google.protobuf.ByteString.EMPTY) {
          setSignature(other.getSignature());
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  downloadUrl_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  contentHash_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  signature_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  input.readMessage(getHeadersFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object downloadUrl_ = "";

      /**
       *
       *
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       *
       * @return The downloadUrl.
       */
      public String getDownloadUrl() {
        Object ref = downloadUrl_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          downloadUrl_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       *
       * @return The bytes for downloadUrl.
       */
      public com.google.protobuf.ByteString getDownloadUrlBytes() {
        Object ref = downloadUrl_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          downloadUrl_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       *
       * @param value The downloadUrl to set.
       * @return This builder for chaining.
       */
      public Builder setDownloadUrl(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        downloadUrl_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearDownloadUrl() {
        downloadUrl_ = getDefaultInstance().getDownloadUrl();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       *
       * @param value The bytes for downloadUrl to set.
       * @return This builder for chaining.
       */
      public Builder setDownloadUrlBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        downloadUrl_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString contentHash_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * The hash of the file content. Can be used by the Agent to verify that the file
       * was downloaded correctly.
       * </pre>
       *
       * <code>bytes content_hash = 2;</code>
       *
       * @return The contentHash.
       */
      @Override
      public com.google.protobuf.ByteString getContentHash() {
        return contentHash_;
      }

      /**
       *
       *
       * <pre>
       * The hash of the file content. Can be used by the Agent to verify that the file
       * was downloaded correctly.
       * </pre>
       *
       * <code>bytes content_hash = 2;</code>
       *
       * @param value The contentHash to set.
       * @return This builder for chaining.
       */
      public Builder setContentHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        contentHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The hash of the file content. Can be used by the Agent to verify that the file
       * was downloaded correctly.
       * </pre>
       *
       * <code>bytes content_hash = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearContentHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        contentHash_ = getDefaultInstance().getContentHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Optional signature of the file content. Can be used by the Agent to verify the
       * authenticity of the downloaded file, for example can be the
       * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
       * The exact signing and verification method is Agent specific. See
       * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
       * for recommendations.
       * </pre>
       *
       * <code>bytes signature = 3;</code>
       *
       * @return The signature.
       */
      @Override
      public com.google.protobuf.ByteString getSignature() {
        return signature_;
      }

      /**
       *
       *
       * <pre>
       * Optional signature of the file content. Can be used by the Agent to verify the
       * authenticity of the downloaded file, for example can be the
       * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
       * The exact signing and verification method is Agent specific. See
       * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
       * for recommendations.
       * </pre>
       *
       * <code>bytes signature = 3;</code>
       *
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        signature_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional signature of the file content. Can be used by the Agent to verify the
       * authenticity of the downloaded file, for example can be the
       * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
       * The exact signing and verification method is Agent specific. See
       * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
       * for recommendations.
       * </pre>
       *
       * <code>bytes signature = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        bitField0_ = (bitField0_ & ~0x00000004);
        signature_ = getDefaultInstance().getSignature();
        onChanged();
        return this;
      }

      private Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          headersBuilder_;

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       *
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return ((bitField0_ & 0x00000008) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       *
       * @return The headers.
       */
      public Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      public Builder setHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
        } else {
          headersBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      public Builder setHeaders(Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      public Builder mergeHeaders(Headers value) {
        if (headersBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)
              && headers_ != null
              && headers_ != Headers.getDefaultInstance()) {
            getHeadersBuilder().mergeFrom(value);
          } else {
            headers_ = value;
          }
        } else {
          headersBuilder_.mergeFrom(value);
        }
        if (headers_ != null) {
          bitField0_ |= 0x00000008;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      public Builder clearHeaders() {
        bitField0_ = (bitField0_ & ~0x00000008);
        headers_ = null;
        if (headersBuilder_ != null) {
          headersBuilder_.dispose();
          headersBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      public Headers.Builder getHeadersBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      public HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ? Headers.getDefaultInstance() : headers_;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional headers to use when downloading a file. Typically used to set
       * access tokens or other authorization headers. For HTTP-based protocols
       * the Agent should set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<Headers, Headers.Builder, HeadersOrBuilder>
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  Headers, Headers.Builder, HeadersOrBuilder>(
                  getHeaders(), getParentForChildren(), isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.DownloadableFile)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.DownloadableFile)
    private static final DownloadableFile DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new DownloadableFile();
    }

    public static DownloadableFile getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DownloadableFile> PARSER =
        new com.google.protobuf.AbstractParser<DownloadableFile>() {
          @Override
          public DownloadableFile parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<DownloadableFile> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<DownloadableFile> getParserForType() {
      return PARSER;
    }

    @Override
    public DownloadableFile getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ServerErrorResponseOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ServerErrorResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();

    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     *
     * @return The type.
     */
    ServerErrorResponseType getType();

    /**
     *
     *
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     *
     * @return The errorMessage.
     */
    String getErrorMessage();

    /**
     *
     *
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     *
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString getErrorMessageBytes();

    /**
     *
     *
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     *
     * @return Whether the retryInfo field is set.
     */
    boolean hasRetryInfo();

    /**
     *
     *
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     *
     * @return The retryInfo.
     */
    RetryInfo getRetryInfo();

    /**
     *
     *
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     */
    RetryInfoOrBuilder getRetryInfoOrBuilder();

    ServerErrorResponse.DetailsCase getDetailsCase();
  }

  /** Protobuf type {@code opamp.proto.ServerErrorResponse} */
  public static final class ServerErrorResponse extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ServerErrorResponse)
      ServerErrorResponseOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ServerErrorResponse.newBuilder() to construct.
    private ServerErrorResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ServerErrorResponse() {
      type_ = 0;
      errorMessage_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ServerErrorResponse();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ServerErrorResponse_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ServerErrorResponse.class, Builder.class);
    }

    private int detailsCase_ = 0;

    @SuppressWarnings("serial")
    private Object details_;

    public enum DetailsCase implements com.google.protobuf.Internal.EnumLite, InternalOneOfEnum {
      RETRY_INFO(3),
      DETAILS_NOT_SET(0);
      private final int value;

      private DetailsCase(int value) {
        this.value = value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @Deprecated
      public static DetailsCase valueOf(int value) {
        return forNumber(value);
      }

      public static DetailsCase forNumber(int value) {
        switch (value) {
          case 3:
            return RETRY_INFO;
          case 0:
            return DETAILS_NOT_SET;
          default:
            return null;
        }
      }

      public int getNumber() {
        return this.value;
      }
    };

    public DetailsCase getDetailsCase() {
      return DetailsCase.forNumber(detailsCase_);
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;

    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    @Override
    public int getTypeValue() {
      return type_;
    }

    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     *
     * @return The type.
     */
    @Override
    public ServerErrorResponseType getType() {
      ServerErrorResponseType result = ServerErrorResponseType.forNumber(type_);
      return result == null ? ServerErrorResponseType.UNRECOGNIZED : result;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private volatile Object errorMessage_ = "";

    /**
     *
     *
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     *
     * @return The errorMessage.
     */
    @Override
    public String getErrorMessage() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     *
     * @return The bytes for errorMessage.
     */
    @Override
    public com.google.protobuf.ByteString getErrorMessageBytes() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RETRY_INFO_FIELD_NUMBER = 3;

    /**
     *
     *
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     *
     * @return Whether the retryInfo field is set.
     */
    @Override
    public boolean hasRetryInfo() {
      return detailsCase_ == 3;
    }

    /**
     *
     *
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     *
     * @return The retryInfo.
     */
    @Override
    public RetryInfo getRetryInfo() {
      if (detailsCase_ == 3) {
        return (RetryInfo) details_;
      }
      return RetryInfo.getDefaultInstance();
    }

    /**
     *
     *
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     */
    @Override
    public RetryInfoOrBuilder getRetryInfoOrBuilder() {
      if (detailsCase_ == 3) {
        return (RetryInfo) details_;
      }
      return RetryInfo.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (type_ != ServerErrorResponseType.ServerErrorResponseType_Unknown.getNumber()) {
        output.writeEnum(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, errorMessage_);
      }
      if (detailsCase_ == 3) {
        output.writeMessage(3, (RetryInfo) details_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != ServerErrorResponseType.ServerErrorResponseType_Unknown.getNumber()) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, errorMessage_);
      }
      if (detailsCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(3, (RetryInfo) details_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ServerErrorResponse)) {
        return super.equals(obj);
      }
      ServerErrorResponse other = (ServerErrorResponse) obj;

      if (type_ != other.type_) return false;
      if (!getErrorMessage().equals(other.getErrorMessage())) return false;
      if (!getDetailsCase().equals(other.getDetailsCase())) return false;
      switch (detailsCase_) {
        case 3:
          if (!getRetryInfo().equals(other.getRetryInfo())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      switch (detailsCase_) {
        case 3:
          hash = (37 * hash) + RETRY_INFO_FIELD_NUMBER;
          hash = (53 * hash) + getRetryInfo().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ServerErrorResponse parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerErrorResponse parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerErrorResponse parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerErrorResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerErrorResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerErrorResponse parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerErrorResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ServerErrorResponse parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ServerErrorResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ServerErrorResponse parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ServerErrorResponse parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ServerErrorResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ServerErrorResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.ServerErrorResponse} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ServerErrorResponse)
        ServerErrorResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ServerErrorResponse_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ServerErrorResponse.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ServerErrorResponse.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        errorMessage_ = "";
        if (retryInfoBuilder_ != null) {
          retryInfoBuilder_.clear();
        }
        detailsCase_ = 0;
        details_ = null;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ServerErrorResponse_descriptor;
      }

      @Override
      public ServerErrorResponse getDefaultInstanceForType() {
        return ServerErrorResponse.getDefaultInstance();
      }

      @Override
      public ServerErrorResponse build() {
        ServerErrorResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ServerErrorResponse buildPartial() {
        ServerErrorResponse result = new ServerErrorResponse(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(ServerErrorResponse result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.errorMessage_ = errorMessage_;
        }
      }

      private void buildPartialOneofs(ServerErrorResponse result) {
        result.detailsCase_ = detailsCase_;
        result.details_ = this.details_;
        if (detailsCase_ == 3 && retryInfoBuilder_ != null) {
          result.details_ = retryInfoBuilder_.build();
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ServerErrorResponse) {
          return mergeFrom((ServerErrorResponse) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ServerErrorResponse other) {
        if (other == ServerErrorResponse.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        switch (other.getDetailsCase()) {
          case RETRY_INFO:
            {
              mergeRetryInfo(other.getRetryInfo());
              break;
            }
          case DETAILS_NOT_SET:
            {
              break;
            }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  type_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              case 18:
                {
                  errorMessage_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  input.readMessage(getRetryInfoFieldBuilder().getBuilder(), extensionRegistry);
                  detailsCase_ = 3;
                  break;
                } // case 26
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int detailsCase_ = 0;
      private Object details_;

      public DetailsCase getDetailsCase() {
        return DetailsCase.forNumber(detailsCase_);
      }

      public Builder clearDetails() {
        detailsCase_ = 0;
        details_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private int type_ = 0;

      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       *
       * @return The enum numeric value on the wire for type.
       */
      @Override
      public int getTypeValue() {
        return type_;
      }

      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       *
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       *
       * @return The type.
       */
      @Override
      public ServerErrorResponseType getType() {
        ServerErrorResponseType result = ServerErrorResponseType.forNumber(type_);
        return result == null ? ServerErrorResponseType.UNRECOGNIZED : result;
      }

      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       *
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(ServerErrorResponseType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private Object errorMessage_ = "";

      /**
       *
       *
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       *
       * @return The errorMessage.
       */
      public String getErrorMessage() {
        Object ref = errorMessage_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       *
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString getErrorMessageBytes() {
        Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       *
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        errorMessage_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        errorMessage_ = getDefaultInstance().getErrorMessage();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       *
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        errorMessage_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
              RetryInfo, RetryInfo.Builder, RetryInfoOrBuilder>
          retryInfoBuilder_;

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       *
       * @return Whether the retryInfo field is set.
       */
      @Override
      public boolean hasRetryInfo() {
        return detailsCase_ == 3;
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       *
       * @return The retryInfo.
       */
      @Override
      public RetryInfo getRetryInfo() {
        if (retryInfoBuilder_ == null) {
          if (detailsCase_ == 3) {
            return (RetryInfo) details_;
          }
          return RetryInfo.getDefaultInstance();
        } else {
          if (detailsCase_ == 3) {
            return retryInfoBuilder_.getMessage();
          }
          return RetryInfo.getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder setRetryInfo(RetryInfo value) {
        if (retryInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          details_ = value;
          onChanged();
        } else {
          retryInfoBuilder_.setMessage(value);
        }
        detailsCase_ = 3;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder setRetryInfo(RetryInfo.Builder builderForValue) {
        if (retryInfoBuilder_ == null) {
          details_ = builderForValue.build();
          onChanged();
        } else {
          retryInfoBuilder_.setMessage(builderForValue.build());
        }
        detailsCase_ = 3;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder mergeRetryInfo(RetryInfo value) {
        if (retryInfoBuilder_ == null) {
          if (detailsCase_ == 3 && details_ != RetryInfo.getDefaultInstance()) {
            details_ = RetryInfo.newBuilder((RetryInfo) details_).mergeFrom(value).buildPartial();
          } else {
            details_ = value;
          }
          onChanged();
        } else {
          if (detailsCase_ == 3) {
            retryInfoBuilder_.mergeFrom(value);
          } else {
            retryInfoBuilder_.setMessage(value);
          }
        }
        detailsCase_ = 3;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder clearRetryInfo() {
        if (retryInfoBuilder_ == null) {
          if (detailsCase_ == 3) {
            detailsCase_ = 0;
            details_ = null;
            onChanged();
          }
        } else {
          if (detailsCase_ == 3) {
            detailsCase_ = 0;
            details_ = null;
          }
          retryInfoBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public RetryInfo.Builder getRetryInfoBuilder() {
        return getRetryInfoFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      @Override
      public RetryInfoOrBuilder getRetryInfoOrBuilder() {
        if ((detailsCase_ == 3) && (retryInfoBuilder_ != null)) {
          return retryInfoBuilder_.getMessageOrBuilder();
        } else {
          if (detailsCase_ == 3) {
            return (RetryInfo) details_;
          }
          return RetryInfo.getDefaultInstance();
        }
      }

      /**
       *
       *
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              RetryInfo, RetryInfo.Builder, RetryInfoOrBuilder>
          getRetryInfoFieldBuilder() {
        if (retryInfoBuilder_ == null) {
          if (!(detailsCase_ == 3)) {
            details_ = RetryInfo.getDefaultInstance();
          }
          retryInfoBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  RetryInfo, RetryInfo.Builder, RetryInfoOrBuilder>(
                  (RetryInfo) details_, getParentForChildren(), isClean());
          details_ = null;
        }
        detailsCase_ = 3;
        onChanged();
        return retryInfoBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ServerErrorResponse)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ServerErrorResponse)
    private static final ServerErrorResponse DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ServerErrorResponse();
    }

    public static ServerErrorResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerErrorResponse> PARSER =
        new com.google.protobuf.AbstractParser<ServerErrorResponse>() {
          @Override
          public ServerErrorResponse parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ServerErrorResponse> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ServerErrorResponse> getParserForType() {
      return PARSER;
    }

    @Override
    public ServerErrorResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RetryInfoOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.RetryInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>uint64 retry_after_nanoseconds = 1;</code>
     *
     * @return The retryAfterNanoseconds.
     */
    long getRetryAfterNanoseconds();
  }

  /** Protobuf type {@code opamp.proto.RetryInfo} */
  public static final class RetryInfo extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.RetryInfo)
      RetryInfoOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use RetryInfo.newBuilder() to construct.
    private RetryInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RetryInfo() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new RetryInfo();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_RetryInfo_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_RetryInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(RetryInfo.class, Builder.class);
    }

    public static final int RETRY_AFTER_NANOSECONDS_FIELD_NUMBER = 1;
    private long retryAfterNanoseconds_ = 0L;

    /**
     * <code>uint64 retry_after_nanoseconds = 1;</code>
     *
     * @return The retryAfterNanoseconds.
     */
    @Override
    public long getRetryAfterNanoseconds() {
      return retryAfterNanoseconds_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (retryAfterNanoseconds_ != 0L) {
        output.writeUInt64(1, retryAfterNanoseconds_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (retryAfterNanoseconds_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(1, retryAfterNanoseconds_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof RetryInfo)) {
        return super.equals(obj);
      }
      RetryInfo other = (RetryInfo) obj;

      if (getRetryAfterNanoseconds() != other.getRetryAfterNanoseconds()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + RETRY_AFTER_NANOSECONDS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getRetryAfterNanoseconds());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static RetryInfo parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static RetryInfo parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static RetryInfo parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static RetryInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static RetryInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static RetryInfo parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static RetryInfo parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static RetryInfo parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static RetryInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static RetryInfo parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static RetryInfo parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static RetryInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(RetryInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.RetryInfo} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.RetryInfo)
        RetryInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_RetryInfo_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_RetryInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(RetryInfo.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.RetryInfo.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        retryAfterNanoseconds_ = 0L;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_RetryInfo_descriptor;
      }

      @Override
      public RetryInfo getDefaultInstanceForType() {
        return RetryInfo.getDefaultInstance();
      }

      @Override
      public RetryInfo build() {
        RetryInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public RetryInfo buildPartial() {
        RetryInfo result = new RetryInfo(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(RetryInfo result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.retryAfterNanoseconds_ = retryAfterNanoseconds_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof RetryInfo) {
          return mergeFrom((RetryInfo) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(RetryInfo other) {
        if (other == RetryInfo.getDefaultInstance()) return this;
        if (other.getRetryAfterNanoseconds() != 0L) {
          setRetryAfterNanoseconds(other.getRetryAfterNanoseconds());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  retryAfterNanoseconds_ = input.readUInt64();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private long retryAfterNanoseconds_;

      /**
       * <code>uint64 retry_after_nanoseconds = 1;</code>
       *
       * @return The retryAfterNanoseconds.
       */
      @Override
      public long getRetryAfterNanoseconds() {
        return retryAfterNanoseconds_;
      }

      /**
       * <code>uint64 retry_after_nanoseconds = 1;</code>
       *
       * @param value The retryAfterNanoseconds to set.
       * @return This builder for chaining.
       */
      public Builder setRetryAfterNanoseconds(long value) {

        retryAfterNanoseconds_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       * <code>uint64 retry_after_nanoseconds = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearRetryAfterNanoseconds() {
        bitField0_ = (bitField0_ & ~0x00000001);
        retryAfterNanoseconds_ = 0L;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.RetryInfo)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.RetryInfo)
    private static final RetryInfo DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new RetryInfo();
    }

    public static RetryInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RetryInfo> PARSER =
        new com.google.protobuf.AbstractParser<RetryInfo>() {
          @Override
          public RetryInfo parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<RetryInfo> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<RetryInfo> getParserForType() {
      return PARSER;
    }

    @Override
    public RetryInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ServerToAgentCommandOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ServerToAgentCommand)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();

    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     *
     * @return The type.
     */
    CommandType getType();
  }

  /**
   *
   *
   * <pre>
   * ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
   * perform a command.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.ServerToAgentCommand}
   */
  public static final class ServerToAgentCommand extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ServerToAgentCommand)
      ServerToAgentCommandOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ServerToAgentCommand.newBuilder() to construct.
    private ServerToAgentCommand(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ServerToAgentCommand() {
      type_ = 0;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ServerToAgentCommand();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ServerToAgentCommand_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ServerToAgentCommand.class, Builder.class);
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;

    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     *
     * @return The enum numeric value on the wire for type.
     */
    @Override
    public int getTypeValue() {
      return type_;
    }

    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     *
     * @return The type.
     */
    @Override
    public CommandType getType() {
      CommandType result = CommandType.forNumber(type_);
      return result == null ? CommandType.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (type_ != CommandType.CommandType_Restart.getNumber()) {
        output.writeEnum(1, type_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != CommandType.CommandType_Restart.getNumber()) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(1, type_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ServerToAgentCommand)) {
        return super.equals(obj);
      }
      ServerToAgentCommand other = (ServerToAgentCommand) obj;

      if (type_ != other.type_) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ServerToAgentCommand parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerToAgentCommand parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerToAgentCommand parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerToAgentCommand parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerToAgentCommand parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ServerToAgentCommand parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ServerToAgentCommand parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ServerToAgentCommand parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ServerToAgentCommand parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ServerToAgentCommand parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ServerToAgentCommand parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ServerToAgentCommand parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ServerToAgentCommand prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
     * perform a command.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.ServerToAgentCommand}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ServerToAgentCommand)
        ServerToAgentCommandOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ServerToAgentCommand_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ServerToAgentCommand.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ServerToAgentCommand.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ServerToAgentCommand_descriptor;
      }

      @Override
      public ServerToAgentCommand getDefaultInstanceForType() {
        return ServerToAgentCommand.getDefaultInstance();
      }

      @Override
      public ServerToAgentCommand build() {
        ServerToAgentCommand result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ServerToAgentCommand buildPartial() {
        ServerToAgentCommand result = new ServerToAgentCommand(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(ServerToAgentCommand result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ServerToAgentCommand) {
          return mergeFrom((ServerToAgentCommand) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ServerToAgentCommand other) {
        if (other == ServerToAgentCommand.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  type_ = input.readEnum();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private int type_ = 0;

      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       *
       * @return The enum numeric value on the wire for type.
       */
      @Override
      public int getTypeValue() {
        return type_;
      }

      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       *
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       *
       * @return The type.
       */
      @Override
      public CommandType getType() {
        CommandType result = CommandType.forNumber(type_);
        return result == null ? CommandType.UNRECOGNIZED : result;
      }

      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       *
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(CommandType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ServerToAgentCommand)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ServerToAgentCommand)
    private static final ServerToAgentCommand DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ServerToAgentCommand();
    }

    public static ServerToAgentCommand getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerToAgentCommand> PARSER =
        new com.google.protobuf.AbstractParser<ServerToAgentCommand>() {
          @Override
          public ServerToAgentCommand parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ServerToAgentCommand> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ServerToAgentCommand> getParserForType() {
      return PARSER;
    }

    @Override
    public ServerToAgentCommand getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AgentDescriptionOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentDescription)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    java.util.List<Anyvalue.KeyValue> getIdentifyingAttributesList();

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    Anyvalue.KeyValue getIdentifyingAttributes(int index);

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    int getIdentifyingAttributesCount();

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    java.util.List<? extends Anyvalue.KeyValueOrBuilder> getIdentifyingAttributesOrBuilderList();

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    Anyvalue.KeyValueOrBuilder getIdentifyingAttributesOrBuilder(int index);

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    java.util.List<Anyvalue.KeyValue> getNonIdentifyingAttributesList();

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    Anyvalue.KeyValue getNonIdentifyingAttributes(int index);

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    int getNonIdentifyingAttributesCount();

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    java.util.List<? extends Anyvalue.KeyValueOrBuilder> getNonIdentifyingAttributesOrBuilderList();

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    Anyvalue.KeyValueOrBuilder getNonIdentifyingAttributesOrBuilder(int index);
  }

  /** Protobuf type {@code opamp.proto.AgentDescription} */
  public static final class AgentDescription extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentDescription)
      AgentDescriptionOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentDescription.newBuilder() to construct.
    private AgentDescription(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentDescription() {
      identifyingAttributes_ = java.util.Collections.emptyList();
      nonIdentifyingAttributes_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentDescription();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentDescription_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentDescription_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentDescription.class, Builder.class);
    }

    public static final int IDENTIFYING_ATTRIBUTES_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private java.util.List<Anyvalue.KeyValue> identifyingAttributes_;

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @Override
    public java.util.List<Anyvalue.KeyValue> getIdentifyingAttributesList() {
      return identifyingAttributes_;
    }

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @Override
    public java.util.List<? extends Anyvalue.KeyValueOrBuilder>
        getIdentifyingAttributesOrBuilderList() {
      return identifyingAttributes_;
    }

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @Override
    public int getIdentifyingAttributesCount() {
      return identifyingAttributes_.size();
    }

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @Override
    public Anyvalue.KeyValue getIdentifyingAttributes(int index) {
      return identifyingAttributes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     *
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     *
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @Override
    public Anyvalue.KeyValueOrBuilder getIdentifyingAttributesOrBuilder(int index) {
      return identifyingAttributes_.get(index);
    }

    public static final int NON_IDENTIFYING_ATTRIBUTES_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private java.util.List<Anyvalue.KeyValue> nonIdentifyingAttributes_;

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @Override
    public java.util.List<Anyvalue.KeyValue> getNonIdentifyingAttributesList() {
      return nonIdentifyingAttributes_;
    }

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @Override
    public java.util.List<? extends Anyvalue.KeyValueOrBuilder>
        getNonIdentifyingAttributesOrBuilderList() {
      return nonIdentifyingAttributes_;
    }

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @Override
    public int getNonIdentifyingAttributesCount() {
      return nonIdentifyingAttributes_.size();
    }

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @Override
    public Anyvalue.KeyValue getNonIdentifyingAttributes(int index) {
      return nonIdentifyingAttributes_.get(index);
    }

    /**
     *
     *
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @Override
    public Anyvalue.KeyValueOrBuilder getNonIdentifyingAttributesOrBuilder(int index) {
      return nonIdentifyingAttributes_.get(index);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < identifyingAttributes_.size(); i++) {
        output.writeMessage(1, identifyingAttributes_.get(i));
      }
      for (int i = 0; i < nonIdentifyingAttributes_.size(); i++) {
        output.writeMessage(2, nonIdentifyingAttributes_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < identifyingAttributes_.size(); i++) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                1, identifyingAttributes_.get(i));
      }
      for (int i = 0; i < nonIdentifyingAttributes_.size(); i++) {
        size +=
            com.google.protobuf.CodedOutputStream.computeMessageSize(
                2, nonIdentifyingAttributes_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentDescription)) {
        return super.equals(obj);
      }
      AgentDescription other = (AgentDescription) obj;

      if (!getIdentifyingAttributesList().equals(other.getIdentifyingAttributesList()))
        return false;
      if (!getNonIdentifyingAttributesList().equals(other.getNonIdentifyingAttributesList()))
        return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getIdentifyingAttributesCount() > 0) {
        hash = (37 * hash) + IDENTIFYING_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getIdentifyingAttributesList().hashCode();
      }
      if (getNonIdentifyingAttributesCount() > 0) {
        hash = (37 * hash) + NON_IDENTIFYING_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getNonIdentifyingAttributesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentDescription parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentDescription parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentDescription parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentDescription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentDescription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentDescription parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentDescription parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentDescription parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentDescription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentDescription parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentDescription parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentDescription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentDescription prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.AgentDescription} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentDescription)
        AgentDescriptionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentDescription_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentDescription_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentDescription.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentDescription.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (identifyingAttributesBuilder_ == null) {
          identifyingAttributes_ = java.util.Collections.emptyList();
        } else {
          identifyingAttributes_ = null;
          identifyingAttributesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (nonIdentifyingAttributesBuilder_ == null) {
          nonIdentifyingAttributes_ = java.util.Collections.emptyList();
        } else {
          nonIdentifyingAttributes_ = null;
          nonIdentifyingAttributesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentDescription_descriptor;
      }

      @Override
      public AgentDescription getDefaultInstanceForType() {
        return AgentDescription.getDefaultInstance();
      }

      @Override
      public AgentDescription build() {
        AgentDescription result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentDescription buildPartial() {
        AgentDescription result = new AgentDescription(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(AgentDescription result) {
        if (identifyingAttributesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            identifyingAttributes_ = java.util.Collections.unmodifiableList(identifyingAttributes_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.identifyingAttributes_ = identifyingAttributes_;
        } else {
          result.identifyingAttributes_ = identifyingAttributesBuilder_.build();
        }
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            nonIdentifyingAttributes_ =
                java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.nonIdentifyingAttributes_ = nonIdentifyingAttributes_;
        } else {
          result.nonIdentifyingAttributes_ = nonIdentifyingAttributesBuilder_.build();
        }
      }

      private void buildPartial0(AgentDescription result) {
        int from_bitField0_ = bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentDescription) {
          return mergeFrom((AgentDescription) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentDescription other) {
        if (other == AgentDescription.getDefaultInstance()) return this;
        if (identifyingAttributesBuilder_ == null) {
          if (!other.identifyingAttributes_.isEmpty()) {
            if (identifyingAttributes_.isEmpty()) {
              identifyingAttributes_ = other.identifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureIdentifyingAttributesIsMutable();
              identifyingAttributes_.addAll(other.identifyingAttributes_);
            }
            onChanged();
          }
        } else {
          if (!other.identifyingAttributes_.isEmpty()) {
            if (identifyingAttributesBuilder_.isEmpty()) {
              identifyingAttributesBuilder_.dispose();
              identifyingAttributesBuilder_ = null;
              identifyingAttributes_ = other.identifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000001);
              identifyingAttributesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getIdentifyingAttributesFieldBuilder()
                      : null;
            } else {
              identifyingAttributesBuilder_.addAllMessages(other.identifyingAttributes_);
            }
          }
        }
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (!other.nonIdentifyingAttributes_.isEmpty()) {
            if (nonIdentifyingAttributes_.isEmpty()) {
              nonIdentifyingAttributes_ = other.nonIdentifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureNonIdentifyingAttributesIsMutable();
              nonIdentifyingAttributes_.addAll(other.nonIdentifyingAttributes_);
            }
            onChanged();
          }
        } else {
          if (!other.nonIdentifyingAttributes_.isEmpty()) {
            if (nonIdentifyingAttributesBuilder_.isEmpty()) {
              nonIdentifyingAttributesBuilder_.dispose();
              nonIdentifyingAttributesBuilder_ = null;
              nonIdentifyingAttributes_ = other.nonIdentifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000002);
              nonIdentifyingAttributesBuilder_ =
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders
                      ? getNonIdentifyingAttributesFieldBuilder()
                      : null;
            } else {
              nonIdentifyingAttributesBuilder_.addAllMessages(other.nonIdentifyingAttributes_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  Anyvalue.KeyValue m =
                      input.readMessage(Anyvalue.KeyValue.parser(), extensionRegistry);
                  if (identifyingAttributesBuilder_ == null) {
                    ensureIdentifyingAttributesIsMutable();
                    identifyingAttributes_.add(m);
                  } else {
                    identifyingAttributesBuilder_.addMessage(m);
                  }
                  break;
                } // case 10
              case 18:
                {
                  Anyvalue.KeyValue m =
                      input.readMessage(Anyvalue.KeyValue.parser(), extensionRegistry);
                  if (nonIdentifyingAttributesBuilder_ == null) {
                    ensureNonIdentifyingAttributesIsMutable();
                    nonIdentifyingAttributes_.add(m);
                  } else {
                    nonIdentifyingAttributesBuilder_.addMessage(m);
                  }
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private java.util.List<Anyvalue.KeyValue> identifyingAttributes_ =
          java.util.Collections.emptyList();

      private void ensureIdentifyingAttributesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          identifyingAttributes_ =
              new java.util.ArrayList<Anyvalue.KeyValue>(identifyingAttributes_);
          bitField0_ |= 0x00000001;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>
          identifyingAttributesBuilder_;

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public java.util.List<Anyvalue.KeyValue> getIdentifyingAttributesList() {
        if (identifyingAttributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(identifyingAttributes_);
        } else {
          return identifyingAttributesBuilder_.getMessageList();
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public int getIdentifyingAttributesCount() {
        if (identifyingAttributesBuilder_ == null) {
          return identifyingAttributes_.size();
        } else {
          return identifyingAttributesBuilder_.getCount();
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Anyvalue.KeyValue getIdentifyingAttributes(int index) {
        if (identifyingAttributesBuilder_ == null) {
          return identifyingAttributes_.get(index);
        } else {
          return identifyingAttributesBuilder_.getMessage(index);
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder setIdentifyingAttributes(int index, Anyvalue.KeyValue value) {
        if (identifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.set(index, value);
          onChanged();
        } else {
          identifyingAttributesBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder setIdentifyingAttributes(
          int index, Anyvalue.KeyValue.Builder builderForValue) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          identifyingAttributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(Anyvalue.KeyValue value) {
        if (identifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(value);
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(int index, Anyvalue.KeyValue value) {
        if (identifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(index, value);
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(Anyvalue.KeyValue.Builder builderForValue) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(builderForValue.build());
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(
          int index, Anyvalue.KeyValue.Builder builderForValue) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addAllIdentifyingAttributes(Iterable<? extends Anyvalue.KeyValue> values) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, identifyingAttributes_);
          onChanged();
        } else {
          identifyingAttributesBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder clearIdentifyingAttributes() {
        if (identifyingAttributesBuilder_ == null) {
          identifyingAttributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          identifyingAttributesBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder removeIdentifyingAttributes(int index) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.remove(index);
          onChanged();
        } else {
          identifyingAttributesBuilder_.remove(index);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Anyvalue.KeyValue.Builder getIdentifyingAttributesBuilder(int index) {
        return getIdentifyingAttributesFieldBuilder().getBuilder(index);
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Anyvalue.KeyValueOrBuilder getIdentifyingAttributesOrBuilder(int index) {
        if (identifyingAttributesBuilder_ == null) {
          return identifyingAttributes_.get(index);
        } else {
          return identifyingAttributesBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public java.util.List<? extends Anyvalue.KeyValueOrBuilder>
          getIdentifyingAttributesOrBuilderList() {
        if (identifyingAttributesBuilder_ != null) {
          return identifyingAttributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(identifyingAttributes_);
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Anyvalue.KeyValue.Builder addIdentifyingAttributesBuilder() {
        return getIdentifyingAttributesFieldBuilder()
            .addBuilder(Anyvalue.KeyValue.getDefaultInstance());
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Anyvalue.KeyValue.Builder addIdentifyingAttributesBuilder(int index) {
        return getIdentifyingAttributesFieldBuilder()
            .addBuilder(index, Anyvalue.KeyValue.getDefaultInstance());
      }

      /**
       *
       *
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       *
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       *
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public java.util.List<Anyvalue.KeyValue.Builder> getIdentifyingAttributesBuilderList() {
        return getIdentifyingAttributesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>
          getIdentifyingAttributesFieldBuilder() {
        if (identifyingAttributesBuilder_ == null) {
          identifyingAttributesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>(
                  identifyingAttributes_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          identifyingAttributes_ = null;
        }
        return identifyingAttributesBuilder_;
      }

      private java.util.List<Anyvalue.KeyValue> nonIdentifyingAttributes_ =
          java.util.Collections.emptyList();

      private void ensureNonIdentifyingAttributesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          nonIdentifyingAttributes_ =
              new java.util.ArrayList<Anyvalue.KeyValue>(nonIdentifyingAttributes_);
          bitField0_ |= 0x00000002;
        }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>
          nonIdentifyingAttributesBuilder_;

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public java.util.List<Anyvalue.KeyValue> getNonIdentifyingAttributesList() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
        } else {
          return nonIdentifyingAttributesBuilder_.getMessageList();
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public int getNonIdentifyingAttributesCount() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return nonIdentifyingAttributes_.size();
        } else {
          return nonIdentifyingAttributesBuilder_.getCount();
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Anyvalue.KeyValue getNonIdentifyingAttributes(int index) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return nonIdentifyingAttributes_.get(index);
        } else {
          return nonIdentifyingAttributesBuilder_.getMessage(index);
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder setNonIdentifyingAttributes(int index, Anyvalue.KeyValue value) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.set(index, value);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.setMessage(index, value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder setNonIdentifyingAttributes(
          int index, Anyvalue.KeyValue.Builder builderForValue) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(Anyvalue.KeyValue value) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(value);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(int index, Anyvalue.KeyValue value) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(index, value);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(index, value);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(Anyvalue.KeyValue.Builder builderForValue) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(builderForValue.build());
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(
          int index, Anyvalue.KeyValue.Builder builderForValue) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addAllNonIdentifyingAttributes(Iterable<? extends Anyvalue.KeyValue> values) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(values, nonIdentifyingAttributes_);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addAllMessages(values);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder clearNonIdentifyingAttributes() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          nonIdentifyingAttributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.clear();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder removeNonIdentifyingAttributes(int index) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.remove(index);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.remove(index);
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Anyvalue.KeyValue.Builder getNonIdentifyingAttributesBuilder(int index) {
        return getNonIdentifyingAttributesFieldBuilder().getBuilder(index);
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Anyvalue.KeyValueOrBuilder getNonIdentifyingAttributesOrBuilder(int index) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return nonIdentifyingAttributes_.get(index);
        } else {
          return nonIdentifyingAttributesBuilder_.getMessageOrBuilder(index);
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public java.util.List<? extends Anyvalue.KeyValueOrBuilder>
          getNonIdentifyingAttributesOrBuilderList() {
        if (nonIdentifyingAttributesBuilder_ != null) {
          return nonIdentifyingAttributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
        }
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Anyvalue.KeyValue.Builder addNonIdentifyingAttributesBuilder() {
        return getNonIdentifyingAttributesFieldBuilder()
            .addBuilder(Anyvalue.KeyValue.getDefaultInstance());
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Anyvalue.KeyValue.Builder addNonIdentifyingAttributesBuilder(int index) {
        return getNonIdentifyingAttributesFieldBuilder()
            .addBuilder(index, Anyvalue.KeyValue.getDefaultInstance());
      }

      /**
       *
       *
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public java.util.List<Anyvalue.KeyValue.Builder> getNonIdentifyingAttributesBuilderList() {
        return getNonIdentifyingAttributesFieldBuilder().getBuilderList();
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
              Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>
          getNonIdentifyingAttributesFieldBuilder() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          nonIdentifyingAttributesBuilder_ =
              new com.google.protobuf.RepeatedFieldBuilderV3<
                  Anyvalue.KeyValue, Anyvalue.KeyValue.Builder, Anyvalue.KeyValueOrBuilder>(
                  nonIdentifyingAttributes_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          nonIdentifyingAttributes_ = null;
        }
        return nonIdentifyingAttributesBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentDescription)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentDescription)
    private static final AgentDescription DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentDescription();
    }

    public static AgentDescription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentDescription> PARSER =
        new com.google.protobuf.AbstractParser<AgentDescription>() {
          @Override
          public AgentDescription parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentDescription> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentDescription> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentDescription getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface ComponentHealthOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ComponentHealth)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Set to true if the component is up and healthy.
     * </pre>
     *
     * <code>bool healthy = 1;</code>
     *
     * @return The healthy.
     */
    boolean getHealthy();

    /**
     *
     *
     * <pre>
     * Timestamp since the component is up, i.e. when the component was started.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     * If the component is not running MUST be set to 0.
     * </pre>
     *
     * <code>fixed64 start_time_unix_nano = 2;</code>
     *
     * @return The startTimeUnixNano.
     */
    long getStartTimeUnixNano();

    /**
     *
     *
     * <pre>
     * Human-readable error message if the component is in erroneous state. SHOULD be set
     * when healthy==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     *
     * @return The lastError.
     */
    String getLastError();

    /**
     *
     *
     * <pre>
     * Human-readable error message if the component is in erroneous state. SHOULD be set
     * when healthy==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     *
     * @return The bytes for lastError.
     */
    com.google.protobuf.ByteString getLastErrorBytes();

    /**
     *
     *
     * <pre>
     * Component status represented as a string. The status values are defined by agent-specific
     * semantics and not at the protocol level.
     * </pre>
     *
     * <code>string status = 4;</code>
     *
     * @return The status.
     */
    String getStatus();

    /**
     *
     *
     * <pre>
     * Component status represented as a string. The status values are defined by agent-specific
     * semantics and not at the protocol level.
     * </pre>
     *
     * <code>string status = 4;</code>
     *
     * @return The bytes for status.
     */
    com.google.protobuf.ByteString getStatusBytes();

    /**
     *
     *
     * <pre>
     * The time when the component status was observed. Value is UNIX Epoch time in
     * nanoseconds since 00:00:00 UTC on 1 January 1970.
     * </pre>
     *
     * <code>fixed64 status_time_unix_nano = 5;</code>
     *
     * @return The statusTimeUnixNano.
     */
    long getStatusTimeUnixNano();

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    int getComponentHealthMapCount();

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    boolean containsComponentHealthMap(String key);

    /** Use {@link #getComponentHealthMapMap()} instead. */
    @Deprecated
    java.util.Map<String, ComponentHealth> getComponentHealthMap();

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    java.util.Map<String, ComponentHealth> getComponentHealthMapMap();

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    /* nullable */
    ComponentHealth getComponentHealthMapOrDefault(
        String key,
        /* nullable */
        ComponentHealth defaultValue);

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    ComponentHealth getComponentHealthMapOrThrow(String key);
  }

  /**
   *
   *
   * <pre>
   * The health of the Agent and sub-components
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.ComponentHealth}
   */
  public static final class ComponentHealth extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ComponentHealth)
      ComponentHealthOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use ComponentHealth.newBuilder() to construct.
    private ComponentHealth(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private ComponentHealth() {
      lastError_ = "";
      status_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new ComponentHealth();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_ComponentHealth_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 6:
          return internalGetComponentHealthMap();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_ComponentHealth_fieldAccessorTable
          .ensureFieldAccessorsInitialized(ComponentHealth.class, Builder.class);
    }

    public static final int HEALTHY_FIELD_NUMBER = 1;
    private boolean healthy_ = false;

    /**
     *
     *
     * <pre>
     * Set to true if the component is up and healthy.
     * </pre>
     *
     * <code>bool healthy = 1;</code>
     *
     * @return The healthy.
     */
    @Override
    public boolean getHealthy() {
      return healthy_;
    }

    public static final int START_TIME_UNIX_NANO_FIELD_NUMBER = 2;
    private long startTimeUnixNano_ = 0L;

    /**
     *
     *
     * <pre>
     * Timestamp since the component is up, i.e. when the component was started.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     * If the component is not running MUST be set to 0.
     * </pre>
     *
     * <code>fixed64 start_time_unix_nano = 2;</code>
     *
     * @return The startTimeUnixNano.
     */
    @Override
    public long getStartTimeUnixNano() {
      return startTimeUnixNano_;
    }

    public static final int LAST_ERROR_FIELD_NUMBER = 3;

    @SuppressWarnings("serial")
    private volatile Object lastError_ = "";

    /**
     *
     *
     * <pre>
     * Human-readable error message if the component is in erroneous state. SHOULD be set
     * when healthy==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     *
     * @return The lastError.
     */
    @Override
    public String getLastError() {
      Object ref = lastError_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        lastError_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Human-readable error message if the component is in erroneous state. SHOULD be set
     * when healthy==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     *
     * @return The bytes for lastError.
     */
    @Override
    public com.google.protobuf.ByteString getLastErrorBytes() {
      Object ref = lastError_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        lastError_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_FIELD_NUMBER = 4;

    @SuppressWarnings("serial")
    private volatile Object status_ = "";

    /**
     *
     *
     * <pre>
     * Component status represented as a string. The status values are defined by agent-specific
     * semantics and not at the protocol level.
     * </pre>
     *
     * <code>string status = 4;</code>
     *
     * @return The status.
     */
    @Override
    public String getStatus() {
      Object ref = status_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        status_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Component status represented as a string. The status values are defined by agent-specific
     * semantics and not at the protocol level.
     * </pre>
     *
     * <code>string status = 4;</code>
     *
     * @return The bytes for status.
     */
    @Override
    public com.google.protobuf.ByteString getStatusBytes() {
      Object ref = status_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        status_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STATUS_TIME_UNIX_NANO_FIELD_NUMBER = 5;
    private long statusTimeUnixNano_ = 0L;

    /**
     *
     *
     * <pre>
     * The time when the component status was observed. Value is UNIX Epoch time in
     * nanoseconds since 00:00:00 UTC on 1 January 1970.
     * </pre>
     *
     * <code>fixed64 status_time_unix_nano = 5;</code>
     *
     * @return The statusTimeUnixNano.
     */
    @Override
    public long getStatusTimeUnixNano() {
      return statusTimeUnixNano_;
    }

    public static final int COMPONENT_HEALTH_MAP_FIELD_NUMBER = 6;

    private static final class ComponentHealthMapDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, ComponentHealth> defaultEntry =
          com.google.protobuf.MapEntry.<String, ComponentHealth>newDefaultInstance(
              Opamp.internal_static_opamp_proto_ComponentHealth_ComponentHealthMapEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              ComponentHealth.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, ComponentHealth> componentHealthMap_;

    private com.google.protobuf.MapField<String, ComponentHealth> internalGetComponentHealthMap() {
      if (componentHealthMap_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ComponentHealthMapDefaultEntryHolder.defaultEntry);
      }
      return componentHealthMap_;
    }

    public int getComponentHealthMapCount() {
      return internalGetComponentHealthMap().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    @Override
    public boolean containsComponentHealthMap(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetComponentHealthMap().getMap().containsKey(key);
    }

    /** Use {@link #getComponentHealthMapMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, ComponentHealth> getComponentHealthMap() {
      return getComponentHealthMapMap();
    }

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    @Override
    public java.util.Map<String, ComponentHealth> getComponentHealthMapMap() {
      return internalGetComponentHealthMap().getMap();
    }

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    @Override
    public /* nullable */ ComponentHealth getComponentHealthMapOrDefault(
        String key,
        /* nullable */
        ComponentHealth defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, ComponentHealth> map = internalGetComponentHealthMap().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * A map to store more granular, sub-component health. It can nest as deeply as needed to
     * describe the underlying system.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
     */
    @Override
    public ComponentHealth getComponentHealthMapOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, ComponentHealth> map = internalGetComponentHealthMap().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (healthy_ != false) {
        output.writeBool(1, healthy_);
      }
      if (startTimeUnixNano_ != 0L) {
        output.writeFixed64(2, startTimeUnixNano_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(lastError_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, lastError_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(status_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, status_);
      }
      if (statusTimeUnixNano_ != 0L) {
        output.writeFixed64(5, statusTimeUnixNano_);
      }
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output,
          internalGetComponentHealthMap(),
          ComponentHealthMapDefaultEntryHolder.defaultEntry,
          6);
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (healthy_ != false) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, healthy_);
      }
      if (startTimeUnixNano_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeFixed64Size(2, startTimeUnixNano_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(lastError_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, lastError_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(status_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, status_);
      }
      if (statusTimeUnixNano_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeFixed64Size(5, statusTimeUnixNano_);
      }
      for (java.util.Map.Entry<String, ComponentHealth> entry :
          internalGetComponentHealthMap().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, ComponentHealth> componentHealthMap__ =
            ComponentHealthMapDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(6, componentHealthMap__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof ComponentHealth)) {
        return super.equals(obj);
      }
      ComponentHealth other = (ComponentHealth) obj;

      if (getHealthy() != other.getHealthy()) return false;
      if (getStartTimeUnixNano() != other.getStartTimeUnixNano()) return false;
      if (!getLastError().equals(other.getLastError())) return false;
      if (!getStatus().equals(other.getStatus())) return false;
      if (getStatusTimeUnixNano() != other.getStatusTimeUnixNano()) return false;
      if (!internalGetComponentHealthMap().equals(other.internalGetComponentHealthMap()))
        return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + HEALTHY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getHealthy());
      hash = (37 * hash) + START_TIME_UNIX_NANO_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getStartTimeUnixNano());
      hash = (37 * hash) + LAST_ERROR_FIELD_NUMBER;
      hash = (53 * hash) + getLastError().hashCode();
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + getStatus().hashCode();
      hash = (37 * hash) + STATUS_TIME_UNIX_NANO_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getStatusTimeUnixNano());
      if (!internalGetComponentHealthMap().getMap().isEmpty()) {
        hash = (37 * hash) + COMPONENT_HEALTH_MAP_FIELD_NUMBER;
        hash = (53 * hash) + internalGetComponentHealthMap().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ComponentHealth parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ComponentHealth parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ComponentHealth parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ComponentHealth parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ComponentHealth parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static ComponentHealth parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static ComponentHealth parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ComponentHealth parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ComponentHealth parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static ComponentHealth parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static ComponentHealth parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static ComponentHealth parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(ComponentHealth prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * The health of the Agent and sub-components
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.ComponentHealth}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ComponentHealth)
        ComponentHealthOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_ComponentHealth_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 6:
            return internalGetComponentHealthMap();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 6:
            return internalGetMutableComponentHealthMap();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_ComponentHealth_fieldAccessorTable
            .ensureFieldAccessorsInitialized(ComponentHealth.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.ComponentHealth.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        healthy_ = false;
        startTimeUnixNano_ = 0L;
        lastError_ = "";
        status_ = "";
        statusTimeUnixNano_ = 0L;
        internalGetMutableComponentHealthMap().clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_ComponentHealth_descriptor;
      }

      @Override
      public ComponentHealth getDefaultInstanceForType() {
        return ComponentHealth.getDefaultInstance();
      }

      @Override
      public ComponentHealth build() {
        ComponentHealth result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ComponentHealth buildPartial() {
        ComponentHealth result = new ComponentHealth(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(ComponentHealth result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.healthy_ = healthy_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.startTimeUnixNano_ = startTimeUnixNano_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.lastError_ = lastError_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.status_ = status_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.statusTimeUnixNano_ = statusTimeUnixNano_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.componentHealthMap_ =
              internalGetComponentHealthMap()
                  .build(ComponentHealthMapDefaultEntryHolder.defaultEntry);
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ComponentHealth) {
          return mergeFrom((ComponentHealth) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ComponentHealth other) {
        if (other == ComponentHealth.getDefaultInstance()) return this;
        if (other.getHealthy() != false) {
          setHealthy(other.getHealthy());
        }
        if (other.getStartTimeUnixNano() != 0L) {
          setStartTimeUnixNano(other.getStartTimeUnixNano());
        }
        if (!other.getLastError().isEmpty()) {
          lastError_ = other.lastError_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (!other.getStatus().isEmpty()) {
          status_ = other.status_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.getStatusTimeUnixNano() != 0L) {
          setStatusTimeUnixNano(other.getStatusTimeUnixNano());
        }
        internalGetMutableComponentHealthMap().mergeFrom(other.internalGetComponentHealthMap());
        bitField0_ |= 0x00000020;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8:
                {
                  healthy_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
              case 17:
                {
                  startTimeUnixNano_ = input.readFixed64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 17
              case 26:
                {
                  lastError_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  status_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              case 41:
                {
                  statusTimeUnixNano_ = input.readFixed64();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 41
              case 50:
                {
                  com.google.protobuf.MapEntry<String, ComponentHealth> componentHealthMap__ =
                      input.readMessage(
                          ComponentHealthMapDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutableComponentHealthMap()
                      .ensureBuilderMap()
                      .put(componentHealthMap__.getKey(), componentHealthMap__.getValue());
                  bitField0_ |= 0x00000020;
                  break;
                } // case 50
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private boolean healthy_;

      /**
       *
       *
       * <pre>
       * Set to true if the component is up and healthy.
       * </pre>
       *
       * <code>bool healthy = 1;</code>
       *
       * @return The healthy.
       */
      @Override
      public boolean getHealthy() {
        return healthy_;
      }

      /**
       *
       *
       * <pre>
       * Set to true if the component is up and healthy.
       * </pre>
       *
       * <code>bool healthy = 1;</code>
       *
       * @param value The healthy to set.
       * @return This builder for chaining.
       */
      public Builder setHealthy(boolean value) {

        healthy_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Set to true if the component is up and healthy.
       * </pre>
       *
       * <code>bool healthy = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearHealthy() {
        bitField0_ = (bitField0_ & ~0x00000001);
        healthy_ = false;
        onChanged();
        return this;
      }

      private long startTimeUnixNano_;

      /**
       *
       *
       * <pre>
       * Timestamp since the component is up, i.e. when the component was started.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * If the component is not running MUST be set to 0.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 2;</code>
       *
       * @return The startTimeUnixNano.
       */
      @Override
      public long getStartTimeUnixNano() {
        return startTimeUnixNano_;
      }

      /**
       *
       *
       * <pre>
       * Timestamp since the component is up, i.e. when the component was started.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * If the component is not running MUST be set to 0.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 2;</code>
       *
       * @param value The startTimeUnixNano to set.
       * @return This builder for chaining.
       */
      public Builder setStartTimeUnixNano(long value) {

        startTimeUnixNano_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Timestamp since the component is up, i.e. when the component was started.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * If the component is not running MUST be set to 0.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearStartTimeUnixNano() {
        bitField0_ = (bitField0_ & ~0x00000002);
        startTimeUnixNano_ = 0L;
        onChanged();
        return this;
      }

      private Object lastError_ = "";

      /**
       *
       *
       * <pre>
       * Human-readable error message if the component is in erroneous state. SHOULD be set
       * when healthy==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       *
       * @return The lastError.
       */
      public String getLastError() {
        Object ref = lastError_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          lastError_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Human-readable error message if the component is in erroneous state. SHOULD be set
       * when healthy==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       *
       * @return The bytes for lastError.
       */
      public com.google.protobuf.ByteString getLastErrorBytes() {
        Object ref = lastError_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          lastError_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Human-readable error message if the component is in erroneous state. SHOULD be set
       * when healthy==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       *
       * @param value The lastError to set.
       * @return This builder for chaining.
       */
      public Builder setLastError(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        lastError_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Human-readable error message if the component is in erroneous state. SHOULD be set
       * when healthy==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearLastError() {
        lastError_ = getDefaultInstance().getLastError();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Human-readable error message if the component is in erroneous state. SHOULD be set
       * when healthy==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       *
       * @param value The bytes for lastError to set.
       * @return This builder for chaining.
       */
      public Builder setLastErrorBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        lastError_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private Object status_ = "";

      /**
       *
       *
       * <pre>
       * Component status represented as a string. The status values are defined by agent-specific
       * semantics and not at the protocol level.
       * </pre>
       *
       * <code>string status = 4;</code>
       *
       * @return The status.
       */
      public String getStatus() {
        Object ref = status_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          status_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Component status represented as a string. The status values are defined by agent-specific
       * semantics and not at the protocol level.
       * </pre>
       *
       * <code>string status = 4;</code>
       *
       * @return The bytes for status.
       */
      public com.google.protobuf.ByteString getStatusBytes() {
        Object ref = status_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          status_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Component status represented as a string. The status values are defined by agent-specific
       * semantics and not at the protocol level.
       * </pre>
       *
       * <code>string status = 4;</code>
       *
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        status_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Component status represented as a string. The status values are defined by agent-specific
       * semantics and not at the protocol level.
       * </pre>
       *
       * <code>string status = 4;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        status_ = getDefaultInstance().getStatus();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Component status represented as a string. The status values are defined by agent-specific
       * semantics and not at the protocol level.
       * </pre>
       *
       * <code>string status = 4;</code>
       *
       * @param value The bytes for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        status_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private long statusTimeUnixNano_;

      /**
       *
       *
       * <pre>
       * The time when the component status was observed. Value is UNIX Epoch time in
       * nanoseconds since 00:00:00 UTC on 1 January 1970.
       * </pre>
       *
       * <code>fixed64 status_time_unix_nano = 5;</code>
       *
       * @return The statusTimeUnixNano.
       */
      @Override
      public long getStatusTimeUnixNano() {
        return statusTimeUnixNano_;
      }

      /**
       *
       *
       * <pre>
       * The time when the component status was observed. Value is UNIX Epoch time in
       * nanoseconds since 00:00:00 UTC on 1 January 1970.
       * </pre>
       *
       * <code>fixed64 status_time_unix_nano = 5;</code>
       *
       * @param value The statusTimeUnixNano to set.
       * @return This builder for chaining.
       */
      public Builder setStatusTimeUnixNano(long value) {

        statusTimeUnixNano_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The time when the component status was observed. Value is UNIX Epoch time in
       * nanoseconds since 00:00:00 UTC on 1 January 1970.
       * </pre>
       *
       * <code>fixed64 status_time_unix_nano = 5;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearStatusTimeUnixNano() {
        bitField0_ = (bitField0_ & ~0x00000010);
        statusTimeUnixNano_ = 0L;
        onChanged();
        return this;
      }

      private static final class ComponentHealthMapConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, ComponentHealthOrBuilder, ComponentHealth> {
        @Override
        public ComponentHealth build(ComponentHealthOrBuilder val) {
          if (val instanceof ComponentHealth) {
            return (ComponentHealth) val;
          }
          return ((Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, ComponentHealth> defaultEntry() {
          return ComponentHealthMapDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final ComponentHealthMapConverter componentHealthMapConverter =
          new ComponentHealthMapConverter();

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentHealthOrBuilder, ComponentHealth, Builder>
          componentHealthMap_;

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentHealthOrBuilder, ComponentHealth, Builder>
          internalGetComponentHealthMap() {
        if (componentHealthMap_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(componentHealthMapConverter);
        }
        return componentHealthMap_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String, ComponentHealthOrBuilder, ComponentHealth, Builder>
          internalGetMutableComponentHealthMap() {
        if (componentHealthMap_ == null) {
          componentHealthMap_ =
              new com.google.protobuf.MapFieldBuilder<>(componentHealthMapConverter);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return componentHealthMap_;
      }

      public int getComponentHealthMapCount() {
        return internalGetComponentHealthMap().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      @Override
      public boolean containsComponentHealthMap(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetComponentHealthMap().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getComponentHealthMapMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, ComponentHealth> getComponentHealthMap() {
        return getComponentHealthMapMap();
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      @Override
      public java.util.Map<String, ComponentHealth> getComponentHealthMapMap() {
        return internalGetComponentHealthMap().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      @Override
      public /* nullable */ ComponentHealth getComponentHealthMapOrDefault(
          String key,
          /* nullable */
          ComponentHealth defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, ComponentHealthOrBuilder> map =
            internalGetMutableComponentHealthMap().ensureBuilderMap();
        return map.containsKey(key)
            ? componentHealthMapConverter.build(map.get(key))
            : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      @Override
      public ComponentHealth getComponentHealthMapOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, ComponentHealthOrBuilder> map =
            internalGetMutableComponentHealthMap().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return componentHealthMapConverter.build(map.get(key));
      }

      public Builder clearComponentHealthMap() {
        bitField0_ = (bitField0_ & ~0x00000020);
        internalGetMutableComponentHealthMap().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      public Builder removeComponentHealthMap(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutableComponentHealthMap().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, ComponentHealth> getMutableComponentHealthMap() {
        bitField0_ |= 0x00000020;
        return internalGetMutableComponentHealthMap().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      public Builder putComponentHealthMap(String key, ComponentHealth value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutableComponentHealthMap().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000020;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      public Builder putAllComponentHealthMap(java.util.Map<String, ComponentHealth> values) {
        for (java.util.Map.Entry<String, ComponentHealth> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableComponentHealthMap().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000020;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map to store more granular, sub-component health. It can nest as deeply as needed to
       * describe the underlying system.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.ComponentHealth&gt; component_health_map = 6;</code>
       */
      public Builder putComponentHealthMapBuilderIfAbsent(String key) {
        java.util.Map<String, ComponentHealthOrBuilder> builderMap =
            internalGetMutableComponentHealthMap().ensureBuilderMap();
        ComponentHealthOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = ComponentHealth.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof ComponentHealth) {
          entry = ((ComponentHealth) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (Builder) entry;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.ComponentHealth)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ComponentHealth)
    private static final ComponentHealth DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new ComponentHealth();
    }

    public static ComponentHealth getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ComponentHealth> PARSER =
        new com.google.protobuf.AbstractParser<ComponentHealth>() {
          @Override
          public ComponentHealth parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<ComponentHealth> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ComponentHealth> getParserForType() {
      return PARSER;
    }

    @Override
    public ComponentHealth getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface EffectiveConfigOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.EffectiveConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     *
     * @return Whether the configMap field is set.
     */
    boolean hasConfigMap();

    /**
     *
     *
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     *
     * @return The configMap.
     */
    AgentConfigMap getConfigMap();

    /**
     *
     *
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     */
    AgentConfigMapOrBuilder getConfigMapOrBuilder();
  }

  /** Protobuf type {@code opamp.proto.EffectiveConfig} */
  public static final class EffectiveConfig extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.EffectiveConfig)
      EffectiveConfigOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use EffectiveConfig.newBuilder() to construct.
    private EffectiveConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private EffectiveConfig() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new EffectiveConfig();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_EffectiveConfig_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(EffectiveConfig.class, Builder.class);
    }

    private int bitField0_;
    public static final int CONFIG_MAP_FIELD_NUMBER = 1;
    private AgentConfigMap configMap_;

    /**
     *
     *
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     *
     * @return Whether the configMap field is set.
     */
    @Override
    public boolean hasConfigMap() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     *
     * @return The configMap.
     */
    @Override
    public AgentConfigMap getConfigMap() {
      return configMap_ == null ? AgentConfigMap.getDefaultInstance() : configMap_;
    }

    /**
     *
     *
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     */
    @Override
    public AgentConfigMapOrBuilder getConfigMapOrBuilder() {
      return configMap_ == null ? AgentConfigMap.getDefaultInstance() : configMap_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getConfigMap());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getConfigMap());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof EffectiveConfig)) {
        return super.equals(obj);
      }
      EffectiveConfig other = (EffectiveConfig) obj;

      if (hasConfigMap() != other.hasConfigMap()) return false;
      if (hasConfigMap()) {
        if (!getConfigMap().equals(other.getConfigMap())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfigMap()) {
        hash = (37 * hash) + CONFIG_MAP_FIELD_NUMBER;
        hash = (53 * hash) + getConfigMap().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static EffectiveConfig parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static EffectiveConfig parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static EffectiveConfig parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static EffectiveConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static EffectiveConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static EffectiveConfig parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static EffectiveConfig parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static EffectiveConfig parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static EffectiveConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static EffectiveConfig parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static EffectiveConfig parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static EffectiveConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(EffectiveConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.EffectiveConfig} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.EffectiveConfig)
        EffectiveConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_EffectiveConfig_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(EffectiveConfig.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.EffectiveConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getConfigMapFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        configMap_ = null;
        if (configMapBuilder_ != null) {
          configMapBuilder_.dispose();
          configMapBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_EffectiveConfig_descriptor;
      }

      @Override
      public EffectiveConfig getDefaultInstanceForType() {
        return EffectiveConfig.getDefaultInstance();
      }

      @Override
      public EffectiveConfig build() {
        EffectiveConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public EffectiveConfig buildPartial() {
        EffectiveConfig result = new EffectiveConfig(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(EffectiveConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.configMap_ = configMapBuilder_ == null ? configMap_ : configMapBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof EffectiveConfig) {
          return mergeFrom((EffectiveConfig) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(EffectiveConfig other) {
        if (other == EffectiveConfig.getDefaultInstance()) return this;
        if (other.hasConfigMap()) {
          mergeConfigMap(other.getConfigMap());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  input.readMessage(getConfigMapFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private AgentConfigMap configMap_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentConfigMap, AgentConfigMap.Builder, AgentConfigMapOrBuilder>
          configMapBuilder_;

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       *
       * @return Whether the configMap field is set.
       */
      public boolean hasConfigMap() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       *
       * @return The configMap.
       */
      public AgentConfigMap getConfigMap() {
        if (configMapBuilder_ == null) {
          return configMap_ == null ? AgentConfigMap.getDefaultInstance() : configMap_;
        } else {
          return configMapBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder setConfigMap(AgentConfigMap value) {
        if (configMapBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          configMap_ = value;
        } else {
          configMapBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder setConfigMap(AgentConfigMap.Builder builderForValue) {
        if (configMapBuilder_ == null) {
          configMap_ = builderForValue.build();
        } else {
          configMapBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder mergeConfigMap(AgentConfigMap value) {
        if (configMapBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)
              && configMap_ != null
              && configMap_ != AgentConfigMap.getDefaultInstance()) {
            getConfigMapBuilder().mergeFrom(value);
          } else {
            configMap_ = value;
          }
        } else {
          configMapBuilder_.mergeFrom(value);
        }
        if (configMap_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder clearConfigMap() {
        bitField0_ = (bitField0_ & ~0x00000001);
        configMap_ = null;
        if (configMapBuilder_ != null) {
          configMapBuilder_.dispose();
          configMapBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public AgentConfigMap.Builder getConfigMapBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getConfigMapFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public AgentConfigMapOrBuilder getConfigMapOrBuilder() {
        if (configMapBuilder_ != null) {
          return configMapBuilder_.getMessageOrBuilder();
        } else {
          return configMap_ == null ? AgentConfigMap.getDefaultInstance() : configMap_;
        }
      }

      /**
       *
       *
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentConfigMap, AgentConfigMap.Builder, AgentConfigMapOrBuilder>
          getConfigMapFieldBuilder() {
        if (configMapBuilder_ == null) {
          configMapBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AgentConfigMap, AgentConfigMap.Builder, AgentConfigMapOrBuilder>(
                  getConfigMap(), getParentForChildren(), isClean());
          configMap_ = null;
        }
        return configMapBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.EffectiveConfig)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.EffectiveConfig)
    private static final EffectiveConfig DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new EffectiveConfig();
    }

    public static EffectiveConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EffectiveConfig> PARSER =
        new com.google.protobuf.AbstractParser<EffectiveConfig>() {
          @Override
          public EffectiveConfig parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<EffectiveConfig> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<EffectiveConfig> getParserForType() {
      return PARSER;
    }

    @Override
    public EffectiveConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface RemoteConfigStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.RemoteConfigStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The hash of the remote config that was last received by this Agent in the
     * AgentRemoteConfig.config_hash field.
     * The Server SHOULD compare this hash with the config hash
     * it has for the Agent and if the hashes are different the Server MUST include
     * the remote_config field in the response in the ServerToAgent message.
     * </pre>
     *
     * <code>bytes last_remote_config_hash = 1;</code>
     *
     * @return The lastRemoteConfigHash.
     */
    com.google.protobuf.ByteString getLastRemoteConfigHash();

    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     *
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();

    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     *
     * @return The status.
     */
    RemoteConfigStatuses getStatus();

    /**
     *
     *
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The errorMessage.
     */
    String getErrorMessage();

    /**
     *
     *
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString getErrorMessageBytes();
  }

  /** Protobuf type {@code opamp.proto.RemoteConfigStatus} */
  public static final class RemoteConfigStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.RemoteConfigStatus)
      RemoteConfigStatusOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use RemoteConfigStatus.newBuilder() to construct.
    private RemoteConfigStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private RemoteConfigStatus() {
      lastRemoteConfigHash_ = com.google.protobuf.ByteString.EMPTY;
      status_ = 0;
      errorMessage_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new RemoteConfigStatus();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_RemoteConfigStatus_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(RemoteConfigStatus.class, Builder.class);
    }

    public static final int LAST_REMOTE_CONFIG_HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString lastRemoteConfigHash_ =
        com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * The hash of the remote config that was last received by this Agent in the
     * AgentRemoteConfig.config_hash field.
     * The Server SHOULD compare this hash with the config hash
     * it has for the Agent and if the hashes are different the Server MUST include
     * the remote_config field in the response in the ServerToAgent message.
     * </pre>
     *
     * <code>bytes last_remote_config_hash = 1;</code>
     *
     * @return The lastRemoteConfigHash.
     */
    @Override
    public com.google.protobuf.ByteString getLastRemoteConfigHash() {
      return lastRemoteConfigHash_;
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private int status_ = 0;

    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     *
     * @return The enum numeric value on the wire for status.
     */
    @Override
    public int getStatusValue() {
      return status_;
    }

    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     *
     * @return The status.
     */
    @Override
    public RemoteConfigStatuses getStatus() {
      RemoteConfigStatuses result = RemoteConfigStatuses.forNumber(status_);
      return result == null ? RemoteConfigStatuses.UNRECOGNIZED : result;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 3;

    @SuppressWarnings("serial")
    private volatile Object errorMessage_ = "";

    /**
     *
     *
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The errorMessage.
     */
    @Override
    public String getErrorMessage() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The bytes for errorMessage.
     */
    @Override
    public com.google.protobuf.ByteString getErrorMessageBytes() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!lastRemoteConfigHash_.isEmpty()) {
        output.writeBytes(1, lastRemoteConfigHash_);
      }
      if (status_ != RemoteConfigStatuses.RemoteConfigStatuses_UNSET.getNumber()) {
        output.writeEnum(2, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, errorMessage_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!lastRemoteConfigHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, lastRemoteConfigHash_);
      }
      if (status_ != RemoteConfigStatuses.RemoteConfigStatuses_UNSET.getNumber()) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(2, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, errorMessage_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof RemoteConfigStatus)) {
        return super.equals(obj);
      }
      RemoteConfigStatus other = (RemoteConfigStatus) obj;

      if (!getLastRemoteConfigHash().equals(other.getLastRemoteConfigHash())) return false;
      if (status_ != other.status_) return false;
      if (!getErrorMessage().equals(other.getErrorMessage())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + LAST_REMOTE_CONFIG_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getLastRemoteConfigHash().hashCode();
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + status_;
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static RemoteConfigStatus parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static RemoteConfigStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static RemoteConfigStatus parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static RemoteConfigStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static RemoteConfigStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static RemoteConfigStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static RemoteConfigStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static RemoteConfigStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static RemoteConfigStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static RemoteConfigStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static RemoteConfigStatus parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static RemoteConfigStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(RemoteConfigStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.RemoteConfigStatus} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.RemoteConfigStatus)
        RemoteConfigStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_RemoteConfigStatus_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(RemoteConfigStatus.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.RemoteConfigStatus.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        lastRemoteConfigHash_ = com.google.protobuf.ByteString.EMPTY;
        status_ = 0;
        errorMessage_ = "";
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_RemoteConfigStatus_descriptor;
      }

      @Override
      public RemoteConfigStatus getDefaultInstanceForType() {
        return RemoteConfigStatus.getDefaultInstance();
      }

      @Override
      public RemoteConfigStatus build() {
        RemoteConfigStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public RemoteConfigStatus buildPartial() {
        RemoteConfigStatus result = new RemoteConfigStatus(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(RemoteConfigStatus result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.lastRemoteConfigHash_ = lastRemoteConfigHash_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.status_ = status_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.errorMessage_ = errorMessage_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof RemoteConfigStatus) {
          return mergeFrom((RemoteConfigStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(RemoteConfigStatus other) {
        if (other == RemoteConfigStatus.getDefaultInstance()) return this;
        if (other.getLastRemoteConfigHash() != com.google.protobuf.ByteString.EMPTY) {
          setLastRemoteConfigHash(other.getLastRemoteConfigHash());
        }
        if (other.status_ != 0) {
          setStatusValue(other.getStatusValue());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  lastRemoteConfigHash_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 16:
                {
                  status_ = input.readEnum();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
              case 26:
                {
                  errorMessage_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString lastRemoteConfigHash_ =
          com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * The hash of the remote config that was last received by this Agent in the
       * AgentRemoteConfig.config_hash field.
       * The Server SHOULD compare this hash with the config hash
       * it has for the Agent and if the hashes are different the Server MUST include
       * the remote_config field in the response in the ServerToAgent message.
       * </pre>
       *
       * <code>bytes last_remote_config_hash = 1;</code>
       *
       * @return The lastRemoteConfigHash.
       */
      @Override
      public com.google.protobuf.ByteString getLastRemoteConfigHash() {
        return lastRemoteConfigHash_;
      }

      /**
       *
       *
       * <pre>
       * The hash of the remote config that was last received by this Agent in the
       * AgentRemoteConfig.config_hash field.
       * The Server SHOULD compare this hash with the config hash
       * it has for the Agent and if the hashes are different the Server MUST include
       * the remote_config field in the response in the ServerToAgent message.
       * </pre>
       *
       * <code>bytes last_remote_config_hash = 1;</code>
       *
       * @param value The lastRemoteConfigHash to set.
       * @return This builder for chaining.
       */
      public Builder setLastRemoteConfigHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        lastRemoteConfigHash_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The hash of the remote config that was last received by this Agent in the
       * AgentRemoteConfig.config_hash field.
       * The Server SHOULD compare this hash with the config hash
       * it has for the Agent and if the hashes are different the Server MUST include
       * the remote_config field in the response in the ServerToAgent message.
       * </pre>
       *
       * <code>bytes last_remote_config_hash = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearLastRemoteConfigHash() {
        bitField0_ = (bitField0_ & ~0x00000001);
        lastRemoteConfigHash_ = getDefaultInstance().getLastRemoteConfigHash();
        onChanged();
        return this;
      }

      private int status_ = 0;

      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       *
       * @return The enum numeric value on the wire for status.
       */
      @Override
      public int getStatusValue() {
        return status_;
      }

      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       *
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        status_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       *
       * @return The status.
       */
      @Override
      public RemoteConfigStatuses getStatus() {
        RemoteConfigStatuses result = RemoteConfigStatuses.forNumber(status_);
        return result == null ? RemoteConfigStatuses.UNRECOGNIZED : result;
      }

      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       *
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(RemoteConfigStatuses value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        status_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000002);
        status_ = 0;
        onChanged();
        return this;
      }

      private Object errorMessage_ = "";

      /**
       *
       *
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @return The errorMessage.
       */
      public String getErrorMessage() {
        Object ref = errorMessage_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString getErrorMessageBytes() {
        Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        errorMessage_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        errorMessage_ = getDefaultInstance().getErrorMessage();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        errorMessage_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.RemoteConfigStatus)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.RemoteConfigStatus)
    private static final RemoteConfigStatus DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new RemoteConfigStatus();
    }

    public static RemoteConfigStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RemoteConfigStatus> PARSER =
        new com.google.protobuf.AbstractParser<RemoteConfigStatus>() {
          @Override
          public RemoteConfigStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<RemoteConfigStatus> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<RemoteConfigStatus> getParserForType() {
      return PARSER;
    }

    @Override
    public RemoteConfigStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PackageStatusesOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageStatuses)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    int getPackagesCount();

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    boolean containsPackages(String key);

    /** Use {@link #getPackagesMap()} instead. */
    @Deprecated
    java.util.Map<String, PackageStatus> getPackages();

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    java.util.Map<String, PackageStatus> getPackagesMap();

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    /* nullable */
    PackageStatus getPackagesOrDefault(
        String key,
        /* nullable */
        PackageStatus defaultValue);

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    PackageStatus getPackagesOrThrow(String key);

    /**
     *
     *
     * <pre>
     * The aggregate hash of all packages that this Agent previously received from the
     * Server via PackagesAvailable message.
     *
     * The Server SHOULD compare this hash to the aggregate hash of all packages that
     * it has for this Agent and if the hashes are different the Server SHOULD send
     * an PackagesAvailable message to the Agent.
     * </pre>
     *
     * <code>bytes server_provided_all_packages_hash = 2;</code>
     *
     * @return The serverProvidedAllPackagesHash.
     */
    com.google.protobuf.ByteString getServerProvidedAllPackagesHash();

    /**
     *
     *
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The errorMessage.
     */
    String getErrorMessage();

    /**
     *
     *
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString getErrorMessageBytes();
  }

  /**
   *
   *
   * <pre>
   * The PackageStatuses message describes the status of all packages that the Agent
   * has or was offered.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageStatuses}
   */
  public static final class PackageStatuses extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageStatuses)
      PackageStatusesOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use PackageStatuses.newBuilder() to construct.
    private PackageStatuses(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PackageStatuses() {
      serverProvidedAllPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
      errorMessage_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new PackageStatuses();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_PackageStatuses_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetPackages();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_PackageStatuses_fieldAccessorTable
          .ensureFieldAccessorsInitialized(PackageStatuses.class, Builder.class);
    }

    public static final int PACKAGES_FIELD_NUMBER = 1;

    private static final class PackagesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, PackageStatus> defaultEntry =
          com.google.protobuf.MapEntry.<String, PackageStatus>newDefaultInstance(
              Opamp.internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              PackageStatus.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, PackageStatus> packages_;

    private com.google.protobuf.MapField<String, PackageStatus> internalGetPackages() {
      if (packages_ == null) {
        return com.google.protobuf.MapField.emptyMapField(PackagesDefaultEntryHolder.defaultEntry);
      }
      return packages_;
    }

    public int getPackagesCount() {
      return internalGetPackages().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @Override
    public boolean containsPackages(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetPackages().getMap().containsKey(key);
    }

    /** Use {@link #getPackagesMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, PackageStatus> getPackages() {
      return getPackagesMap();
    }

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @Override
    public java.util.Map<String, PackageStatus> getPackagesMap() {
      return internalGetPackages().getMap();
    }

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @Override
    public /* nullable */ PackageStatus getPackagesOrDefault(
        String key,
        /* nullable */
        PackageStatus defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, PackageStatus> map = internalGetPackages().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @Override
    public PackageStatus getPackagesOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, PackageStatus> map = internalGetPackages().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SERVER_PROVIDED_ALL_PACKAGES_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString serverProvidedAllPackagesHash_ =
        com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * The aggregate hash of all packages that this Agent previously received from the
     * Server via PackagesAvailable message.
     *
     * The Server SHOULD compare this hash to the aggregate hash of all packages that
     * it has for this Agent and if the hashes are different the Server SHOULD send
     * an PackagesAvailable message to the Agent.
     * </pre>
     *
     * <code>bytes server_provided_all_packages_hash = 2;</code>
     *
     * @return The serverProvidedAllPackagesHash.
     */
    @Override
    public com.google.protobuf.ByteString getServerProvidedAllPackagesHash() {
      return serverProvidedAllPackagesHash_;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 3;

    @SuppressWarnings("serial")
    private volatile Object errorMessage_ = "";

    /**
     *
     *
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The errorMessage.
     */
    @Override
    public String getErrorMessage() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     *
     * @return The bytes for errorMessage.
     */
    @Override
    public com.google.protobuf.ByteString getErrorMessageBytes() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetPackages(), PackagesDefaultEntryHolder.defaultEntry, 1);
      if (!serverProvidedAllPackagesHash_.isEmpty()) {
        output.writeBytes(2, serverProvidedAllPackagesHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, errorMessage_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<String, PackageStatus> entry :
          internalGetPackages().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, PackageStatus> packages__ =
            PackagesDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, packages__);
      }
      if (!serverProvidedAllPackagesHash_.isEmpty()) {
        size +=
            com.google.protobuf.CodedOutputStream.computeBytesSize(
                2, serverProvidedAllPackagesHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, errorMessage_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof PackageStatuses)) {
        return super.equals(obj);
      }
      PackageStatuses other = (PackageStatuses) obj;

      if (!internalGetPackages().equals(other.internalGetPackages())) return false;
      if (!getServerProvidedAllPackagesHash().equals(other.getServerProvidedAllPackagesHash()))
        return false;
      if (!getErrorMessage().equals(other.getErrorMessage())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetPackages().getMap().isEmpty()) {
        hash = (37 * hash) + PACKAGES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPackages().hashCode();
      }
      hash = (37 * hash) + SERVER_PROVIDED_ALL_PACKAGES_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getServerProvidedAllPackagesHash().hashCode();
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PackageStatuses parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageStatuses parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageStatuses parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageStatuses parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageStatuses parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageStatuses parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageStatuses parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageStatuses parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageStatuses parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static PackageStatuses parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageStatuses parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageStatuses parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(PackageStatuses prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * The PackageStatuses message describes the status of all packages that the Agent
     * has or was offered.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageStatuses}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageStatuses)
        PackageStatusesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_PackageStatuses_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetPackages();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutablePackages();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_PackageStatuses_fieldAccessorTable
            .ensureFieldAccessorsInitialized(PackageStatuses.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageStatuses.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutablePackages().clear();
        serverProvidedAllPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
        errorMessage_ = "";
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_PackageStatuses_descriptor;
      }

      @Override
      public PackageStatuses getDefaultInstanceForType() {
        return PackageStatuses.getDefaultInstance();
      }

      @Override
      public PackageStatuses build() {
        PackageStatuses result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PackageStatuses buildPartial() {
        PackageStatuses result = new PackageStatuses(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(PackageStatuses result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.packages_ = internalGetPackages().build(PackagesDefaultEntryHolder.defaultEntry);
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.serverProvidedAllPackagesHash_ = serverProvidedAllPackagesHash_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.errorMessage_ = errorMessage_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PackageStatuses) {
          return mergeFrom((PackageStatuses) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PackageStatuses other) {
        if (other == PackageStatuses.getDefaultInstance()) return this;
        internalGetMutablePackages().mergeFrom(other.internalGetPackages());
        bitField0_ |= 0x00000001;
        if (other.getServerProvidedAllPackagesHash() != com.google.protobuf.ByteString.EMPTY) {
          setServerProvidedAllPackagesHash(other.getServerProvidedAllPackagesHash());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  com.google.protobuf.MapEntry<String, PackageStatus> packages__ =
                      input.readMessage(
                          PackagesDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutablePackages()
                      .ensureBuilderMap()
                      .put(packages__.getKey(), packages__.getValue());
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  serverProvidedAllPackagesHash_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  errorMessage_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private static final class PackagesConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, PackageStatusOrBuilder, PackageStatus> {
        @Override
        public PackageStatus build(PackageStatusOrBuilder val) {
          if (val instanceof PackageStatus) {
            return (PackageStatus) val;
          }
          return ((PackageStatus.Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, PackageStatus> defaultEntry() {
          return PackagesDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final PackagesConverter packagesConverter = new PackagesConverter();

      private com.google.protobuf.MapFieldBuilder<
              String, PackageStatusOrBuilder, PackageStatus, PackageStatus.Builder>
          packages_;

      private com.google.protobuf.MapFieldBuilder<
              String, PackageStatusOrBuilder, PackageStatus, PackageStatus.Builder>
          internalGetPackages() {
        if (packages_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(packagesConverter);
        }
        return packages_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String, PackageStatusOrBuilder, PackageStatus, PackageStatus.Builder>
          internalGetMutablePackages() {
        if (packages_ == null) {
          packages_ = new com.google.protobuf.MapFieldBuilder<>(packagesConverter);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return packages_;
      }

      public int getPackagesCount() {
        return internalGetPackages().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @Override
      public boolean containsPackages(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetPackages().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getPackagesMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, PackageStatus> getPackages() {
        return getPackagesMap();
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @Override
      public java.util.Map<String, PackageStatus> getPackagesMap() {
        return internalGetPackages().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @Override
      public /* nullable */ PackageStatus getPackagesOrDefault(
          String key,
          /* nullable */
          PackageStatus defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, PackageStatusOrBuilder> map =
            internalGetMutablePackages().ensureBuilderMap();
        return map.containsKey(key) ? packagesConverter.build(map.get(key)) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @Override
      public PackageStatus getPackagesOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, PackageStatusOrBuilder> map =
            internalGetMutablePackages().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return packagesConverter.build(map.get(key));
      }

      public Builder clearPackages() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutablePackages().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      public Builder removePackages(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutablePackages().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, PackageStatus> getMutablePackages() {
        bitField0_ |= 0x00000001;
        return internalGetMutablePackages().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      public Builder putPackages(String key, PackageStatus value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutablePackages().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      public Builder putAllPackages(java.util.Map<String, PackageStatus> values) {
        for (java.util.Map.Entry<String, PackageStatus> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutablePackages().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      public PackageStatus.Builder putPackagesBuilderIfAbsent(String key) {
        java.util.Map<String, PackageStatusOrBuilder> builderMap =
            internalGetMutablePackages().ensureBuilderMap();
        PackageStatusOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = PackageStatus.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof PackageStatus) {
          entry = ((PackageStatus) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (PackageStatus.Builder) entry;
      }

      private com.google.protobuf.ByteString serverProvidedAllPackagesHash_ =
          com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * The aggregate hash of all packages that this Agent previously received from the
       * Server via PackagesAvailable message.
       *
       * The Server SHOULD compare this hash to the aggregate hash of all packages that
       * it has for this Agent and if the hashes are different the Server SHOULD send
       * an PackagesAvailable message to the Agent.
       * </pre>
       *
       * <code>bytes server_provided_all_packages_hash = 2;</code>
       *
       * @return The serverProvidedAllPackagesHash.
       */
      @Override
      public com.google.protobuf.ByteString getServerProvidedAllPackagesHash() {
        return serverProvidedAllPackagesHash_;
      }

      /**
       *
       *
       * <pre>
       * The aggregate hash of all packages that this Agent previously received from the
       * Server via PackagesAvailable message.
       *
       * The Server SHOULD compare this hash to the aggregate hash of all packages that
       * it has for this Agent and if the hashes are different the Server SHOULD send
       * an PackagesAvailable message to the Agent.
       * </pre>
       *
       * <code>bytes server_provided_all_packages_hash = 2;</code>
       *
       * @param value The serverProvidedAllPackagesHash to set.
       * @return This builder for chaining.
       */
      public Builder setServerProvidedAllPackagesHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        serverProvidedAllPackagesHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The aggregate hash of all packages that this Agent previously received from the
       * Server via PackagesAvailable message.
       *
       * The Server SHOULD compare this hash to the aggregate hash of all packages that
       * it has for this Agent and if the hashes are different the Server SHOULD send
       * an PackagesAvailable message to the Agent.
       * </pre>
       *
       * <code>bytes server_provided_all_packages_hash = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearServerProvidedAllPackagesHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        serverProvidedAllPackagesHash_ = getDefaultInstance().getServerProvidedAllPackagesHash();
        onChanged();
        return this;
      }

      private Object errorMessage_ = "";

      /**
       *
       *
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @return The errorMessage.
       */
      public String getErrorMessage() {
        Object ref = errorMessage_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString getErrorMessageBytes() {
        Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        errorMessage_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        errorMessage_ = getDefaultInstance().getErrorMessage();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       *
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        errorMessage_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageStatuses)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageStatuses)
    private static final PackageStatuses DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new PackageStatuses();
    }

    public static PackageStatuses getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageStatuses> PARSER =
        new com.google.protobuf.AbstractParser<PackageStatuses>() {
          @Override
          public PackageStatuses parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<PackageStatuses> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PackageStatuses> getParserForType() {
      return PARSER;
    }

    @Override
    public PackageStatuses getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PackageStatusOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     *
     * @return The name.
     */
    String getName();

    /**
     *
     *
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     *
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString getNameBytes();

    /**
     *
     *
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     *
     * @return The agentHasVersion.
     */
    String getAgentHasVersion();

    /**
     *
     *
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     *
     * @return The bytes for agentHasVersion.
     */
    com.google.protobuf.ByteString getAgentHasVersionBytes();

    /**
     *
     *
     * <pre>
     * The hash of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case for
     * example if the package was offered by the Server but failed to install and the
     * Agent did not have this package previously.
     * </pre>
     *
     * <code>bytes agent_has_hash = 3;</code>
     *
     * @return The agentHasHash.
     */
    com.google.protobuf.ByteString getAgentHasHash();

    /**
     *
     *
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     *
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     *
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     *
     * @return The serverOfferedVersion.
     */
    String getServerOfferedVersion();

    /**
     *
     *
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     *
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     *
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     *
     * @return The bytes for serverOfferedVersion.
     */
    com.google.protobuf.ByteString getServerOfferedVersionBytes();

    /**
     *
     *
     * <pre>
     * The hash of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier
     * offer from the Server to install this package.
     *
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     *
     * Note that it is possible for both agent_has_hash and server_offered_hash
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the
     * Server offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>bytes server_offered_hash = 5;</code>
     *
     * @return The serverOfferedHash.
     */
    com.google.protobuf.ByteString getServerOfferedHash();

    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     *
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();

    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     *
     * @return The status.
     */
    PackageStatusEnum getStatus();

    /**
     *
     *
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     *
     * @return The errorMessage.
     */
    String getErrorMessage();

    /**
     *
     *
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     *
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString getErrorMessageBytes();

    /**
     *
     *
     * <pre>
     * Optional details that may be of interest to a user.
     * Should only be set if status is Downloading.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
     *
     * @return Whether the downloadDetails field is set.
     */
    boolean hasDownloadDetails();

    /**
     *
     *
     * <pre>
     * Optional details that may be of interest to a user.
     * Should only be set if status is Downloading.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
     *
     * @return The downloadDetails.
     */
    PackageDownloadDetails getDownloadDetails();

    /**
     *
     *
     * <pre>
     * Optional details that may be of interest to a user.
     * Should only be set if status is Downloading.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
     */
    PackageDownloadDetailsOrBuilder getDownloadDetailsOrBuilder();
  }

  /**
   *
   *
   * <pre>
   * The status of a single package.
   * Status: [Beta]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageStatus}
   */
  public static final class PackageStatus extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageStatus)
      PackageStatusOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use PackageStatus.newBuilder() to construct.
    private PackageStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PackageStatus() {
      name_ = "";
      agentHasVersion_ = "";
      agentHasHash_ = com.google.protobuf.ByteString.EMPTY;
      serverOfferedVersion_ = "";
      serverOfferedHash_ = com.google.protobuf.ByteString.EMPTY;
      status_ = 0;
      errorMessage_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new PackageStatus();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_PackageStatus_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_PackageStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(PackageStatus.class, Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object name_ = "";

    /**
     *
     *
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     *
     * @return The name.
     */
    @Override
    public String getName() {
      Object ref = name_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     *
     * @return The bytes for name.
     */
    @Override
    public com.google.protobuf.ByteString getNameBytes() {
      Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENT_HAS_VERSION_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private volatile Object agentHasVersion_ = "";

    /**
     *
     *
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     *
     * @return The agentHasVersion.
     */
    @Override
    public String getAgentHasVersion() {
      Object ref = agentHasVersion_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        agentHasVersion_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     *
     * @return The bytes for agentHasVersion.
     */
    @Override
    public com.google.protobuf.ByteString getAgentHasVersionBytes() {
      Object ref = agentHasVersion_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        agentHasVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENT_HAS_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString agentHasHash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * The hash of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case for
     * example if the package was offered by the Server but failed to install and the
     * Agent did not have this package previously.
     * </pre>
     *
     * <code>bytes agent_has_hash = 3;</code>
     *
     * @return The agentHasHash.
     */
    @Override
    public com.google.protobuf.ByteString getAgentHasHash() {
      return agentHasHash_;
    }

    public static final int SERVER_OFFERED_VERSION_FIELD_NUMBER = 4;

    @SuppressWarnings("serial")
    private volatile Object serverOfferedVersion_ = "";

    /**
     *
     *
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     *
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     *
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     *
     * @return The serverOfferedVersion.
     */
    @Override
    public String getServerOfferedVersion() {
      Object ref = serverOfferedVersion_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        serverOfferedVersion_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     *
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     *
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     *
     * @return The bytes for serverOfferedVersion.
     */
    @Override
    public com.google.protobuf.ByteString getServerOfferedVersionBytes() {
      Object ref = serverOfferedVersion_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        serverOfferedVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVER_OFFERED_HASH_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString serverOfferedHash_ =
        com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * The hash of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier
     * offer from the Server to install this package.
     *
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     *
     * Note that it is possible for both agent_has_hash and server_offered_hash
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the
     * Server offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>bytes server_offered_hash = 5;</code>
     *
     * @return The serverOfferedHash.
     */
    @Override
    public com.google.protobuf.ByteString getServerOfferedHash() {
      return serverOfferedHash_;
    }

    public static final int STATUS_FIELD_NUMBER = 6;
    private int status_ = 0;

    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     *
     * @return The enum numeric value on the wire for status.
     */
    @Override
    public int getStatusValue() {
      return status_;
    }

    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     *
     * @return The status.
     */
    @Override
    public PackageStatusEnum getStatus() {
      PackageStatusEnum result = PackageStatusEnum.forNumber(status_);
      return result == null ? PackageStatusEnum.UNRECOGNIZED : result;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 7;

    @SuppressWarnings("serial")
    private volatile Object errorMessage_ = "";

    /**
     *
     *
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     *
     * @return The errorMessage.
     */
    @Override
    public String getErrorMessage() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     *
     * @return The bytes for errorMessage.
     */
    @Override
    public com.google.protobuf.ByteString getErrorMessageBytes() {
      Object ref = errorMessage_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DOWNLOAD_DETAILS_FIELD_NUMBER = 8;
    private PackageDownloadDetails downloadDetails_;

    /**
     *
     *
     * <pre>
     * Optional details that may be of interest to a user.
     * Should only be set if status is Downloading.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
     *
     * @return Whether the downloadDetails field is set.
     */
    @Override
    public boolean hasDownloadDetails() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Optional details that may be of interest to a user.
     * Should only be set if status is Downloading.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
     *
     * @return The downloadDetails.
     */
    @Override
    public PackageDownloadDetails getDownloadDetails() {
      return downloadDetails_ == null
          ? PackageDownloadDetails.getDefaultInstance()
          : downloadDetails_;
    }

    /**
     *
     *
     * <pre>
     * Optional details that may be of interest to a user.
     * Should only be set if status is Downloading.
     * Status: [Development]
     * </pre>
     *
     * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
     */
    @Override
    public PackageDownloadDetailsOrBuilder getDownloadDetailsOrBuilder() {
      return downloadDetails_ == null
          ? PackageDownloadDetails.getDefaultInstance()
          : downloadDetails_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agentHasVersion_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, agentHasVersion_);
      }
      if (!agentHasHash_.isEmpty()) {
        output.writeBytes(3, agentHasHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverOfferedVersion_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, serverOfferedVersion_);
      }
      if (!serverOfferedHash_.isEmpty()) {
        output.writeBytes(5, serverOfferedHash_);
      }
      if (status_ != PackageStatusEnum.PackageStatusEnum_Installed.getNumber()) {
        output.writeEnum(6, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, errorMessage_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(8, getDownloadDetails());
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agentHasVersion_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, agentHasVersion_);
      }
      if (!agentHasHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, agentHasHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverOfferedVersion_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, serverOfferedVersion_);
      }
      if (!serverOfferedHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(5, serverOfferedHash_);
      }
      if (status_ != PackageStatusEnum.PackageStatusEnum_Installed.getNumber()) {
        size += com.google.protobuf.CodedOutputStream.computeEnumSize(6, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, errorMessage_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(8, getDownloadDetails());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof PackageStatus)) {
        return super.equals(obj);
      }
      PackageStatus other = (PackageStatus) obj;

      if (!getName().equals(other.getName())) return false;
      if (!getAgentHasVersion().equals(other.getAgentHasVersion())) return false;
      if (!getAgentHasHash().equals(other.getAgentHasHash())) return false;
      if (!getServerOfferedVersion().equals(other.getServerOfferedVersion())) return false;
      if (!getServerOfferedHash().equals(other.getServerOfferedHash())) return false;
      if (status_ != other.status_) return false;
      if (!getErrorMessage().equals(other.getErrorMessage())) return false;
      if (hasDownloadDetails() != other.hasDownloadDetails()) return false;
      if (hasDownloadDetails()) {
        if (!getDownloadDetails().equals(other.getDownloadDetails())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + AGENT_HAS_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getAgentHasVersion().hashCode();
      hash = (37 * hash) + AGENT_HAS_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getAgentHasHash().hashCode();
      hash = (37 * hash) + SERVER_OFFERED_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getServerOfferedVersion().hashCode();
      hash = (37 * hash) + SERVER_OFFERED_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getServerOfferedHash().hashCode();
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + status_;
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      if (hasDownloadDetails()) {
        hash = (37 * hash) + DOWNLOAD_DETAILS_FIELD_NUMBER;
        hash = (53 * hash) + getDownloadDetails().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PackageStatus parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageStatus parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageStatus parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageStatus parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageStatus parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageStatus parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static PackageStatus parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageStatus parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(PackageStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * The status of a single package.
     * Status: [Beta]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageStatus}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageStatus)
        PackageStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_PackageStatus_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_PackageStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(PackageStatus.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getDownloadDetailsFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        agentHasVersion_ = "";
        agentHasHash_ = com.google.protobuf.ByteString.EMPTY;
        serverOfferedVersion_ = "";
        serverOfferedHash_ = com.google.protobuf.ByteString.EMPTY;
        status_ = 0;
        errorMessage_ = "";
        downloadDetails_ = null;
        if (downloadDetailsBuilder_ != null) {
          downloadDetailsBuilder_.dispose();
          downloadDetailsBuilder_ = null;
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_PackageStatus_descriptor;
      }

      @Override
      public PackageStatus getDefaultInstanceForType() {
        return PackageStatus.getDefaultInstance();
      }

      @Override
      public PackageStatus build() {
        PackageStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PackageStatus buildPartial() {
        PackageStatus result = new PackageStatus(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(PackageStatus result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.agentHasVersion_ = agentHasVersion_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.agentHasHash_ = agentHasHash_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.serverOfferedVersion_ = serverOfferedVersion_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.serverOfferedHash_ = serverOfferedHash_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.status_ = status_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.errorMessage_ = errorMessage_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.downloadDetails_ =
              downloadDetailsBuilder_ == null ? downloadDetails_ : downloadDetailsBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PackageStatus) {
          return mergeFrom((PackageStatus) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PackageStatus other) {
        if (other == PackageStatus.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getAgentHasVersion().isEmpty()) {
          agentHasVersion_ = other.agentHasVersion_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.getAgentHasHash() != com.google.protobuf.ByteString.EMPTY) {
          setAgentHasHash(other.getAgentHasHash());
        }
        if (!other.getServerOfferedVersion().isEmpty()) {
          serverOfferedVersion_ = other.serverOfferedVersion_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.getServerOfferedHash() != com.google.protobuf.ByteString.EMPTY) {
          setServerOfferedHash(other.getServerOfferedHash());
        }
        if (other.status_ != 0) {
          setStatusValue(other.getStatusValue());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (other.hasDownloadDetails()) {
          mergeDownloadDetails(other.getDownloadDetails());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  name_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  agentHasVersion_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  agentHasHash_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              case 34:
                {
                  serverOfferedVersion_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 34
              case 42:
                {
                  serverOfferedHash_ = input.readBytes();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 42
              case 48:
                {
                  status_ = input.readEnum();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
              case 58:
                {
                  errorMessage_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 58
              case 66:
                {
                  input.readMessage(
                      getDownloadDetailsFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000080;
                  break;
                } // case 66
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object name_ = "";

      /**
       *
       *
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       *
       * @return The name.
       */
      public String getName() {
        Object ref = name_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       *
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString getNameBytes() {
        Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       *
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       *
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Object agentHasVersion_ = "";

      /**
       *
       *
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       *
       * @return The agentHasVersion.
       */
      public String getAgentHasVersion() {
        Object ref = agentHasVersion_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          agentHasVersion_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       *
       * @return The bytes for agentHasVersion.
       */
      public com.google.protobuf.ByteString getAgentHasVersionBytes() {
        Object ref = agentHasVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          agentHasVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       *
       * @param value The agentHasVersion to set.
       * @return This builder for chaining.
       */
      public Builder setAgentHasVersion(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        agentHasVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearAgentHasVersion() {
        agentHasVersion_ = getDefaultInstance().getAgentHasVersion();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       *
       * @param value The bytes for agentHasVersion to set.
       * @return This builder for chaining.
       */
      public Builder setAgentHasVersionBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        agentHasVersion_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString agentHasHash_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * The hash of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case for
       * example if the package was offered by the Server but failed to install and the
       * Agent did not have this package previously.
       * </pre>
       *
       * <code>bytes agent_has_hash = 3;</code>
       *
       * @return The agentHasHash.
       */
      @Override
      public com.google.protobuf.ByteString getAgentHasHash() {
        return agentHasHash_;
      }

      /**
       *
       *
       * <pre>
       * The hash of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case for
       * example if the package was offered by the Server but failed to install and the
       * Agent did not have this package previously.
       * </pre>
       *
       * <code>bytes agent_has_hash = 3;</code>
       *
       * @param value The agentHasHash to set.
       * @return This builder for chaining.
       */
      public Builder setAgentHasHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        agentHasHash_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The hash of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case for
       * example if the package was offered by the Server but failed to install and the
       * Agent did not have this package previously.
       * </pre>
       *
       * <code>bytes agent_has_hash = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearAgentHasHash() {
        bitField0_ = (bitField0_ & ~0x00000004);
        agentHasHash_ = getDefaultInstance().getAgentHasHash();
        onChanged();
        return this;
      }

      private Object serverOfferedVersion_ = "";

      /**
       *
       *
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       *
       * @return The serverOfferedVersion.
       */
      public String getServerOfferedVersion() {
        Object ref = serverOfferedVersion_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          serverOfferedVersion_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       *
       * @return The bytes for serverOfferedVersion.
       */
      public com.google.protobuf.ByteString getServerOfferedVersionBytes() {
        Object ref = serverOfferedVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          serverOfferedVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       *
       * @param value The serverOfferedVersion to set.
       * @return This builder for chaining.
       */
      public Builder setServerOfferedVersion(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        serverOfferedVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearServerOfferedVersion() {
        serverOfferedVersion_ = getDefaultInstance().getServerOfferedVersion();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       *
       * @param value The bytes for serverOfferedVersion to set.
       * @return This builder for chaining.
       */
      public Builder setServerOfferedVersionBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        serverOfferedVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString serverOfferedHash_ =
          com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * The hash of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier
       * offer from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_hash and server_offered_hash
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the
       * Server offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>bytes server_offered_hash = 5;</code>
       *
       * @return The serverOfferedHash.
       */
      @Override
      public com.google.protobuf.ByteString getServerOfferedHash() {
        return serverOfferedHash_;
      }

      /**
       *
       *
       * <pre>
       * The hash of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier
       * offer from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_hash and server_offered_hash
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the
       * Server offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>bytes server_offered_hash = 5;</code>
       *
       * @param value The serverOfferedHash to set.
       * @return This builder for chaining.
       */
      public Builder setServerOfferedHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        serverOfferedHash_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The hash of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier
       * offer from the Server to install this package.
       *
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       *
       * Note that it is possible for both agent_has_hash and server_offered_hash
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the
       * Server offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>bytes server_offered_hash = 5;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearServerOfferedHash() {
        bitField0_ = (bitField0_ & ~0x00000010);
        serverOfferedHash_ = getDefaultInstance().getServerOfferedHash();
        onChanged();
        return this;
      }

      private int status_ = 0;

      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       *
       * @return The enum numeric value on the wire for status.
       */
      @Override
      public int getStatusValue() {
        return status_;
      }

      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       *
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        status_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       *
       * @return The status.
       */
      @Override
      public PackageStatusEnum getStatus() {
        PackageStatusEnum result = PackageStatusEnum.forNumber(status_);
        return result == null ? PackageStatusEnum.UNRECOGNIZED : result;
      }

      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       *
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(PackageStatusEnum value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000020;
        status_ = value.getNumber();
        onChanged();
        return this;
      }

      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        bitField0_ = (bitField0_ & ~0x00000020);
        status_ = 0;
        onChanged();
        return this;
      }

      private Object errorMessage_ = "";

      /**
       *
       *
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       *
       * @return The errorMessage.
       */
      public String getErrorMessage() {
        Object ref = errorMessage_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       *
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString getErrorMessageBytes() {
        Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       *
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        errorMessage_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        errorMessage_ = getDefaultInstance().getErrorMessage();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       *
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        errorMessage_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private PackageDownloadDetails downloadDetails_;
      private com.google.protobuf.SingleFieldBuilderV3<
              PackageDownloadDetails,
              PackageDownloadDetails.Builder,
              PackageDownloadDetailsOrBuilder>
          downloadDetailsBuilder_;

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       *
       * @return Whether the downloadDetails field is set.
       */
      public boolean hasDownloadDetails() {
        return ((bitField0_ & 0x00000080) != 0);
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       *
       * @return The downloadDetails.
       */
      public PackageDownloadDetails getDownloadDetails() {
        if (downloadDetailsBuilder_ == null) {
          return downloadDetails_ == null
              ? PackageDownloadDetails.getDefaultInstance()
              : downloadDetails_;
        } else {
          return downloadDetailsBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      public Builder setDownloadDetails(PackageDownloadDetails value) {
        if (downloadDetailsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          downloadDetails_ = value;
        } else {
          downloadDetailsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      public Builder setDownloadDetails(PackageDownloadDetails.Builder builderForValue) {
        if (downloadDetailsBuilder_ == null) {
          downloadDetails_ = builderForValue.build();
        } else {
          downloadDetailsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      public Builder mergeDownloadDetails(PackageDownloadDetails value) {
        if (downloadDetailsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)
              && downloadDetails_ != null
              && downloadDetails_ != PackageDownloadDetails.getDefaultInstance()) {
            getDownloadDetailsBuilder().mergeFrom(value);
          } else {
            downloadDetails_ = value;
          }
        } else {
          downloadDetailsBuilder_.mergeFrom(value);
        }
        if (downloadDetails_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      public Builder clearDownloadDetails() {
        bitField0_ = (bitField0_ & ~0x00000080);
        downloadDetails_ = null;
        if (downloadDetailsBuilder_ != null) {
          downloadDetailsBuilder_.dispose();
          downloadDetailsBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      public PackageDownloadDetails.Builder getDownloadDetailsBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getDownloadDetailsFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      public PackageDownloadDetailsOrBuilder getDownloadDetailsOrBuilder() {
        if (downloadDetailsBuilder_ != null) {
          return downloadDetailsBuilder_.getMessageOrBuilder();
        } else {
          return downloadDetails_ == null
              ? PackageDownloadDetails.getDefaultInstance()
              : downloadDetails_;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional details that may be of interest to a user.
       * Should only be set if status is Downloading.
       * Status: [Development]
       * </pre>
       *
       * <code>.opamp.proto.PackageDownloadDetails download_details = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              PackageDownloadDetails,
              PackageDownloadDetails.Builder,
              PackageDownloadDetailsOrBuilder>
          getDownloadDetailsFieldBuilder() {
        if (downloadDetailsBuilder_ == null) {
          downloadDetailsBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  PackageDownloadDetails,
                  PackageDownloadDetails.Builder,
                  PackageDownloadDetailsOrBuilder>(
                  getDownloadDetails(), getParentForChildren(), isClean());
          downloadDetails_ = null;
        }
        return downloadDetailsBuilder_;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageStatus)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageStatus)
    private static final PackageStatus DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new PackageStatus();
    }

    public static PackageStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageStatus> PARSER =
        new com.google.protobuf.AbstractParser<PackageStatus>() {
          @Override
          public PackageStatus parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<PackageStatus> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PackageStatus> getParserForType() {
      return PARSER;
    }

    @Override
    public PackageStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface PackageDownloadDetailsOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageDownloadDetails)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * The package download progress as a percentage.
     * </pre>
     *
     * <code>double download_percent = 1;</code>
     *
     * @return The downloadPercent.
     */
    double getDownloadPercent();

    /**
     *
     *
     * <pre>
     * The current package download rate in bytes per second.
     * </pre>
     *
     * <code>uint64 download_bytes_per_second = 2;</code>
     *
     * @return The downloadBytesPerSecond.
     */
    long getDownloadBytesPerSecond();
  }

  /**
   *
   *
   * <pre>
   * Additional details that an agent can use to describe an in-progress package download.
   * Status: [Development]
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageDownloadDetails}
   */
  public static final class PackageDownloadDetails extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageDownloadDetails)
      PackageDownloadDetailsOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use PackageDownloadDetails.newBuilder() to construct.
    private PackageDownloadDetails(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private PackageDownloadDetails() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new PackageDownloadDetails();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_PackageDownloadDetails_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_PackageDownloadDetails_fieldAccessorTable
          .ensureFieldAccessorsInitialized(PackageDownloadDetails.class, Builder.class);
    }

    public static final int DOWNLOAD_PERCENT_FIELD_NUMBER = 1;
    private double downloadPercent_ = 0D;

    /**
     *
     *
     * <pre>
     * The package download progress as a percentage.
     * </pre>
     *
     * <code>double download_percent = 1;</code>
     *
     * @return The downloadPercent.
     */
    @Override
    public double getDownloadPercent() {
      return downloadPercent_;
    }

    public static final int DOWNLOAD_BYTES_PER_SECOND_FIELD_NUMBER = 2;
    private long downloadBytesPerSecond_ = 0L;

    /**
     *
     *
     * <pre>
     * The current package download rate in bytes per second.
     * </pre>
     *
     * <code>uint64 download_bytes_per_second = 2;</code>
     *
     * @return The downloadBytesPerSecond.
     */
    @Override
    public long getDownloadBytesPerSecond() {
      return downloadBytesPerSecond_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (Double.doubleToRawLongBits(downloadPercent_) != 0) {
        output.writeDouble(1, downloadPercent_);
      }
      if (downloadBytesPerSecond_ != 0L) {
        output.writeUInt64(2, downloadBytesPerSecond_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (Double.doubleToRawLongBits(downloadPercent_) != 0) {
        size += com.google.protobuf.CodedOutputStream.computeDoubleSize(1, downloadPercent_);
      }
      if (downloadBytesPerSecond_ != 0L) {
        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(2, downloadBytesPerSecond_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof PackageDownloadDetails)) {
        return super.equals(obj);
      }
      PackageDownloadDetails other = (PackageDownloadDetails) obj;

      if (Double.doubleToLongBits(getDownloadPercent())
          != Double.doubleToLongBits(other.getDownloadPercent())) return false;
      if (getDownloadBytesPerSecond() != other.getDownloadBytesPerSecond()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DOWNLOAD_PERCENT_FIELD_NUMBER;
      hash =
          (53 * hash)
              + com.google.protobuf.Internal.hashLong(
                  Double.doubleToLongBits(getDownloadPercent()));
      hash = (37 * hash) + DOWNLOAD_BYTES_PER_SECOND_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getDownloadBytesPerSecond());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PackageDownloadDetails parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageDownloadDetails parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageDownloadDetails parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageDownloadDetails parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageDownloadDetails parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static PackageDownloadDetails parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static PackageDownloadDetails parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageDownloadDetails parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageDownloadDetails parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static PackageDownloadDetails parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static PackageDownloadDetails parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static PackageDownloadDetails parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(PackageDownloadDetails prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Additional details that an agent can use to describe an in-progress package download.
     * Status: [Development]
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageDownloadDetails}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageDownloadDetails)
        PackageDownloadDetailsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_PackageDownloadDetails_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_PackageDownloadDetails_fieldAccessorTable
            .ensureFieldAccessorsInitialized(PackageDownloadDetails.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageDownloadDetails.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        downloadPercent_ = 0D;
        downloadBytesPerSecond_ = 0L;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_PackageDownloadDetails_descriptor;
      }

      @Override
      public PackageDownloadDetails getDefaultInstanceForType() {
        return PackageDownloadDetails.getDefaultInstance();
      }

      @Override
      public PackageDownloadDetails build() {
        PackageDownloadDetails result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PackageDownloadDetails buildPartial() {
        PackageDownloadDetails result = new PackageDownloadDetails(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(PackageDownloadDetails result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.downloadPercent_ = downloadPercent_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.downloadBytesPerSecond_ = downloadBytesPerSecond_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PackageDownloadDetails) {
          return mergeFrom((PackageDownloadDetails) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PackageDownloadDetails other) {
        if (other == PackageDownloadDetails.getDefaultInstance()) return this;
        if (other.getDownloadPercent() != 0D) {
          setDownloadPercent(other.getDownloadPercent());
        }
        if (other.getDownloadBytesPerSecond() != 0L) {
          setDownloadBytesPerSecond(other.getDownloadBytesPerSecond());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 9:
                {
                  downloadPercent_ = input.readDouble();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 9
              case 16:
                {
                  downloadBytesPerSecond_ = input.readUInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private double downloadPercent_;

      /**
       *
       *
       * <pre>
       * The package download progress as a percentage.
       * </pre>
       *
       * <code>double download_percent = 1;</code>
       *
       * @return The downloadPercent.
       */
      @Override
      public double getDownloadPercent() {
        return downloadPercent_;
      }

      /**
       *
       *
       * <pre>
       * The package download progress as a percentage.
       * </pre>
       *
       * <code>double download_percent = 1;</code>
       *
       * @param value The downloadPercent to set.
       * @return This builder for chaining.
       */
      public Builder setDownloadPercent(double value) {

        downloadPercent_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The package download progress as a percentage.
       * </pre>
       *
       * <code>double download_percent = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearDownloadPercent() {
        bitField0_ = (bitField0_ & ~0x00000001);
        downloadPercent_ = 0D;
        onChanged();
        return this;
      }

      private long downloadBytesPerSecond_;

      /**
       *
       *
       * <pre>
       * The current package download rate in bytes per second.
       * </pre>
       *
       * <code>uint64 download_bytes_per_second = 2;</code>
       *
       * @return The downloadBytesPerSecond.
       */
      @Override
      public long getDownloadBytesPerSecond() {
        return downloadBytesPerSecond_;
      }

      /**
       *
       *
       * <pre>
       * The current package download rate in bytes per second.
       * </pre>
       *
       * <code>uint64 download_bytes_per_second = 2;</code>
       *
       * @param value The downloadBytesPerSecond to set.
       * @return This builder for chaining.
       */
      public Builder setDownloadBytesPerSecond(long value) {

        downloadBytesPerSecond_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * The current package download rate in bytes per second.
       * </pre>
       *
       * <code>uint64 download_bytes_per_second = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearDownloadBytesPerSecond() {
        bitField0_ = (bitField0_ & ~0x00000002);
        downloadBytesPerSecond_ = 0L;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageDownloadDetails)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageDownloadDetails)
    private static final PackageDownloadDetails DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new PackageDownloadDetails();
    }

    public static PackageDownloadDetails getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageDownloadDetails> PARSER =
        new com.google.protobuf.AbstractParser<PackageDownloadDetails>() {
          @Override
          public PackageDownloadDetails parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<PackageDownloadDetails> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PackageDownloadDetails> getParserForType() {
      return PARSER;
    }

    @Override
    public PackageDownloadDetails getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AgentIdentificationOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentIdentification)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * When new_instance_uid is set, Agent MUST update instance_uid
     * to the value provided and use it for all further communication.
     * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
     * </pre>
     *
     * <code>bytes new_instance_uid = 1;</code>
     *
     * @return The newInstanceUid.
     */
    com.google.protobuf.ByteString getNewInstanceUid();
  }

  /**
   *
   *
   * <pre>
   * Properties related to identification of the Agent, which can be overridden
   * by the Server if needed
   * </pre>
   *
   * Protobuf type {@code opamp.proto.AgentIdentification}
   */
  public static final class AgentIdentification extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentIdentification)
      AgentIdentificationOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentIdentification.newBuilder() to construct.
    private AgentIdentification(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentIdentification() {
      newInstanceUid_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentIdentification();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentIdentification_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentIdentification_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentIdentification.class, Builder.class);
    }

    public static final int NEW_INSTANCE_UID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString newInstanceUid_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * When new_instance_uid is set, Agent MUST update instance_uid
     * to the value provided and use it for all further communication.
     * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
     * </pre>
     *
     * <code>bytes new_instance_uid = 1;</code>
     *
     * @return The newInstanceUid.
     */
    @Override
    public com.google.protobuf.ByteString getNewInstanceUid() {
      return newInstanceUid_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!newInstanceUid_.isEmpty()) {
        output.writeBytes(1, newInstanceUid_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!newInstanceUid_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, newInstanceUid_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentIdentification)) {
        return super.equals(obj);
      }
      AgentIdentification other = (AgentIdentification) obj;

      if (!getNewInstanceUid().equals(other.getNewInstanceUid())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NEW_INSTANCE_UID_FIELD_NUMBER;
      hash = (53 * hash) + getNewInstanceUid().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentIdentification parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentIdentification parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentIdentification parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentIdentification parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentIdentification parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentIdentification parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentIdentification parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentIdentification parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentIdentification parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentIdentification parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentIdentification parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentIdentification parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentIdentification prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     *
     *
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed
     * </pre>
     *
     * Protobuf type {@code opamp.proto.AgentIdentification}
     */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentIdentification)
        AgentIdentificationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentIdentification_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentIdentification_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentIdentification.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentIdentification.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        newInstanceUid_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentIdentification_descriptor;
      }

      @Override
      public AgentIdentification getDefaultInstanceForType() {
        return AgentIdentification.getDefaultInstance();
      }

      @Override
      public AgentIdentification build() {
        AgentIdentification result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentIdentification buildPartial() {
        AgentIdentification result = new AgentIdentification(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(AgentIdentification result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.newInstanceUid_ = newInstanceUid_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentIdentification) {
          return mergeFrom((AgentIdentification) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentIdentification other) {
        if (other == AgentIdentification.getDefaultInstance()) return this;
        if (other.getNewInstanceUid() != com.google.protobuf.ByteString.EMPTY) {
          setNewInstanceUid(other.getNewInstanceUid());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  newInstanceUid_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString newInstanceUid_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
       * </pre>
       *
       * <code>bytes new_instance_uid = 1;</code>
       *
       * @return The newInstanceUid.
       */
      @Override
      public com.google.protobuf.ByteString getNewInstanceUid() {
        return newInstanceUid_;
      }

      /**
       *
       *
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
       * </pre>
       *
       * <code>bytes new_instance_uid = 1;</code>
       *
       * @param value The newInstanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setNewInstanceUid(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        newInstanceUid_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
       * </pre>
       *
       * <code>bytes new_instance_uid = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearNewInstanceUid() {
        bitField0_ = (bitField0_ & ~0x00000001);
        newInstanceUid_ = getDefaultInstance().getNewInstanceUid();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentIdentification)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentIdentification)
    private static final AgentIdentification DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentIdentification();
    }

    public static AgentIdentification getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentIdentification> PARSER =
        new com.google.protobuf.AbstractParser<AgentIdentification>() {
          @Override
          public AgentIdentification parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentIdentification> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentIdentification> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentIdentification getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AgentRemoteConfigOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentRemoteConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     *
     * @return Whether the config field is set.
     */
    boolean hasConfig();

    /**
     *
     *
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     *
     * @return The config.
     */
    AgentConfigMap getConfig();

    /**
     *
     *
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     */
    AgentConfigMapOrBuilder getConfigOrBuilder();

    /**
     *
     *
     * <pre>
     * Hash of "config". The Agent SHOULD include this value in subsequent
     * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
     * allows the management Server to identify that a new config is available for the Agent.
     *
     * This field MUST be always set if the management Server supports remote configuration
     * of agents.
     *
     * Management Server must choose a hashing function that guarantees lack of hash
     * collisions in practice.
     * </pre>
     *
     * <code>bytes config_hash = 2;</code>
     *
     * @return The configHash.
     */
    com.google.protobuf.ByteString getConfigHash();
  }

  /** Protobuf type {@code opamp.proto.AgentRemoteConfig} */
  public static final class AgentRemoteConfig extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentRemoteConfig)
      AgentRemoteConfigOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentRemoteConfig.newBuilder() to construct.
    private AgentRemoteConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentRemoteConfig() {
      configHash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentRemoteConfig();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentRemoteConfig_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentRemoteConfig.class, Builder.class);
    }

    private int bitField0_;
    public static final int CONFIG_FIELD_NUMBER = 1;
    private AgentConfigMap config_;

    /**
     *
     *
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     *
     * @return Whether the config field is set.
     */
    @Override
    public boolean hasConfig() {
      return ((bitField0_ & 0x00000001) != 0);
    }

    /**
     *
     *
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     *
     * @return The config.
     */
    @Override
    public AgentConfigMap getConfig() {
      return config_ == null ? AgentConfigMap.getDefaultInstance() : config_;
    }

    /**
     *
     *
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     */
    @Override
    public AgentConfigMapOrBuilder getConfigOrBuilder() {
      return config_ == null ? AgentConfigMap.getDefaultInstance() : config_;
    }

    public static final int CONFIG_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString configHash_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Hash of "config". The Agent SHOULD include this value in subsequent
     * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
     * allows the management Server to identify that a new config is available for the Agent.
     *
     * This field MUST be always set if the management Server supports remote configuration
     * of agents.
     *
     * Management Server must choose a hashing function that guarantees lack of hash
     * collisions in practice.
     * </pre>
     *
     * <code>bytes config_hash = 2;</code>
     *
     * @return The configHash.
     */
    @Override
    public com.google.protobuf.ByteString getConfigHash() {
      return configHash_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getConfig());
      }
      if (!configHash_.isEmpty()) {
        output.writeBytes(2, configHash_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, getConfig());
      }
      if (!configHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(2, configHash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentRemoteConfig)) {
        return super.equals(obj);
      }
      AgentRemoteConfig other = (AgentRemoteConfig) obj;

      if (hasConfig() != other.hasConfig()) return false;
      if (hasConfig()) {
        if (!getConfig().equals(other.getConfig())) return false;
      }
      if (!getConfigHash().equals(other.getConfigHash())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfig()) {
        hash = (37 * hash) + CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getConfig().hashCode();
      }
      hash = (37 * hash) + CONFIG_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getConfigHash().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentRemoteConfig parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentRemoteConfig parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentRemoteConfig parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentRemoteConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentRemoteConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentRemoteConfig parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentRemoteConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentRemoteConfig parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentRemoteConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentRemoteConfig parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentRemoteConfig parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentRemoteConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentRemoteConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.AgentRemoteConfig} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentRemoteConfig)
        AgentRemoteConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentRemoteConfig_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentRemoteConfig.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentRemoteConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {
          getConfigFieldBuilder();
        }
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        config_ = null;
        if (configBuilder_ != null) {
          configBuilder_.dispose();
          configBuilder_ = null;
        }
        configHash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentRemoteConfig_descriptor;
      }

      @Override
      public AgentRemoteConfig getDefaultInstanceForType() {
        return AgentRemoteConfig.getDefaultInstance();
      }

      @Override
      public AgentRemoteConfig build() {
        AgentRemoteConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentRemoteConfig buildPartial() {
        AgentRemoteConfig result = new AgentRemoteConfig(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(AgentRemoteConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.config_ = configBuilder_ == null ? config_ : configBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.configHash_ = configHash_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentRemoteConfig) {
          return mergeFrom((AgentRemoteConfig) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentRemoteConfig other) {
        if (other == AgentRemoteConfig.getDefaultInstance()) return this;
        if (other.hasConfig()) {
          mergeConfig(other.getConfig());
        }
        if (other.getConfigHash() != com.google.protobuf.ByteString.EMPTY) {
          setConfigHash(other.getConfigHash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  input.readMessage(getConfigFieldBuilder().getBuilder(), extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  configHash_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private AgentConfigMap config_;
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentConfigMap, AgentConfigMap.Builder, AgentConfigMapOrBuilder>
          configBuilder_;

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       *
       * @return Whether the config field is set.
       */
      public boolean hasConfig() {
        return ((bitField0_ & 0x00000001) != 0);
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       *
       * @return The config.
       */
      public AgentConfigMap getConfig() {
        if (configBuilder_ == null) {
          return config_ == null ? AgentConfigMap.getDefaultInstance() : config_;
        } else {
          return configBuilder_.getMessage();
        }
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder setConfig(AgentConfigMap value) {
        if (configBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          config_ = value;
        } else {
          configBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder setConfig(AgentConfigMap.Builder builderForValue) {
        if (configBuilder_ == null) {
          config_ = builderForValue.build();
        } else {
          configBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder mergeConfig(AgentConfigMap value) {
        if (configBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)
              && config_ != null
              && config_ != AgentConfigMap.getDefaultInstance()) {
            getConfigBuilder().mergeFrom(value);
          } else {
            config_ = value;
          }
        } else {
          configBuilder_.mergeFrom(value);
        }
        if (config_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder clearConfig() {
        bitField0_ = (bitField0_ & ~0x00000001);
        config_ = null;
        if (configBuilder_ != null) {
          configBuilder_.dispose();
          configBuilder_ = null;
        }
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public AgentConfigMap.Builder getConfigBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getConfigFieldBuilder().getBuilder();
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public AgentConfigMapOrBuilder getConfigOrBuilder() {
        if (configBuilder_ != null) {
          return configBuilder_.getMessageOrBuilder();
        } else {
          return config_ == null ? AgentConfigMap.getDefaultInstance() : config_;
        }
      }

      /**
       *
       *
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
              AgentConfigMap, AgentConfigMap.Builder, AgentConfigMapOrBuilder>
          getConfigFieldBuilder() {
        if (configBuilder_ == null) {
          configBuilder_ =
              new com.google.protobuf.SingleFieldBuilderV3<
                  AgentConfigMap, AgentConfigMap.Builder, AgentConfigMapOrBuilder>(
                  getConfig(), getParentForChildren(), isClean());
          config_ = null;
        }
        return configBuilder_;
      }

      private com.google.protobuf.ByteString configHash_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Hash of "config". The Agent SHOULD include this value in subsequent
       * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
       * allows the management Server to identify that a new config is available for the Agent.
       *
       * This field MUST be always set if the management Server supports remote configuration
       * of agents.
       *
       * Management Server must choose a hashing function that guarantees lack of hash
       * collisions in practice.
       * </pre>
       *
       * <code>bytes config_hash = 2;</code>
       *
       * @return The configHash.
       */
      @Override
      public com.google.protobuf.ByteString getConfigHash() {
        return configHash_;
      }

      /**
       *
       *
       * <pre>
       * Hash of "config". The Agent SHOULD include this value in subsequent
       * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
       * allows the management Server to identify that a new config is available for the Agent.
       *
       * This field MUST be always set if the management Server supports remote configuration
       * of agents.
       *
       * Management Server must choose a hashing function that guarantees lack of hash
       * collisions in practice.
       * </pre>
       *
       * <code>bytes config_hash = 2;</code>
       *
       * @param value The configHash to set.
       * @return This builder for chaining.
       */
      public Builder setConfigHash(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        configHash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Hash of "config". The Agent SHOULD include this value in subsequent
       * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
       * allows the management Server to identify that a new config is available for the Agent.
       *
       * This field MUST be always set if the management Server supports remote configuration
       * of agents.
       *
       * Management Server must choose a hashing function that guarantees lack of hash
       * collisions in practice.
       * </pre>
       *
       * <code>bytes config_hash = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearConfigHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        configHash_ = getDefaultInstance().getConfigHash();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentRemoteConfig)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentRemoteConfig)
    private static final AgentRemoteConfig DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentRemoteConfig();
    }

    public static AgentRemoteConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentRemoteConfig> PARSER =
        new com.google.protobuf.AbstractParser<AgentRemoteConfig>() {
          @Override
          public AgentRemoteConfig parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentRemoteConfig> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentRemoteConfig> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentRemoteConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AgentConfigMapOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentConfigMap)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    int getConfigMapCount();

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    boolean containsConfigMap(String key);

    /** Use {@link #getConfigMapMap()} instead. */
    @Deprecated
    java.util.Map<String, AgentConfigFile> getConfigMap();

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    java.util.Map<String, AgentConfigFile> getConfigMapMap();

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    /* nullable */
    AgentConfigFile getConfigMapOrDefault(
        String key,
        /* nullable */
        AgentConfigFile defaultValue);

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    AgentConfigFile getConfigMapOrThrow(String key);
  }

  /** Protobuf type {@code opamp.proto.AgentConfigMap} */
  public static final class AgentConfigMap extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentConfigMap)
      AgentConfigMapOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentConfigMap.newBuilder() to construct.
    private AgentConfigMap(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentConfigMap() {}

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentConfigMap();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentConfigMap_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetConfigMap();
        default:
          throw new RuntimeException("Invalid map field number: " + number);
      }
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentConfigMap.class, Builder.class);
    }

    public static final int CONFIG_MAP_FIELD_NUMBER = 1;

    private static final class ConfigMapDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<String, AgentConfigFile> defaultEntry =
          com.google.protobuf.MapEntry.<String, AgentConfigFile>newDefaultInstance(
              Opamp.internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor,
              com.google.protobuf.WireFormat.FieldType.STRING,
              "",
              com.google.protobuf.WireFormat.FieldType.MESSAGE,
              AgentConfigFile.getDefaultInstance());
    }

    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<String, AgentConfigFile> configMap_;

    private com.google.protobuf.MapField<String, AgentConfigFile> internalGetConfigMap() {
      if (configMap_ == null) {
        return com.google.protobuf.MapField.emptyMapField(ConfigMapDefaultEntryHolder.defaultEntry);
      }
      return configMap_;
    }

    public int getConfigMapCount() {
      return internalGetConfigMap().getMap().size();
    }

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @Override
    public boolean containsConfigMap(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      return internalGetConfigMap().getMap().containsKey(key);
    }

    /** Use {@link #getConfigMapMap()} instead. */
    @Override
    @Deprecated
    public java.util.Map<String, AgentConfigFile> getConfigMap() {
      return getConfigMapMap();
    }

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @Override
    public java.util.Map<String, AgentConfigFile> getConfigMapMap() {
      return internalGetConfigMap().getMap();
    }

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @Override
    public /* nullable */ AgentConfigFile getConfigMapOrDefault(
        String key,
        /* nullable */
        AgentConfigFile defaultValue) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, AgentConfigFile> map = internalGetConfigMap().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }

    /**
     *
     *
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @Override
    public AgentConfigFile getConfigMapOrThrow(String key) {
      if (key == null) {
        throw new NullPointerException("map key");
      }
      java.util.Map<String, AgentConfigFile> map = internalGetConfigMap().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3.serializeStringMapTo(
          output, internalGetConfigMap(), ConfigMapDefaultEntryHolder.defaultEntry, 1);
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<String, AgentConfigFile> entry :
          internalGetConfigMap().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, AgentConfigFile> configMap__ =
            ConfigMapDefaultEntryHolder.defaultEntry
                .newBuilderForType()
                .setKey(entry.getKey())
                .setValue(entry.getValue())
                .build();
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(1, configMap__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentConfigMap)) {
        return super.equals(obj);
      }
      AgentConfigMap other = (AgentConfigMap) obj;

      if (!internalGetConfigMap().equals(other.internalGetConfigMap())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetConfigMap().getMap().isEmpty()) {
        hash = (37 * hash) + CONFIG_MAP_FIELD_NUMBER;
        hash = (53 * hash) + internalGetConfigMap().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentConfigMap parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentConfigMap parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentConfigMap parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentConfigMap parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentConfigMap parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentConfigMap parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentConfigMap parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentConfigMap parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentConfigMap parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentConfigMap parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentConfigMap parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentConfigMap parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentConfigMap prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.AgentConfigMap} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentConfigMap)
        AgentConfigMapOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentConfigMap_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetConfigMap();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableConfigMap();
          default:
            throw new RuntimeException("Invalid map field number: " + number);
        }
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentConfigMap.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentConfigMap.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutableConfigMap().clear();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentConfigMap_descriptor;
      }

      @Override
      public AgentConfigMap getDefaultInstanceForType() {
        return AgentConfigMap.getDefaultInstance();
      }

      @Override
      public AgentConfigMap build() {
        AgentConfigMap result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentConfigMap buildPartial() {
        AgentConfigMap result = new AgentConfigMap(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(AgentConfigMap result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.configMap_ =
              internalGetConfigMap().build(ConfigMapDefaultEntryHolder.defaultEntry);
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentConfigMap) {
          return mergeFrom((AgentConfigMap) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentConfigMap other) {
        if (other == AgentConfigMap.getDefaultInstance()) return this;
        internalGetMutableConfigMap().mergeFrom(other.internalGetConfigMap());
        bitField0_ |= 0x00000001;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  com.google.protobuf.MapEntry<String, AgentConfigFile> configMap__ =
                      input.readMessage(
                          ConfigMapDefaultEntryHolder.defaultEntry.getParserForType(),
                          extensionRegistry);
                  internalGetMutableConfigMap()
                      .ensureBuilderMap()
                      .put(configMap__.getKey(), configMap__.getValue());
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private static final class ConfigMapConverter
          implements com.google.protobuf.MapFieldBuilder.Converter<
              String, AgentConfigFileOrBuilder, AgentConfigFile> {
        @Override
        public AgentConfigFile build(AgentConfigFileOrBuilder val) {
          if (val instanceof AgentConfigFile) {
            return (AgentConfigFile) val;
          }
          return ((AgentConfigFile.Builder) val).build();
        }

        @Override
        public com.google.protobuf.MapEntry<String, AgentConfigFile> defaultEntry() {
          return ConfigMapDefaultEntryHolder.defaultEntry;
        }
      }
      ;

      private static final ConfigMapConverter configMapConverter = new ConfigMapConverter();

      private com.google.protobuf.MapFieldBuilder<
              String, AgentConfigFileOrBuilder, AgentConfigFile, AgentConfigFile.Builder>
          configMap_;

      private com.google.protobuf.MapFieldBuilder<
              String, AgentConfigFileOrBuilder, AgentConfigFile, AgentConfigFile.Builder>
          internalGetConfigMap() {
        if (configMap_ == null) {
          return new com.google.protobuf.MapFieldBuilder<>(configMapConverter);
        }
        return configMap_;
      }

      private com.google.protobuf.MapFieldBuilder<
              String, AgentConfigFileOrBuilder, AgentConfigFile, AgentConfigFile.Builder>
          internalGetMutableConfigMap() {
        if (configMap_ == null) {
          configMap_ = new com.google.protobuf.MapFieldBuilder<>(configMapConverter);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return configMap_;
      }

      public int getConfigMapCount() {
        return internalGetConfigMap().ensureBuilderMap().size();
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @Override
      public boolean containsConfigMap(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        return internalGetConfigMap().ensureBuilderMap().containsKey(key);
      }

      /** Use {@link #getConfigMapMap()} instead. */
      @Override
      @Deprecated
      public java.util.Map<String, AgentConfigFile> getConfigMap() {
        return getConfigMapMap();
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @Override
      public java.util.Map<String, AgentConfigFile> getConfigMapMap() {
        return internalGetConfigMap().getImmutableMap();
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @Override
      public /* nullable */ AgentConfigFile getConfigMapOrDefault(
          String key,
          /* nullable */
          AgentConfigFile defaultValue) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, AgentConfigFileOrBuilder> map =
            internalGetMutableConfigMap().ensureBuilderMap();
        return map.containsKey(key) ? configMapConverter.build(map.get(key)) : defaultValue;
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @Override
      public AgentConfigFile getConfigMapOrThrow(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        java.util.Map<String, AgentConfigFileOrBuilder> map =
            internalGetMutableConfigMap().ensureBuilderMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return configMapConverter.build(map.get(key));
      }

      public Builder clearConfigMap() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableConfigMap().clear();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      public Builder removeConfigMap(String key) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        internalGetMutableConfigMap().ensureBuilderMap().remove(key);
        return this;
      }

      /** Use alternate mutation accessors instead. */
      @Deprecated
      public java.util.Map<String, AgentConfigFile> getMutableConfigMap() {
        bitField0_ |= 0x00000001;
        return internalGetMutableConfigMap().ensureMessageMap();
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      public Builder putConfigMap(String key, AgentConfigFile value) {
        if (key == null) {
          throw new NullPointerException("map key");
        }
        if (value == null) {
          throw new NullPointerException("map value");
        }
        internalGetMutableConfigMap().ensureBuilderMap().put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      public Builder putAllConfigMap(java.util.Map<String, AgentConfigFile> values) {
        for (java.util.Map.Entry<String, AgentConfigFile> e : values.entrySet()) {
          if (e.getKey() == null || e.getValue() == null) {
            throw new NullPointerException();
          }
        }
        internalGetMutableConfigMap().ensureBuilderMap().putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }

      /**
       *
       *
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      public AgentConfigFile.Builder putConfigMapBuilderIfAbsent(String key) {
        java.util.Map<String, AgentConfigFileOrBuilder> builderMap =
            internalGetMutableConfigMap().ensureBuilderMap();
        AgentConfigFileOrBuilder entry = builderMap.get(key);
        if (entry == null) {
          entry = AgentConfigFile.newBuilder();
          builderMap.put(key, entry);
        }
        if (entry instanceof AgentConfigFile) {
          entry = ((AgentConfigFile) entry).toBuilder();
          builderMap.put(key, entry);
        }
        return (AgentConfigFile.Builder) entry;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentConfigMap)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentConfigMap)
    private static final AgentConfigMap DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentConfigMap();
    }

    public static AgentConfigMap getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentConfigMap> PARSER =
        new com.google.protobuf.AbstractParser<AgentConfigMap>() {
          @Override
          public AgentConfigMap parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentConfigMap> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentConfigMap> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentConfigMap getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface AgentConfigFileOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentConfigFile)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * Config file or section body. The content, format and encoding depends on the Agent
     * type. The content_type field may optionally describe the MIME type of the body.
     * </pre>
     *
     * <code>bytes body = 1;</code>
     *
     * @return The body.
     */
    com.google.protobuf.ByteString getBody();

    /**
     *
     *
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     *
     * @return The contentType.
     */
    String getContentType();

    /**
     *
     *
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     *
     * @return The bytes for contentType.
     */
    com.google.protobuf.ByteString getContentTypeBytes();
  }

  /** Protobuf type {@code opamp.proto.AgentConfigFile} */
  public static final class AgentConfigFile extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentConfigFile)
      AgentConfigFileOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use AgentConfigFile.newBuilder() to construct.
    private AgentConfigFile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private AgentConfigFile() {
      body_ = com.google.protobuf.ByteString.EMPTY;
      contentType_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new AgentConfigFile();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_AgentConfigFile_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable
          .ensureFieldAccessorsInitialized(AgentConfigFile.class, Builder.class);
    }

    public static final int BODY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Config file or section body. The content, format and encoding depends on the Agent
     * type. The content_type field may optionally describe the MIME type of the body.
     * </pre>
     *
     * <code>bytes body = 1;</code>
     *
     * @return The body.
     */
    @Override
    public com.google.protobuf.ByteString getBody() {
      return body_;
    }

    public static final int CONTENT_TYPE_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private volatile Object contentType_ = "";

    /**
     *
     *
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     *
     * @return The contentType.
     */
    @Override
    public String getContentType() {
      Object ref = contentType_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        contentType_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     *
     * @return The bytes for contentType.
     */
    @Override
    public com.google.protobuf.ByteString getContentTypeBytes() {
      Object ref = contentType_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        contentType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!body_.isEmpty()) {
        output.writeBytes(1, body_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(contentType_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, contentType_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!body_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, body_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(contentType_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, contentType_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof AgentConfigFile)) {
        return super.equals(obj);
      }
      AgentConfigFile other = (AgentConfigFile) obj;

      if (!getBody().equals(other.getBody())) return false;
      if (!getContentType().equals(other.getContentType())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + BODY_FIELD_NUMBER;
      hash = (53 * hash) + getBody().hashCode();
      hash = (37 * hash) + CONTENT_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getContentType().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AgentConfigFile parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentConfigFile parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentConfigFile parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentConfigFile parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentConfigFile parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static AgentConfigFile parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static AgentConfigFile parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentConfigFile parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentConfigFile parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static AgentConfigFile parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static AgentConfigFile parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static AgentConfigFile parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(AgentConfigFile prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.AgentConfigFile} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentConfigFile)
        AgentConfigFileOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_AgentConfigFile_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(AgentConfigFile.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentConfigFile.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        body_ = com.google.protobuf.ByteString.EMPTY;
        contentType_ = "";
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_AgentConfigFile_descriptor;
      }

      @Override
      public AgentConfigFile getDefaultInstanceForType() {
        return AgentConfigFile.getDefaultInstance();
      }

      @Override
      public AgentConfigFile build() {
        AgentConfigFile result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public AgentConfigFile buildPartial() {
        AgentConfigFile result = new AgentConfigFile(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(AgentConfigFile result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.body_ = body_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.contentType_ = contentType_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AgentConfigFile) {
          return mergeFrom((AgentConfigFile) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AgentConfigFile other) {
        if (other == AgentConfigFile.getDefaultInstance()) return this;
        if (other.getBody() != com.google.protobuf.ByteString.EMPTY) {
          setBody(other.getBody());
        }
        if (!other.getContentType().isEmpty()) {
          contentType_ = other.contentType_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  body_ = input.readBytes();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  contentType_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Config file or section body. The content, format and encoding depends on the Agent
       * type. The content_type field may optionally describe the MIME type of the body.
       * </pre>
       *
       * <code>bytes body = 1;</code>
       *
       * @return The body.
       */
      @Override
      public com.google.protobuf.ByteString getBody() {
        return body_;
      }

      /**
       *
       *
       * <pre>
       * Config file or section body. The content, format and encoding depends on the Agent
       * type. The content_type field may optionally describe the MIME type of the body.
       * </pre>
       *
       * <code>bytes body = 1;</code>
       *
       * @param value The body to set.
       * @return This builder for chaining.
       */
      public Builder setBody(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        body_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Config file or section body. The content, format and encoding depends on the Agent
       * type. The content_type field may optionally describe the MIME type of the body.
       * </pre>
       *
       * <code>bytes body = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearBody() {
        bitField0_ = (bitField0_ & ~0x00000001);
        body_ = getDefaultInstance().getBody();
        onChanged();
        return this;
      }

      private Object contentType_ = "";

      /**
       *
       *
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       *
       * @return The contentType.
       */
      public String getContentType() {
        Object ref = contentType_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          contentType_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       *
       * @return The bytes for contentType.
       */
      public com.google.protobuf.ByteString getContentTypeBytes() {
        Object ref = contentType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          contentType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       *
       * @param value The contentType to set.
       * @return This builder for chaining.
       */
      public Builder setContentType(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        contentType_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearContentType() {
        contentType_ = getDefaultInstance().getContentType();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       *
       * @param value The bytes for contentType to set.
       * @return This builder for chaining.
       */
      public Builder setContentTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        contentType_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentConfigFile)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentConfigFile)
    private static final AgentConfigFile DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new AgentConfigFile();
    }

    public static AgentConfigFile getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentConfigFile> PARSER =
        new com.google.protobuf.AbstractParser<AgentConfigFile>() {
          @Override
          public AgentConfigFile parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<AgentConfigFile> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AgentConfigFile> getParserForType() {
      return PARSER;
    }

    @Override
    public AgentConfigFile getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface CustomCapabilitiesOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.CustomCapabilities)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @return A list containing the capabilities.
     */
    java.util.List<String> getCapabilitiesList();

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @return The count of capabilities.
     */
    int getCapabilitiesCount();

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @param index The index of the element to return.
     * @return The capabilities at the given index.
     */
    String getCapabilities(int index);

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the capabilities at the given index.
     */
    com.google.protobuf.ByteString getCapabilitiesBytes(int index);
  }

  /** Protobuf type {@code opamp.proto.CustomCapabilities} */
  public static final class CustomCapabilities extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.CustomCapabilities)
      CustomCapabilitiesOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CustomCapabilities.newBuilder() to construct.
    private CustomCapabilities(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CustomCapabilities() {
      capabilities_ = com.google.protobuf.LazyStringArrayList.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new CustomCapabilities();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_CustomCapabilities_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_CustomCapabilities_fieldAccessorTable
          .ensureFieldAccessorsInitialized(CustomCapabilities.class, Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList capabilities_ =
        com.google.protobuf.LazyStringArrayList.emptyList();

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @return A list containing the capabilities.
     */
    public com.google.protobuf.ProtocolStringList getCapabilitiesList() {
      return capabilities_;
    }

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @return The count of capabilities.
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @param index The index of the element to return.
     * @return The capabilities at the given index.
     */
    public String getCapabilities(int index) {
      return capabilities_.get(index);
    }

    /**
     *
     *
     * <pre>
     * A list of custom capabilities that are supported. Each capability is a reverse FQDN
     * with optional version information that uniquely identifies the custom capability
     * and should match a capability specified in a supported CustomMessage.
     * Status: [Development]
     * </pre>
     *
     * <code>repeated string capabilities = 1;</code>
     *
     * @param index The index of the value to return.
     * @return The bytes of the capabilities at the given index.
     */
    public com.google.protobuf.ByteString getCapabilitiesBytes(int index) {
      return capabilities_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, capabilities_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < capabilities_.size(); i++) {
          dataSize += computeStringSizeNoTag(capabilities_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getCapabilitiesList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof CustomCapabilities)) {
        return super.equals(obj);
      }
      CustomCapabilities other = (CustomCapabilities) obj;

      if (!getCapabilitiesList().equals(other.getCapabilitiesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static CustomCapabilities parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CustomCapabilities parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CustomCapabilities parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CustomCapabilities parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CustomCapabilities parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CustomCapabilities parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CustomCapabilities parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static CustomCapabilities parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static CustomCapabilities parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static CustomCapabilities parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static CustomCapabilities parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static CustomCapabilities parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(CustomCapabilities prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.CustomCapabilities} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.CustomCapabilities)
        CustomCapabilitiesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_CustomCapabilities_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_CustomCapabilities_fieldAccessorTable
            .ensureFieldAccessorsInitialized(CustomCapabilities.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.CustomCapabilities.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        capabilities_ = com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_CustomCapabilities_descriptor;
      }

      @Override
      public CustomCapabilities getDefaultInstanceForType() {
        return CustomCapabilities.getDefaultInstance();
      }

      @Override
      public CustomCapabilities build() {
        CustomCapabilities result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public CustomCapabilities buildPartial() {
        CustomCapabilities result = new CustomCapabilities(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(CustomCapabilities result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          capabilities_.makeImmutable();
          result.capabilities_ = capabilities_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof CustomCapabilities) {
          return mergeFrom((CustomCapabilities) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(CustomCapabilities other) {
        if (other == CustomCapabilities.getDefaultInstance()) return this;
        if (!other.capabilities_.isEmpty()) {
          if (capabilities_.isEmpty()) {
            capabilities_ = other.capabilities_;
            bitField0_ |= 0x00000001;
          } else {
            ensureCapabilitiesIsMutable();
            capabilities_.addAll(other.capabilities_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  String s = input.readStringRequireUtf8();
                  ensureCapabilitiesIsMutable();
                  capabilities_.add(s);
                  break;
                } // case 10
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList capabilities_ =
          com.google.protobuf.LazyStringArrayList.emptyList();

      private void ensureCapabilitiesIsMutable() {
        if (!capabilities_.isModifiable()) {
          capabilities_ = new com.google.protobuf.LazyStringArrayList(capabilities_);
        }
        bitField0_ |= 0x00000001;
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @return A list containing the capabilities.
       */
      public com.google.protobuf.ProtocolStringList getCapabilitiesList() {
        capabilities_.makeImmutable();
        return capabilities_;
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @return The count of capabilities.
       */
      public int getCapabilitiesCount() {
        return capabilities_.size();
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @param index The index of the element to return.
       * @return The capabilities at the given index.
       */
      public String getCapabilities(int index) {
        return capabilities_.get(index);
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @param index The index of the value to return.
       * @return The bytes of the capabilities at the given index.
       */
      public com.google.protobuf.ByteString getCapabilitiesBytes(int index) {
        return capabilities_.getByteString(index);
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @param index The index to set the value at.
       * @param value The capabilities to set.
       * @return This builder for chaining.
       */
      public Builder setCapabilities(int index, String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureCapabilitiesIsMutable();
        capabilities_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @param value The capabilities to add.
       * @return This builder for chaining.
       */
      public Builder addCapabilities(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureCapabilitiesIsMutable();
        capabilities_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @param values The capabilities to add.
       * @return This builder for chaining.
       */
      public Builder addAllCapabilities(Iterable<String> values) {
        ensureCapabilitiesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, capabilities_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCapabilities() {
        capabilities_ = com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        ;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A list of custom capabilities that are supported. Each capability is a reverse FQDN
       * with optional version information that uniquely identifies the custom capability
       * and should match a capability specified in a supported CustomMessage.
       * Status: [Development]
       * </pre>
       *
       * <code>repeated string capabilities = 1;</code>
       *
       * @param value The bytes of the capabilities to add.
       * @return This builder for chaining.
       */
      public Builder addCapabilitiesBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        ensureCapabilitiesIsMutable();
        capabilities_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.CustomCapabilities)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.CustomCapabilities)
    private static final CustomCapabilities DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new CustomCapabilities();
    }

    public static CustomCapabilities getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CustomCapabilities> PARSER =
        new com.google.protobuf.AbstractParser<CustomCapabilities>() {
          @Override
          public CustomCapabilities parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<CustomCapabilities> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<CustomCapabilities> getParserForType() {
      return PARSER;
    }

    @Override
    public CustomCapabilities getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  public interface CustomMessageOrBuilder
      extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.CustomMessage)
      com.google.protobuf.MessageOrBuilder {

    /**
     *
     *
     * <pre>
     * A reverse FQDN that uniquely identifies the capability and matches one of the
     * capabilities in the CustomCapabilities message.
     * Status: [Development]
     * </pre>
     *
     * <code>string capability = 1;</code>
     *
     * @return The capability.
     */
    String getCapability();

    /**
     *
     *
     * <pre>
     * A reverse FQDN that uniquely identifies the capability and matches one of the
     * capabilities in the CustomCapabilities message.
     * Status: [Development]
     * </pre>
     *
     * <code>string capability = 1;</code>
     *
     * @return The bytes for capability.
     */
    com.google.protobuf.ByteString getCapabilityBytes();

    /**
     *
     *
     * <pre>
     * Type of message within the capability. The capability defines the types of custom
     * messages that are used to implement the capability. The type must only be unique
     * within the capability.
     * Status: [Development]
     * </pre>
     *
     * <code>string type = 2;</code>
     *
     * @return The type.
     */
    String getType();

    /**
     *
     *
     * <pre>
     * Type of message within the capability. The capability defines the types of custom
     * messages that are used to implement the capability. The type must only be unique
     * within the capability.
     * Status: [Development]
     * </pre>
     *
     * <code>string type = 2;</code>
     *
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString getTypeBytes();

    /**
     *
     *
     * <pre>
     * Binary data of the message. The capability must specify the format of the contents
     * of the data for each custom message type it defines.
     * Status: [Development]
     * </pre>
     *
     * <code>bytes data = 3;</code>
     *
     * @return The data.
     */
    com.google.protobuf.ByteString getData();
  }

  /** Protobuf type {@code opamp.proto.CustomMessage} */
  public static final class CustomMessage extends com.google.protobuf.GeneratedMessageV3
      implements
      // @@protoc_insertion_point(message_implements:opamp.proto.CustomMessage)
      CustomMessageOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use CustomMessage.newBuilder() to construct.
    private CustomMessage(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }

    private CustomMessage() {
      capability_ = "";
      type_ = "";
      data_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(UnusedPrivateParameter unused) {
      return new CustomMessage();
    }

    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return Opamp.internal_static_opamp_proto_CustomMessage_descriptor;
    }

    @Override
    protected FieldAccessorTable internalGetFieldAccessorTable() {
      return Opamp.internal_static_opamp_proto_CustomMessage_fieldAccessorTable
          .ensureFieldAccessorsInitialized(CustomMessage.class, Builder.class);
    }

    public static final int CAPABILITY_FIELD_NUMBER = 1;

    @SuppressWarnings("serial")
    private volatile Object capability_ = "";

    /**
     *
     *
     * <pre>
     * A reverse FQDN that uniquely identifies the capability and matches one of the
     * capabilities in the CustomCapabilities message.
     * Status: [Development]
     * </pre>
     *
     * <code>string capability = 1;</code>
     *
     * @return The capability.
     */
    @Override
    public String getCapability() {
      Object ref = capability_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        capability_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * A reverse FQDN that uniquely identifies the capability and matches one of the
     * capabilities in the CustomCapabilities message.
     * Status: [Development]
     * </pre>
     *
     * <code>string capability = 1;</code>
     *
     * @return The bytes for capability.
     */
    @Override
    public com.google.protobuf.ByteString getCapabilityBytes() {
      Object ref = capability_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        capability_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 2;

    @SuppressWarnings("serial")
    private volatile Object type_ = "";

    /**
     *
     *
     * <pre>
     * Type of message within the capability. The capability defines the types of custom
     * messages that are used to implement the capability. The type must only be unique
     * within the capability.
     * Status: [Development]
     * </pre>
     *
     * <code>string type = 2;</code>
     *
     * @return The type.
     */
    @Override
    public String getType() {
      Object ref = type_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        type_ = s;
        return s;
      }
    }

    /**
     *
     *
     * <pre>
     * Type of message within the capability. The capability defines the types of custom
     * messages that are used to implement the capability. The type must only be unique
     * within the capability.
     * Status: [Development]
     * </pre>
     *
     * <code>string type = 2;</code>
     *
     * @return The bytes for type.
     */
    @Override
    public com.google.protobuf.ByteString getTypeBytes() {
      Object ref = type_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DATA_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString data_ = com.google.protobuf.ByteString.EMPTY;

    /**
     *
     *
     * <pre>
     * Binary data of the message. The capability must specify the format of the contents
     * of the data for each custom message type it defines.
     * Status: [Development]
     * </pre>
     *
     * <code>bytes data = 3;</code>
     *
     * @return The data.
     */
    @Override
    public com.google.protobuf.ByteString getData() {
      return data_;
    }

    private byte memoizedIsInitialized = -1;

    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(capability_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, capability_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(type_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, type_);
      }
      if (!data_.isEmpty()) {
        output.writeBytes(3, data_);
      }
      getUnknownFields().writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(capability_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, capability_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(type_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, type_);
      }
      if (!data_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(3, data_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
        return true;
      }
      if (!(obj instanceof CustomMessage)) {
        return super.equals(obj);
      }
      CustomMessage other = (CustomMessage) obj;

      if (!getCapability().equals(other.getCapability())) return false;
      if (!getType().equals(other.getType())) return false;
      if (!getData().equals(other.getData())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CAPABILITY_FIELD_NUMBER;
      hash = (53 * hash) + getCapability().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getType().hashCode();
      hash = (37 * hash) + DATA_FIELD_NUMBER;
      hash = (53 * hash) + getData().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static CustomMessage parseFrom(java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CustomMessage parseFrom(
        java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CustomMessage parseFrom(com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CustomMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CustomMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static CustomMessage parseFrom(
        byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static CustomMessage parseFrom(java.io.InputStream input) throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static CustomMessage parseFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static CustomMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
    }

    public static CustomMessage parseDelimitedFrom(
        java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
          PARSER, input, extensionRegistry);
    }

    public static CustomMessage parseFrom(com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
    }

    public static CustomMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
          PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(CustomMessage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /** Protobuf type {@code opamp.proto.CustomMessage} */
    public static final class Builder
        extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
        implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.CustomMessage)
        CustomMessageOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
        return Opamp.internal_static_opamp_proto_CustomMessage_descriptor;
      }

      @Override
      protected FieldAccessorTable internalGetFieldAccessorTable() {
        return Opamp.internal_static_opamp_proto_CustomMessage_fieldAccessorTable
            .ensureFieldAccessorsInitialized(CustomMessage.class, Builder.class);
      }

      // Construct using opamp.proto.Opamp.CustomMessage.newBuilder()
      private Builder() {}

      private Builder(BuilderParent parent) {
        super(parent);
      }

      @Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        capability_ = "";
        type_ = "";
        data_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
        return Opamp.internal_static_opamp_proto_CustomMessage_descriptor;
      }

      @Override
      public CustomMessage getDefaultInstanceForType() {
        return CustomMessage.getDefaultInstance();
      }

      @Override
      public CustomMessage build() {
        CustomMessage result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public CustomMessage buildPartial() {
        CustomMessage result = new CustomMessage(this);
        if (bitField0_ != 0) {
          buildPartial0(result);
        }
        onBuilt();
        return result;
      }

      private void buildPartial0(CustomMessage result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.capability_ = capability_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.type_ = type_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.data_ = data_;
        }
      }

      @Override
      public Builder clone() {
        return super.clone();
      }

      @Override
      public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.setField(field, value);
      }

      @Override
      public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }

      @Override
      public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }

      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }

      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field, Object value) {
        return super.addRepeatedField(field, value);
      }

      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof CustomMessage) {
          return mergeFrom((CustomMessage) other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(CustomMessage other) {
        if (other == CustomMessage.getDefaultInstance()) return this;
        if (!other.getCapability().isEmpty()) {
          capability_ = other.capability_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getType().isEmpty()) {
          type_ = other.type_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.getData() != com.google.protobuf.ByteString.EMPTY) {
          setData(other.getData());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10:
                {
                  capability_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
              case 18:
                {
                  type_ = input.readStringRequireUtf8();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
              case 26:
                {
                  data_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
              default:
                {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }

      private int bitField0_;

      private Object capability_ = "";

      /**
       *
       *
       * <pre>
       * A reverse FQDN that uniquely identifies the capability and matches one of the
       * capabilities in the CustomCapabilities message.
       * Status: [Development]
       * </pre>
       *
       * <code>string capability = 1;</code>
       *
       * @return The capability.
       */
      public String getCapability() {
        Object ref = capability_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          capability_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * A reverse FQDN that uniquely identifies the capability and matches one of the
       * capabilities in the CustomCapabilities message.
       * Status: [Development]
       * </pre>
       *
       * <code>string capability = 1;</code>
       *
       * @return The bytes for capability.
       */
      public com.google.protobuf.ByteString getCapabilityBytes() {
        Object ref = capability_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          capability_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * A reverse FQDN that uniquely identifies the capability and matches one of the
       * capabilities in the CustomCapabilities message.
       * Status: [Development]
       * </pre>
       *
       * <code>string capability = 1;</code>
       *
       * @param value The capability to set.
       * @return This builder for chaining.
       */
      public Builder setCapability(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        capability_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A reverse FQDN that uniquely identifies the capability and matches one of the
       * capabilities in the CustomCapabilities message.
       * Status: [Development]
       * </pre>
       *
       * <code>string capability = 1;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearCapability() {
        capability_ = getDefaultInstance().getCapability();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * A reverse FQDN that uniquely identifies the capability and matches one of the
       * capabilities in the CustomCapabilities message.
       * Status: [Development]
       * </pre>
       *
       * <code>string capability = 1;</code>
       *
       * @param value The bytes for capability to set.
       * @return This builder for chaining.
       */
      public Builder setCapabilityBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        capability_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Object type_ = "";

      /**
       *
       *
       * <pre>
       * Type of message within the capability. The capability defines the types of custom
       * messages that are used to implement the capability. The type must only be unique
       * within the capability.
       * Status: [Development]
       * </pre>
       *
       * <code>string type = 2;</code>
       *
       * @return The type.
       */
      public String getType() {
        Object ref = type_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          type_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Type of message within the capability. The capability defines the types of custom
       * messages that are used to implement the capability. The type must only be unique
       * within the capability.
       * Status: [Development]
       * </pre>
       *
       * <code>string type = 2;</code>
       *
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString getTypeBytes() {
        Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8((String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      /**
       *
       *
       * <pre>
       * Type of message within the capability. The capability defines the types of custom
       * messages that are used to implement the capability. The type must only be unique
       * within the capability.
       * Status: [Development]
       * </pre>
       *
       * <code>string type = 2;</code>
       *
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        type_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Type of message within the capability. The capability defines the types of custom
       * messages that are used to implement the capability. The type must only be unique
       * within the capability.
       * Status: [Development]
       * </pre>
       *
       * <code>string type = 2;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearType() {
        type_ = getDefaultInstance().getType();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Type of message within the capability. The capability defines the types of custom
       * messages that are used to implement the capability. The type must only be unique
       * within the capability.
       * Status: [Development]
       * </pre>
       *
       * <code>string type = 2;</code>
       *
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        checkByteStringIsUtf8(value);
        type_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString data_ = com.google.protobuf.ByteString.EMPTY;

      /**
       *
       *
       * <pre>
       * Binary data of the message. The capability must specify the format of the contents
       * of the data for each custom message type it defines.
       * Status: [Development]
       * </pre>
       *
       * <code>bytes data = 3;</code>
       *
       * @return The data.
       */
      @Override
      public com.google.protobuf.ByteString getData() {
        return data_;
      }

      /**
       *
       *
       * <pre>
       * Binary data of the message. The capability must specify the format of the contents
       * of the data for each custom message type it defines.
       * Status: [Development]
       * </pre>
       *
       * <code>bytes data = 3;</code>
       *
       * @param value The data to set.
       * @return This builder for chaining.
       */
      public Builder setData(com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        data_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      /**
       *
       *
       * <pre>
       * Binary data of the message. The capability must specify the format of the contents
       * of the data for each custom message type it defines.
       * Status: [Development]
       * </pre>
       *
       * <code>bytes data = 3;</code>
       *
       * @return This builder for chaining.
       */
      public Builder clearData() {
        bitField0_ = (bitField0_ & ~0x00000004);
        data_ = getDefaultInstance().getData();
        onChanged();
        return this;
      }

      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }

      // @@protoc_insertion_point(builder_scope:opamp.proto.CustomMessage)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.CustomMessage)
    private static final CustomMessage DEFAULT_INSTANCE;

    static {
      DEFAULT_INSTANCE = new CustomMessage();
    }

    public static CustomMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CustomMessage> PARSER =
        new com.google.protobuf.AbstractParser<CustomMessage>() {
          @Override
          public CustomMessage parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException()
                  .setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

    public static com.google.protobuf.Parser<CustomMessage> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<CustomMessage> getParserForType() {
      return PARSER;
    }

    @Override
    public CustomMessage getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }
  }

  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentToServer_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentToServer_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentDisconnect_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ConnectionSettingsRequest_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ConnectionSettingsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_OpAMPConnectionSettingsRequest_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OpAMPConnectionSettingsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_CertificateRequest_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_CertificateRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AvailableComponents_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AvailableComponents_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AvailableComponents_ComponentsEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AvailableComponents_ComponentsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ComponentDetails_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ComponentDetails_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ComponentDetails_SubComponentMapEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ComponentDetails_SubComponentMapEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ServerToAgent_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ServerToAgent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_OtherConnectionSettings_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_Headers_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_Headers_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_Header_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_Header_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_TLSCertificate_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_TLSCertificate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackagesAvailable_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackagesAvailable_PackagesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackageAvailable_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageAvailable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_DownloadableFile_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_DownloadableFile_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ServerErrorResponse_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_RetryInfo_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_RetryInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ServerToAgentCommand_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentDescription_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentDescription_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ComponentHealth_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ComponentHealth_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_ComponentHealth_ComponentHealthMapEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ComponentHealth_ComponentHealthMapEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_EffectiveConfig_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_RemoteConfigStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackageStatuses_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageStatuses_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageStatuses_PackagesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackageStatus_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_PackageDownloadDetails_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageDownloadDetails_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentIdentification_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentIdentification_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentRemoteConfig_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentConfigMap_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_AgentConfigFile_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_CustomCapabilities_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_CustomCapabilities_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
      internal_static_opamp_proto_CustomMessage_descriptor;
  private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_CustomMessage_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor() {
    return descriptor;
  }

  private static com.google.protobuf.Descriptors.FileDescriptor descriptor;

  static {
    String[] descriptorData = {
      "\n\013opamp.proto\022\013opamp.proto\032\016anyvalue.pro"
          + "to\"\256\005\n\rAgentToServer\022\024\n\014instance_uid\030\001 \001"
          + "(\014\022\024\n\014sequence_num\030\002 \001(\004\0228\n\021agent_descri"
          + "ption\030\003 \001(\0132\035.opamp.proto.AgentDescripti"
          + "on\022\024\n\014capabilities\030\004 \001(\004\022,\n\006health\030\005 \001(\013"
          + "2\034.opamp.proto.ComponentHealth\0226\n\020effect"
          + "ive_config\030\006 \001(\0132\034.opamp.proto.Effective"
          + "Config\022=\n\024remote_config_status\030\007 \001(\0132\037.o"
          + "pamp.proto.RemoteConfigStatus\0226\n\020package"
          + "_statuses\030\010 \001(\0132\034.opamp.proto.PackageSta"
          + "tuses\0226\n\020agent_disconnect\030\t \001(\0132\034.opamp."
          + "proto.AgentDisconnect\022\r\n\005flags\030\n \001(\004\022K\n\033"
          + "connection_settings_request\030\013 \001(\0132&.opam"
          + "p.proto.ConnectionSettingsRequest\022<\n\023cus"
          + "tom_capabilities\030\014 \001(\0132\037.opamp.proto.Cus"
          + "tomCapabilities\0222\n\016custom_message\030\r \001(\0132"
          + "\032.opamp.proto.CustomMessage\022>\n\024available"
          + "_components\030\016 \001(\0132 .opamp.proto.Availabl"
          + "eComponents\"\021\n\017AgentDisconnect\"W\n\031Connec"
          + "tionSettingsRequest\022:\n\005opamp\030\001 \001(\0132+.opa"
          + "mp.proto.OpAMPConnectionSettingsRequest\""
          + "^\n\036OpAMPConnectionSettingsRequest\022<\n\023cer"
          + "tificate_request\030\001 \001(\0132\037.opamp.proto.Cer"
          + "tificateRequest\"!\n\022CertificateRequest\022\013\n"
          + "\003csr\030\001 \001(\014\"\273\001\n\023AvailableComponents\022D\n\nco"
          + "mponents\030\001 \003(\01320.opamp.proto.AvailableCo"
          + "mponents.ComponentsEntry\022\014\n\004hash\030\002 \001(\014\032P"
          + "\n\017ComponentsEntry\022\013\n\003key\030\001 \001(\t\022,\n\005value\030"
          + "\002 \001(\0132\035.opamp.proto.ComponentDetails:\0028\001"
          + "\"\341\001\n\020ComponentDetails\022\'\n\010metadata\030\001 \003(\0132"
          + "\025.opamp.proto.KeyValue\022M\n\021sub_component_"
          + "map\030\002 \003(\01322.opamp.proto.ComponentDetails"
          + ".SubComponentMapEntry\032U\n\024SubComponentMap"
          + "Entry\022\013\n\003key\030\001 \001(\t\022,\n\005value\030\002 \001(\0132\035.opam"
          + "p.proto.ComponentDetails:\0028\001\"\241\004\n\rServerT"
          + "oAgent\022\024\n\014instance_uid\030\001 \001(\014\0228\n\016error_re"
          + "sponse\030\002 \001(\0132 .opamp.proto.ServerErrorRe"
          + "sponse\0225\n\rremote_config\030\003 \001(\0132\036.opamp.pr"
          + "oto.AgentRemoteConfig\022B\n\023connection_sett"
          + "ings\030\004 \001(\0132%.opamp.proto.ConnectionSetti"
          + "ngsOffers\022:\n\022packages_available\030\005 \001(\0132\036."
          + "opamp.proto.PackagesAvailable\022\r\n\005flags\030\006"
          + " \001(\004\022\024\n\014capabilities\030\007 \001(\004\022>\n\024agent_iden"
          + "tification\030\010 \001(\0132 .opamp.proto.AgentIden"
          + "tification\0222\n\007command\030\t \001(\0132!.opamp.prot"
          + "o.ServerToAgentCommand\022<\n\023custom_capabil"
          + "ities\030\n \001(\0132\037.opamp.proto.CustomCapabili"
          + "ties\0222\n\016custom_message\030\013 \001(\0132\032.opamp.pro"
          + "to.CustomMessage\"\264\001\n\027OpAMPConnectionSett"
          + "ings\022\034\n\024destination_endpoint\030\001 \001(\t\022%\n\007he"
          + "aders\030\002 \001(\0132\024.opamp.proto.Headers\0220\n\013cer"
          + "tificate\030\003 \001(\0132\033.opamp.proto.TLSCertific"
          + "ate\022\"\n\032heartbeat_interval_seconds\030\004 \001(\004\""
          + "\224\001\n\033TelemetryConnectionSettings\022\034\n\024desti"
          + "nation_endpoint\030\001 \001(\t\022%\n\007headers\030\002 \001(\0132\024"
          + ".opamp.proto.Headers\0220\n\013certificate\030\003 \001("
          + "\0132\033.opamp.proto.TLSCertificate\"\227\002\n\027Other"
          + "ConnectionSettings\022\034\n\024destination_endpoi"
          + "nt\030\001 \001(\t\022%\n\007headers\030\002 \001(\0132\024.opamp.proto."
          + "Headers\0220\n\013certificate\030\003 \001(\0132\033.opamp.pro"
          + "to.TLSCertificate\022O\n\016other_settings\030\004 \003("
          + "\01327.opamp.proto.OtherConnectionSettings."
          + "OtherSettingsEntry\0324\n\022OtherSettingsEntry"
          + "\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"/\n\007Head"
          + "ers\022$\n\007headers\030\001 \003(\0132\023.opamp.proto.Heade"
          + "r\"$\n\006Header\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\""
          + "D\n\016TLSCertificate\022\014\n\004cert\030\001 \001(\014\022\023\n\013priva"
          + "te_key\030\002 \001(\014\022\017\n\007ca_cert\030\003 \001(\014\"\315\003\n\030Connec"
          + "tionSettingsOffers\022\014\n\004hash\030\001 \001(\014\0223\n\005opam"
          + "p\030\002 \001(\0132$.opamp.proto.OpAMPConnectionSet"
          + "tings\022=\n\013own_metrics\030\003 \001(\0132(.opamp.proto"
          + ".TelemetryConnectionSettings\022<\n\nown_trac"
          + "es\030\004 \001(\0132(.opamp.proto.TelemetryConnecti"
          + "onSettings\022:\n\010own_logs\030\005 \001(\0132(.opamp.pro"
          + "to.TelemetryConnectionSettings\022V\n\021other_"
          + "connections\030\006 \003(\0132;.opamp.proto.Connecti"
          + "onSettingsOffers.OtherConnectionsEntry\032]"
          + "\n\025OtherConnectionsEntry\022\013\n\003key\030\001 \001(\t\0223\n\005"
          + "value\030\002 \001(\0132$.opamp.proto.OtherConnectio"
          + "nSettings:\0028\001\"\276\001\n\021PackagesAvailable\022>\n\010p"
          + "ackages\030\001 \003(\0132,.opamp.proto.PackagesAvai"
          + "lable.PackagesEntry\022\031\n\021all_packages_hash"
          + "\030\002 \001(\014\032N\n\rPackagesEntry\022\013\n\003key\030\001 \001(\t\022,\n\005"
          + "value\030\002 \001(\0132\035.opamp.proto.PackageAvailab"
          + "le:\0028\001\"\206\001\n\020PackageAvailable\022&\n\004type\030\001 \001("
          + "\0162\030.opamp.proto.PackageType\022\017\n\007version\030\002"
          + " \001(\t\022+\n\004file\030\003 \001(\0132\035.opamp.proto.Downloa"
          + "dableFile\022\014\n\004hash\030\004 \001(\014\"x\n\020DownloadableF"
          + "ile\022\024\n\014download_url\030\001 \001(\t\022\024\n\014content_has"
          + "h\030\002 \001(\014\022\021\n\tsignature\030\003 \001(\014\022%\n\007headers\030\004 "
          + "\001(\0132\024.opamp.proto.Headers\"\231\001\n\023ServerErro"
          + "rResponse\0222\n\004type\030\001 \001(\0162$.opamp.proto.Se"
          + "rverErrorResponseType\022\025\n\rerror_message\030\002"
          + " \001(\t\022,\n\nretry_info\030\003 \001(\0132\026.opamp.proto.R"
          + "etryInfoH\000B\t\n\007Details\",\n\tRetryInfo\022\037\n\027re"
          + "try_after_nanoseconds\030\001 \001(\004\">\n\024ServerToA"
          + "gentCommand\022&\n\004type\030\001 \001(\0162\030.opamp.proto."
          + "CommandType\"\204\001\n\020AgentDescription\0225\n\026iden"
          + "tifying_attributes\030\001 \003(\0132\025.opamp.proto.K"
          + "eyValue\0229\n\032non_identifying_attributes\030\002 "
          + "\003(\0132\025.opamp.proto.KeyValue\"\260\002\n\017Component"
          + "Health\022\017\n\007healthy\030\001 \001(\010\022\034\n\024start_time_un"
          + "ix_nano\030\002 \001(\006\022\022\n\nlast_error\030\003 \001(\t\022\016\n\006sta"
          + "tus\030\004 \001(\t\022\035\n\025status_time_unix_nano\030\005 \001(\006"
          + "\022R\n\024component_health_map\030\006 \003(\01324.opamp.p"
          + "roto.ComponentHealth.ComponentHealthMapE"
          + "ntry\032W\n\027ComponentHealthMapEntry\022\013\n\003key\030\001"
          + " \001(\t\022+\n\005value\030\002 \001(\0132\034.opamp.proto.Compon"
          + "entHealth:\0028\001\"B\n\017EffectiveConfig\022/\n\nconf"
          + "ig_map\030\001 \001(\0132\033.opamp.proto.AgentConfigMa"
          + "p\"\177\n\022RemoteConfigStatus\022\037\n\027last_remote_c"
          + "onfig_hash\030\001 \001(\014\0221\n\006status\030\002 \001(\0162!.opamp"
          + ".proto.RemoteConfigStatuses\022\025\n\rerror_mes"
          + "sage\030\003 \001(\t\"\336\001\n\017PackageStatuses\022<\n\010packag"
          + "es\030\001 \003(\0132*.opamp.proto.PackageStatuses.P"
          + "ackagesEntry\022)\n!server_provided_all_pack"
          + "ages_hash\030\002 \001(\014\022\025\n\rerror_message\030\003 \001(\t\032K"
          + "\n\rPackagesEntry\022\013\n\003key\030\001 \001(\t\022)\n\005value\030\002 "
          + "\001(\0132\032.opamp.proto.PackageStatus:\0028\001\"\223\002\n\r"
          + "PackageStatus\022\014\n\004name\030\001 \001(\t\022\031\n\021agent_has"
          + "_version\030\002 \001(\t\022\026\n\016agent_has_hash\030\003 \001(\014\022\036"
          + "\n\026server_offered_version\030\004 \001(\t\022\033\n\023server"
          + "_offered_hash\030\005 \001(\014\022.\n\006status\030\006 \001(\0162\036.op"
          + "amp.proto.PackageStatusEnum\022\025\n\rerror_mes"
          + "sage\030\007 \001(\t\022=\n\020download_details\030\010 \001(\0132#.o"
          + "pamp.proto.PackageDownloadDetails\"U\n\026Pac"
          + "kageDownloadDetails\022\030\n\020download_percent\030"
          + "\001 \001(\001\022!\n\031download_bytes_per_second\030\002 \001(\004"
          + "\"/\n\023AgentIdentification\022\030\n\020new_instance_"
          + "uid\030\001 \001(\014\"U\n\021AgentRemoteConfig\022+\n\006config"
          + "\030\001 \001(\0132\033.opamp.proto.AgentConfigMap\022\023\n\013c"
          + "onfig_hash\030\002 \001(\014\"\240\001\n\016AgentConfigMap\022>\n\nc"
          + "onfig_map\030\001 \003(\0132*.opamp.proto.AgentConfi"
          + "gMap.ConfigMapEntry\032N\n\016ConfigMapEntry\022\013\n"
          + "\003key\030\001 \001(\t\022+\n\005value\030\002 \001(\0132\034.opamp.proto."
          + "AgentConfigFile:\0028\001\"5\n\017AgentConfigFile\022\014"
          + "\n\004body\030\001 \001(\014\022\024\n\014content_type\030\002 \001(\t\"*\n\022Cu"
          + "stomCapabilities\022\024\n\014capabilities\030\001 \003(\t\"?"
          + "\n\rCustomMessage\022\022\n\ncapability\030\001 \001(\t\022\014\n\004t"
          + "ype\030\002 \001(\t\022\014\n\004data\030\003 \001(\014*c\n\022AgentToServer"
          + "Flags\022\"\n\036AgentToServerFlags_Unspecified\020"
          + "\000\022)\n%AgentToServerFlags_RequestInstanceU"
          + "id\020\001*\222\001\n\022ServerToAgentFlags\022\"\n\036ServerToA"
          + "gentFlags_Unspecified\020\000\022&\n\"ServerToAgent"
          + "Flags_ReportFullState\020\001\0220\n,ServerToAgent"
          + "Flags_ReportAvailableComponents\020\002*\367\002\n\022Se"
          + "rverCapabilities\022\"\n\036ServerCapabilities_U"
          + "nspecified\020\000\022$\n ServerCapabilities_Accep"
          + "tsStatus\020\001\022)\n%ServerCapabilities_OffersR"
          + "emoteConfig\020\002\022-\n)ServerCapabilities_Acce"
          + "ptsEffectiveConfig\020\004\022%\n!ServerCapabiliti"
          + "es_OffersPackages\020\010\022,\n(ServerCapabilitie"
          + "s_AcceptsPackagesStatus\020\020\022/\n+ServerCapab"
          + "ilities_OffersConnectionSettings\020 \0227\n3Se"
          + "rverCapabilities_AcceptsConnectionSettin"
          + "gsRequest\020@*>\n\013PackageType\022\030\n\024PackageTyp"
          + "e_TopLevel\020\000\022\025\n\021PackageType_Addon\020\001*\217\001\n\027"
          + "ServerErrorResponseType\022#\n\037ServerErrorRe"
          + "sponseType_Unknown\020\000\022&\n\"ServerErrorRespo"
          + "nseType_BadRequest\020\001\022\'\n#ServerErrorRespo"
          + "nseType_Unavailable\020\002*&\n\013CommandType\022\027\n\023"
          + "CommandType_Restart\020\000*\314\005\n\021AgentCapabilit"
          + "ies\022!\n\035AgentCapabilities_Unspecified\020\000\022#"
          + "\n\037AgentCapabilities_ReportsStatus\020\001\022)\n%A"
          + "gentCapabilities_AcceptsRemoteConfig\020\002\022,"
          + "\n(AgentCapabilities_ReportsEffectiveConf"
          + "ig\020\004\022%\n!AgentCapabilities_AcceptsPackage"
          + "s\020\010\022,\n(AgentCapabilities_ReportsPackageS"
          + "tatuses\020\020\022&\n\"AgentCapabilities_ReportsOw"
          + "nTraces\020 \022\'\n#AgentCapabilities_ReportsOw"
          + "nMetrics\020@\022%\n AgentCapabilities_ReportsO"
          + "wnLogs\020\200\001\0225\n0AgentCapabilities_AcceptsOp"
          + "AMPConnectionSettings\020\200\002\0225\n0AgentCapabil"
          + "ities_AcceptsOtherConnectionSettings\020\200\004\022"
          + ",\n\'AgentCapabilities_AcceptsRestartComma"
          + "nd\020\200\010\022$\n\037AgentCapabilities_ReportsHealth"
          + "\020\200\020\022*\n%AgentCapabilities_ReportsRemoteCo"
          + "nfig\020\200 \022\'\n\"AgentCapabilities_ReportsHear"
          + "tbeat\020\200@\0222\n,AgentCapabilities_ReportsAva"
          + "ilableComponents\020\200\200\001*\234\001\n\024RemoteConfigSta"
          + "tuses\022\036\n\032RemoteConfigStatuses_UNSET\020\000\022 \n"
          + "\034RemoteConfigStatuses_APPLIED\020\001\022!\n\035Remot"
          + "eConfigStatuses_APPLYING\020\002\022\037\n\033RemoteConf"
          + "igStatuses_FAILED\020\003*\304\001\n\021PackageStatusEnu"
          + "m\022\037\n\033PackageStatusEnum_Installed\020\000\022$\n Pa"
          + "ckageStatusEnum_InstallPending\020\001\022 \n\034Pack"
          + "ageStatusEnum_Installing\020\002\022#\n\037PackageSta"
          + "tusEnum_InstallFailed\020\003\022!\n\035PackageStatus"
          + "Enum_Downloading\020\004B.Z,github.com/open-te"
          + "lemetry/opamp-go/protobufsb\006proto3"
    };
    descriptor =
        com.google.protobuf.Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(
            descriptorData,
            new com.google.protobuf.Descriptors.FileDescriptor[] {
              Anyvalue.getDescriptor(),
            });
    internal_static_opamp_proto_AgentToServer_descriptor = getDescriptor().getMessageTypes().get(0);
    internal_static_opamp_proto_AgentToServer_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentToServer_descriptor,
            new String[] {
              "InstanceUid",
              "SequenceNum",
              "AgentDescription",
              "Capabilities",
              "Health",
              "EffectiveConfig",
              "RemoteConfigStatus",
              "PackageStatuses",
              "AgentDisconnect",
              "Flags",
              "ConnectionSettingsRequest",
              "CustomCapabilities",
              "CustomMessage",
              "AvailableComponents",
            });
    internal_static_opamp_proto_AgentDisconnect_descriptor =
        getDescriptor().getMessageTypes().get(1);
    internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentDisconnect_descriptor, new String[] {});
    internal_static_opamp_proto_ConnectionSettingsRequest_descriptor =
        getDescriptor().getMessageTypes().get(2);
    internal_static_opamp_proto_ConnectionSettingsRequest_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ConnectionSettingsRequest_descriptor,
            new String[] {
              "Opamp",
            });
    internal_static_opamp_proto_OpAMPConnectionSettingsRequest_descriptor =
        getDescriptor().getMessageTypes().get(3);
    internal_static_opamp_proto_OpAMPConnectionSettingsRequest_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_OpAMPConnectionSettingsRequest_descriptor,
            new String[] {
              "CertificateRequest",
            });
    internal_static_opamp_proto_CertificateRequest_descriptor =
        getDescriptor().getMessageTypes().get(4);
    internal_static_opamp_proto_CertificateRequest_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_CertificateRequest_descriptor,
            new String[] {
              "Csr",
            });
    internal_static_opamp_proto_AvailableComponents_descriptor =
        getDescriptor().getMessageTypes().get(5);
    internal_static_opamp_proto_AvailableComponents_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AvailableComponents_descriptor,
            new String[] {
              "Components", "Hash",
            });
    internal_static_opamp_proto_AvailableComponents_ComponentsEntry_descriptor =
        internal_static_opamp_proto_AvailableComponents_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_AvailableComponents_ComponentsEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AvailableComponents_ComponentsEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_ComponentDetails_descriptor =
        getDescriptor().getMessageTypes().get(6);
    internal_static_opamp_proto_ComponentDetails_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ComponentDetails_descriptor,
            new String[] {
              "Metadata", "SubComponentMap",
            });
    internal_static_opamp_proto_ComponentDetails_SubComponentMapEntry_descriptor =
        internal_static_opamp_proto_ComponentDetails_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_ComponentDetails_SubComponentMapEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ComponentDetails_SubComponentMapEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_ServerToAgent_descriptor = getDescriptor().getMessageTypes().get(7);
    internal_static_opamp_proto_ServerToAgent_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ServerToAgent_descriptor,
            new String[] {
              "InstanceUid",
              "ErrorResponse",
              "RemoteConfig",
              "ConnectionSettings",
              "PackagesAvailable",
              "Flags",
              "Capabilities",
              "AgentIdentification",
              "Command",
              "CustomCapabilities",
              "CustomMessage",
            });
    internal_static_opamp_proto_OpAMPConnectionSettings_descriptor =
        getDescriptor().getMessageTypes().get(8);
    internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_OpAMPConnectionSettings_descriptor,
            new String[] {
              "DestinationEndpoint", "Headers", "Certificate", "HeartbeatIntervalSeconds",
            });
    internal_static_opamp_proto_TelemetryConnectionSettings_descriptor =
        getDescriptor().getMessageTypes().get(9);
    internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_TelemetryConnectionSettings_descriptor,
            new String[] {
              "DestinationEndpoint", "Headers", "Certificate",
            });
    internal_static_opamp_proto_OtherConnectionSettings_descriptor =
        getDescriptor().getMessageTypes().get(10);
    internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_OtherConnectionSettings_descriptor,
            new String[] {
              "DestinationEndpoint", "Headers", "Certificate", "OtherSettings",
            });
    internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor =
        internal_static_opamp_proto_OtherConnectionSettings_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_Headers_descriptor = getDescriptor().getMessageTypes().get(11);
    internal_static_opamp_proto_Headers_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_Headers_descriptor,
            new String[] {
              "Headers",
            });
    internal_static_opamp_proto_Header_descriptor = getDescriptor().getMessageTypes().get(12);
    internal_static_opamp_proto_Header_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_Header_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_TLSCertificate_descriptor =
        getDescriptor().getMessageTypes().get(13);
    internal_static_opamp_proto_TLSCertificate_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_TLSCertificate_descriptor,
            new String[] {
              "Cert", "PrivateKey", "CaCert",
            });
    internal_static_opamp_proto_ConnectionSettingsOffers_descriptor =
        getDescriptor().getMessageTypes().get(14);
    internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ConnectionSettingsOffers_descriptor,
            new String[] {
              "Hash", "Opamp", "OwnMetrics", "OwnTraces", "OwnLogs", "OtherConnections",
            });
    internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor =
        internal_static_opamp_proto_ConnectionSettingsOffers_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_PackagesAvailable_descriptor =
        getDescriptor().getMessageTypes().get(15);
    internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackagesAvailable_descriptor,
            new String[] {
              "Packages", "AllPackagesHash",
            });
    internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor =
        internal_static_opamp_proto_PackagesAvailable_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_PackagesAvailable_PackagesEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_PackageAvailable_descriptor =
        getDescriptor().getMessageTypes().get(16);
    internal_static_opamp_proto_PackageAvailable_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackageAvailable_descriptor,
            new String[] {
              "Type", "Version", "File", "Hash",
            });
    internal_static_opamp_proto_DownloadableFile_descriptor =
        getDescriptor().getMessageTypes().get(17);
    internal_static_opamp_proto_DownloadableFile_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_DownloadableFile_descriptor,
            new String[] {
              "DownloadUrl", "ContentHash", "Signature", "Headers",
            });
    internal_static_opamp_proto_ServerErrorResponse_descriptor =
        getDescriptor().getMessageTypes().get(18);
    internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ServerErrorResponse_descriptor,
            new String[] {
              "Type", "ErrorMessage", "RetryInfo", "Details",
            });
    internal_static_opamp_proto_RetryInfo_descriptor = getDescriptor().getMessageTypes().get(19);
    internal_static_opamp_proto_RetryInfo_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_RetryInfo_descriptor,
            new String[] {
              "RetryAfterNanoseconds",
            });
    internal_static_opamp_proto_ServerToAgentCommand_descriptor =
        getDescriptor().getMessageTypes().get(20);
    internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ServerToAgentCommand_descriptor,
            new String[] {
              "Type",
            });
    internal_static_opamp_proto_AgentDescription_descriptor =
        getDescriptor().getMessageTypes().get(21);
    internal_static_opamp_proto_AgentDescription_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentDescription_descriptor,
            new String[] {
              "IdentifyingAttributes", "NonIdentifyingAttributes",
            });
    internal_static_opamp_proto_ComponentHealth_descriptor =
        getDescriptor().getMessageTypes().get(22);
    internal_static_opamp_proto_ComponentHealth_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ComponentHealth_descriptor,
            new String[] {
              "Healthy",
              "StartTimeUnixNano",
              "LastError",
              "Status",
              "StatusTimeUnixNano",
              "ComponentHealthMap",
            });
    internal_static_opamp_proto_ComponentHealth_ComponentHealthMapEntry_descriptor =
        internal_static_opamp_proto_ComponentHealth_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_ComponentHealth_ComponentHealthMapEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_ComponentHealth_ComponentHealthMapEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_EffectiveConfig_descriptor =
        getDescriptor().getMessageTypes().get(23);
    internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_EffectiveConfig_descriptor,
            new String[] {
              "ConfigMap",
            });
    internal_static_opamp_proto_RemoteConfigStatus_descriptor =
        getDescriptor().getMessageTypes().get(24);
    internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_RemoteConfigStatus_descriptor,
            new String[] {
              "LastRemoteConfigHash", "Status", "ErrorMessage",
            });
    internal_static_opamp_proto_PackageStatuses_descriptor =
        getDescriptor().getMessageTypes().get(25);
    internal_static_opamp_proto_PackageStatuses_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackageStatuses_descriptor,
            new String[] {
              "Packages", "ServerProvidedAllPackagesHash", "ErrorMessage",
            });
    internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor =
        internal_static_opamp_proto_PackageStatuses_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_PackageStatuses_PackagesEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_PackageStatus_descriptor =
        getDescriptor().getMessageTypes().get(26);
    internal_static_opamp_proto_PackageStatus_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackageStatus_descriptor,
            new String[] {
              "Name",
              "AgentHasVersion",
              "AgentHasHash",
              "ServerOfferedVersion",
              "ServerOfferedHash",
              "Status",
              "ErrorMessage",
              "DownloadDetails",
            });
    internal_static_opamp_proto_PackageDownloadDetails_descriptor =
        getDescriptor().getMessageTypes().get(27);
    internal_static_opamp_proto_PackageDownloadDetails_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_PackageDownloadDetails_descriptor,
            new String[] {
              "DownloadPercent", "DownloadBytesPerSecond",
            });
    internal_static_opamp_proto_AgentIdentification_descriptor =
        getDescriptor().getMessageTypes().get(28);
    internal_static_opamp_proto_AgentIdentification_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentIdentification_descriptor,
            new String[] {
              "NewInstanceUid",
            });
    internal_static_opamp_proto_AgentRemoteConfig_descriptor =
        getDescriptor().getMessageTypes().get(29);
    internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentRemoteConfig_descriptor,
            new String[] {
              "Config", "ConfigHash",
            });
    internal_static_opamp_proto_AgentConfigMap_descriptor =
        getDescriptor().getMessageTypes().get(30);
    internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentConfigMap_descriptor,
            new String[] {
              "ConfigMap",
            });
    internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor =
        internal_static_opamp_proto_AgentConfigMap_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor,
            new String[] {
              "Key", "Value",
            });
    internal_static_opamp_proto_AgentConfigFile_descriptor =
        getDescriptor().getMessageTypes().get(31);
    internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_AgentConfigFile_descriptor,
            new String[] {
              "Body", "ContentType",
            });
    internal_static_opamp_proto_CustomCapabilities_descriptor =
        getDescriptor().getMessageTypes().get(32);
    internal_static_opamp_proto_CustomCapabilities_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_CustomCapabilities_descriptor,
            new String[] {
              "Capabilities",
            });
    internal_static_opamp_proto_CustomMessage_descriptor =
        getDescriptor().getMessageTypes().get(33);
    internal_static_opamp_proto_CustomMessage_fieldAccessorTable =
        new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
            internal_static_opamp_proto_CustomMessage_descriptor,
            new String[] {
              "Capability", "Type", "Data",
            });
    Anyvalue.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
