import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
  id "maven-publish"
  id "signing"
  id "java"
  alias catalog.plugins.shadow
  alias catalog.plugins.taskinfo
}

description = rootProject.description + " agent"

base.archivesName.set("elastic-otel-javaagent")

apply from: "$rootDir/gradle/shadow.gradle"

def relocatePackages = ext.relocatePackages

configurations {
  // this configuration collects libs that will be placed in the bootstrap classloader
  bootstrapLibs {
    canBeResolved = true
    canBeConsumed = false
  }
  // this configuration collects libs that will be placed in the agent classloader, isolated from the instrumented application code
  javaagentLibs {
    canBeResolved = true
    canBeConsumed = false
  }
  // this configuration stores the upstream agent dep that's extended by this project
  upstreamAgent {
    canBeResolved = true
    canBeConsumed = false
  }
}

dependencies {

  // required to access OpenTelemetryAgent
  compileOnly(catalog.opentelemetryJavaagentBootstrap)

  bootstrapLibs(project(":bootstrap"))

  javaagentLibs(project(":custom"))
  javaagentLibs(project(":resources"))

  // This is where we should add custom instrumentations
  // javaagentLibs(project(":instrumentation:servlet-3"))

  upstreamAgent(catalog.opentelemetryJavaagent)
}

CopySpec isolateClasses(Iterable<File> jars) {
  return copySpec {
    jars.forEach {
      from(zipTree(it)) {
        into("inst")
        rename("^(.*)\\.class\$", "\$1.classdata")
        // Rename LICENSE file since it clashes with license dir on non-case sensitive FSs (i.e. Mac)
        rename("^LICENSE\$", "LICENSE.renamed")
        exclude("META-INF/INDEX.LIST")
        exclude("META-INF/*.DSA")
        exclude("META-INF/*.SF")
      }
    }
  }
}

tasks {

  jar {
    enabled = false
  }

  // building the final javaagent jar is done in 3 steps:

  // 1. all distro specific javaagent libs are relocated
  task relocateJavaagentLibs(type: ShadowJar) {
    configurations = [project.configurations.javaagentLibs]

    duplicatesStrategy = DuplicatesStrategy.FAIL

    archiveFileName.set("javaagentLibs-relocated.jar")

    mergeServiceFiles()
    exclude("**/module-info.class")
    relocatePackages(it)

    // exclude known bootstrap dependencies - they can't appear in the inst/ directory
    dependencies {
      exclude("io.opentelemetry:opentelemetry-api")
      exclude("io.opentelemetry:opentelemetry-api-events")
      exclude("io.opentelemetry:opentelemetry-context")
      exclude("io.opentelemetry:opentelemetry-semconv")
      // metrics advice API
      exclude("io.opentelemetry:opentelemetry-extension-incubator")
    }
  }

  // 2. the distro javaagent libs are then isolated - moved to the inst/ directory
  // having a separate task for isolating javaagent libs is required to avoid duplicates with the upstream javaagent
  // duplicatesStrategy in shadowJar won't be applied when adding files with with(CopySpec) because each CopySpec has
  // its own duplicatesStrategy
  task isolateJavaagentLibs(type: Copy) {
    dependsOn(tasks.relocateJavaagentLibs)
    with isolateClasses(tasks.relocateJavaagentLibs.outputs.files)

    into("$buildDir/isolated/javaagentLibs")
  }

  // 3. the relocated and isolated javaagent libs are merged together with the bootstrap libs (which undergo relocation
  // in this task) and the upstream javaagent jar; duplicates are removed
  shadowJar {
    configurations = [project.configurations.bootstrapLibs, project.configurations.upstreamAgent]

    dependsOn(tasks.isolateJavaagentLibs)
    from(tasks.isolateJavaagentLibs.outputs)

    archiveClassifier.set(null)

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    mergeServiceFiles {
      include("inst/META-INF/services/*")
    }
    exclude("**/module-info.class")
    relocatePackages(it)

    manifest {
      attributes.put("Main-Class", "co.elastic.otel.agent.ElasticAgent")
      attributes.put("Agent-Class", "co.elastic.otel.agent.ElasticAgent")
      attributes.put("Premain-Class", "co.elastic.otel.agent.ElasticAgent")
      attributes.put("Can-Redefine-Classes", "true")
      attributes.put("Can-Retransform-Classes", "true")
      attributes.put("Implementation-Vendor", "Elastic")
      attributes.put("Implementation-Title", "co.elastic.otel:elastic-otel-javaagent")
      attributes.put("Implementation-Version", project.version)
      // TODO : add git hash to version for easier support with SCM-Revision
    }
  }

  assemble {
    dependsOn(shadowJar, javadocJar, sourcesJar)
  }

}

publishing {
  publications {
    agentJar(MavenPublication) {
      artifactId = 'elastic-otel-javaagent'

      artifact shadowJar
      artifact sourcesJar
      artifact javadocJar

      pom {
        name = project.description
        description = project.description
        url = "https://github.com/elastic/elastic-otel-java"
        licenses {
          license {
            name = "The Apache License, Version 2.0"
            url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
          }
        }
        developers {
          developer {
            name = "Elastic Inc."
            url = "https://www.elastic.co"
          }
        }
        scm {
          connection = "scm:git:git@github.com:elastic/elastic-otel-java.git"
          developerConnection = "scm:git:git@github.com:elastic/elastic-otel-java.git"
          url = "https://github.com/elastic/elastic-otel-java"
        }
      }
    }
  }
}

signing {
  setRequired({
    // only sign in CI
    System.getenv("CI") == "true"
  })
  // use in-memory ascii-armored key in environment variables
  useInMemoryPgpKeys(System.getenv("KEY_ID_SECRET"), System.getenv("SECRING_ASC"), System.getenv("KEYPASS_SECRET"))
  sign publishing.publications.agentJar
}
